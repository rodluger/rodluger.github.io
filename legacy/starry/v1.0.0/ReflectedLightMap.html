

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Maps in reflected light &mdash; starry 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script type="text/javascript" src="_static/js/hacks.js"></script>
        <script type="text/javascript" src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
        <script type="text/javascript" src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Keplerian systems" href="Kepler.html" />
    <link rel="prev" title="Radial velocity maps" href="RadialVelocityMap.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> starry
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html"> Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="changes.html"> New in version 1.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html"> Examples &amp; tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api.html"> API</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="MapFactory.html">Maps</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="SphericalHarmonicMap.html">Spherical harmonic maps</a></li>
<li class="toctree-l3"><a class="reference internal" href="LimbDarkenedMap.html">Limb darkened maps</a></li>
<li class="toctree-l3"><a class="reference internal" href="RadialVelocityMap.html">Radial velocity maps</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Maps in reflected light</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Kepler.html">Keplerian systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="linalg.html">Linear Algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="config.html">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extensions.html"> Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer.html"> Developer</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/rodluger/starry"> Github</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/rodluger/starry/issues"> Submit an issue</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ui.adsabs.harvard.edu/public-libraries/b0KqtPtYRj6I7T8eAZc5Ig"> Papers</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">starry</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="api.html">The starry Python API</a> &raquo;</li>
        
          <li><a href="MapFactory.html">Maps</a> &raquo;</li>
        
      <li>Maps in reflected light</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="maps-in-reflected-light">
<h1>Maps in reflected light<a class="headerlink" href="#maps-in-reflected-light" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">starry.</code><code class="sig-name descname">Map</code></dt>
<dd><p>The reflected light <code class="docutils literal notranslate"><span class="pre">starry</span></code> map class.</p>
<p>This class handles light curves and phase curves of objects viewed
in reflected light. It has all the same attributes and methods as
<code class="xref py py-class docutils literal notranslate"><span class="pre">starry.maps.YlmBase</span></code>, with the
additions and modifications listed below.</p>
<p>The spherical harmonic coefficients of a map in reflected light are
an expansion of the object’s <em>albedo</em> (instead of its emissivity, in
the default case).</p>
<p>The illumination source is currently assumed to be a point source for
the purposes of computing the illumination profile on the surface of the
body. However, if the illumination source occults the body, the flux
<em>is</em> computed correctly (i.e., the occulting body has a finite radius).
This approximation holds if the distance between the occultor and the source
is large compared to the size of the source. It fails, for example, in the
case of an extremely short-period planet, in which case signficantly more
than half the planet surface is illuminated by the star at any given time.
We plan to account for this effect in the future, so stay tuned.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">xo</span></code>, <code class="docutils literal notranslate"><span class="pre">yo</span></code>, and <code class="docutils literal notranslate"><span class="pre">zo</span></code> parameters in several of the methods below
specify the position of the illumination source in units of this body’s
radius. The flux returned by the <code class="xref py py-meth docutils literal notranslate"><span class="pre">flux()</span></code> method is normalized such
that when the distance between the occultor and the illumination source is
unity, a uniform unit-amplitude map will emit a flux of unity when viewed
at noon.</p>
<p>This class does not currently support occultations. If an occultation
does occur, a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised. Support for occultations in
reflected light will be added in an upcoming version, so stay tuned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Instantiate this class by calling
<a class="reference internal" href="MapFactory.html#starry.Map" title="starry.Map"><code class="xref py py-func docutils literal notranslate"><span class="pre">starry.Map()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">ydeg</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">reflected</span></code> set to True.</p>
</div>
<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">N</code></dt>
<dd><p>Total number of map coefficients. <em>Read-only</em></p>
<p>This is equal to <span class="math notranslate nohighlight">\(N_\mathrm{y} + N_\mathrm{u} + N_\mathrm{f}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">Nf</code></dt>
<dd><p>Number of spherical harmonic coefficients in the filter. <em>Read-only</em></p>
<p>This is equal to <span class="math notranslate nohighlight">\((f_\mathrm{deg} + 1)^2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">Nu</code></dt>
<dd><p>Number of limb darkening coefficients, including <span class="math notranslate nohighlight">\(u_0\)</span>. <em>Read-only</em></p>
<p>This is equal to <span class="math notranslate nohighlight">\(u_\mathrm{deg} + 1\)</span>.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">Ny</code></dt>
<dd><p>Number of spherical harmonic coefficients. <em>Read-only</em></p>
<p>This is equal to <span class="math notranslate nohighlight">\((y_\mathrm{deg} + 1)^2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">amp</code></dt>
<dd><p>The overall amplitude of the map in arbitrary units. This factor
multiplies the intensity and the flux and is thus proportional to the
luminosity of the object. For multi-wavelength maps, this is a vector
corresponding to the amplitude of each wavelength bin.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">angle_unit</code></dt>
<dd><p>An <code class="docutils literal notranslate"><span class="pre">astropy.units</span></code> unit defining the angle metric for this map.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">deg</code></dt>
<dd><p>Total degree of the map. <em>Read-only</em></p>
<p>This is equal to <span class="math notranslate nohighlight">\(y_\mathrm{deg} + u_\mathrm{deg} + f_\mathrm{deg}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">design_matrix</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Compute and return the light curve design matrix, <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>This matrix is used to compute the flux <span class="math notranslate nohighlight">\(f\)</span> from a vector of spherical
harmonic coefficients <span class="math notranslate nohighlight">\(y\)</span> and the map amplitude <span class="math notranslate nohighlight">\(a\)</span>:
<span class="math notranslate nohighlight">\(f = a A y\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – x coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>ys</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – y coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>zs</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – z coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>xo</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – x coordinate of the occultor
relative to this body in units of this body’s radius.</p></li>
<li><p><strong>yo</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – y coordinate of the occultor
relative to this body in units of this body’s radius.</p></li>
<li><p><strong>zo</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – z coordinate of the occultor
relative to this body in units of this body’s radius.</p></li>
<li><p><strong>ro</strong> (<em>scalar</em><em>, </em><em>optional</em>) – Radius of the occultor in units of
this body’s radius.</p></li>
<li><p><strong>theta</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – Angular phase of the body
in units of <code class="xref py py-attr docutils literal notranslate"><span class="pre">angle_unit</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">starry</span></code> does not yet support occultations in reflected light.</p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">draw</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Draw a map from the posterior distribution.</p>
<p>This method draws a random map from the posterior distribution and
sets the <code class="xref py py-attr docutils literal notranslate"><span class="pre">y</span></code> map vector and <code class="xref py py-attr docutils literal notranslate"><span class="pre">amp</span></code> map amplitude
accordingly. Users should call <code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code> to enable this
attribute.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">drorder</code></dt>
<dd><p>Differential rotation order. <em>Read-only</em></p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">fdeg</code></dt>
<dd><p>Degree of the multiplicative filter. <em>Read-only</em></p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">flux</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Compute and return the reflected flux from the map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – x coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>ys</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – y coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>zs</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – z coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>xo</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – x coordinate of the occultor
relative to this body in units of this body’s radius.</p></li>
<li><p><strong>yo</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – y coordinate of the occultor
relative to this body in units of this body’s radius.</p></li>
<li><p><strong>zo</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – z coordinate of the occultor
relative to this body in units of this body’s radius.</p></li>
<li><p><strong>ro</strong> (<em>scalar</em><em>, </em><em>optional</em>) – Radius of the occultor in units of
this body’s radius.</p></li>
<li><p><strong>theta</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – Angular phase of the body
in units of <code class="xref py py-attr docutils literal notranslate"><span class="pre">angle_unit</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">starry</span></code> does not yet support occultations in reflected light.</p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">intensity</code><span class="sig-paren">(</span><em class="sig-param">lat=0</em>, <em class="sig-param">lon=0</em>, <em class="sig-param">xs=0</em>, <em class="sig-param">ys=0</em>, <em class="sig-param">zs=1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Compute and return the intensity of the map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lat</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – latitude at which to evaluate
the intensity in units of <code class="xref py py-attr docutils literal notranslate"><span class="pre">angle_unit</span></code>.</p></li>
<li><p><strong>lon</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – longitude at which to evaluate
the intensity in units of <code class="xref py py-attr docutils literal notranslate"><span class="pre">angle_unit</span></code>.</p></li>
<li><p><strong>xs</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – x coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>ys</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – y coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>zs</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – z coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>theta</strong> (<em>scalar</em><em>, </em><em>optional</em>) – For differentially rotating maps only,
the angular phase at which to evaluate the intensity.
Default 0.</p></li>
<li><p><strong>limbdarken</strong> (<em>bool</em><em>, </em><em>optional</em>) – Apply limb darkening
(only if <code class="xref py py-attr docutils literal notranslate"><span class="pre">udeg</span></code> &gt; 0)? Default True.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">limbdark_is_physical</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Check whether the limb darkening profile (if any) is physical.</p>
<p>This method uses Sturm’s theorem to ensure that the limb darkening
intensity is positive everywhere and decreases monotonically toward
the limb.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Whether or not the limb darkening profile is physical.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">lnlike</code><span class="sig-paren">(</span><em class="sig-param">*</em>, <em class="sig-param">design_matrix=None</em>, <em class="sig-param">woodbury=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the log marginal likelihood of the data given a design matrix.</p>
<p>This method computes the marginal likelihood (marginalized over the
spherical harmonic coefficients) given a
light curve and its covariance (set via the <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_data()</span></code> method)
and a Gaussian prior on the spherical harmonic coefficients
(set via the <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_prior()</span></code> method).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>design_matrix</strong> (<em>matrix</em><em>, </em><em>optional</em>) – The flux design matrix, the
quantity returned by <code class="xref py py-meth docutils literal notranslate"><span class="pre">design_matrix()</span></code>. Default is
None, in which case this is computed based on <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>.</p></li>
<li><p><strong>woodbury</strong> (<em>bool</em><em>, </em><em>optional</em>) – Solve the linear problem using the
Woodbury identity? Default is True. The
<a class="reference external" href="https://en.wikipedia.org/wiki/Woodbury_matrix_identity">Woodbury identity</a>
is used to speed up matrix operations in the case that the
number of data points is much larger than the number of
spherical harmonic coefficients. In this limit, it can
speed up the code by more than an order of magnitude. Keep
in mind that the numerical stability of the Woodbury identity
is not great, so if you’re getting strange results try
disabling this. It’s also a good idea to disable this in the
limit of few data points and large spherical harmonic degree.</p></li>
<li><p><strong>kwargs</strong> (<em>optional</em>) – Keyword arguments to be passed directly to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">design_matrix()</span></code>, if a design matrix is not provided.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The log marginal likelihood, a scalar.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">nw</code></dt>
<dd><p>Number of wavelength bins. <em>Read-only</em></p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">remove_prior</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Remove the prior on the map coefficients.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">render</code><span class="sig-paren">(</span><em class="sig-param">res=300</em>, <em class="sig-param">projection='ortho'</em>, <em class="sig-param">illuminate=True</em>, <em class="sig-param">theta=0.0</em>, <em class="sig-param">xs=0</em>, <em class="sig-param">ys=0</em>, <em class="sig-param">zs=1</em><span class="sig-paren">)</span></dt>
<dd><p>Compute and return the intensity of the map on a grid.</p>
<p>Returns an image of shape <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">res)</span></code>, unless <code class="docutils literal notranslate"><span class="pre">theta</span></code> is a vector,
in which case returns an array of shape <code class="docutils literal notranslate"><span class="pre">(nframes,</span> <span class="pre">res,</span> <span class="pre">res)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">nframes</span></code> is the number of values of <code class="docutils literal notranslate"><span class="pre">theta</span></code>. However, if this is
a spectral map, <code class="docutils literal notranslate"><span class="pre">nframes</span></code> is the number of wavelength bins and
<code class="docutils literal notranslate"><span class="pre">theta</span></code> must be a scalar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>res</strong> (<em>int</em><em>, </em><em>optional</em>) – The resolution of the map in pixels on a
side. Defaults to 300.</p></li>
<li><p><strong>projection</strong> (<em>string</em><em>, </em><em>optional</em>) – The map projection. Accepted
values are <code class="docutils literal notranslate"><span class="pre">ortho</span></code>, corresponding to an orthographic
projection (as seen on the sky), and <code class="docutils literal notranslate"><span class="pre">rect</span></code>, corresponding
to an equirectangular latitude-longitude projection.
Defaults to <code class="docutils literal notranslate"><span class="pre">ortho</span></code>.</p></li>
<li><p><strong>illuminate</strong> (<em>bool</em><em>, </em><em>optional</em>) – Illuminate the map? Default is True.</p></li>
<li><p><strong>theta</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – The map rotation phase in
units of <code class="xref py py-attr docutils literal notranslate"><span class="pre">angle_unit</span></code>. If this is a vector, an
animation is generated. Defaults to <code class="docutils literal notranslate"><span class="pre">0.0</span></code>.</p></li>
<li><p><strong>xs</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – x coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>ys</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – y coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
<li><p><strong>zs</strong> (<em>scalar</em><em> or </em><em>vector</em><em>, </em><em>optional</em>) – z coordinate of the illumination
source relative to this body in units of this body’s radius.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Reset all map coefficients and attributes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Does not reset custom unit settings.</p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">set_data</code><span class="sig-paren">(</span><em class="sig-param">flux</em>, <em class="sig-param">C=None</em>, <em class="sig-param">cho_C=None</em><span class="sig-paren">)</span></dt>
<dd><p>Set the data vector and covariance matrix.</p>
<p>This method is required by the <code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code> method, which
analytically computes the posterior over surface maps given a
dataset and a prior, provided both are described as multivariate
Gaussians.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flux</strong> (<em>vector</em>) – The observed light curve.</p></li>
<li><p><strong>C</strong> (<em>scalar</em><em>, </em><em>vector</em><em>, or </em><em>matrix</em>) – The data covariance. This may be
a scalar, in which case the noise is assumed to be
homoscedastic, a vector, in which case the covariance
is assumed to be diagonal, or a matrix specifying the full
covariance of the dataset. Default is None. Either <cite>C</cite> or
<cite>cho_C</cite> must be provided.</p></li>
<li><p><strong>cho_C</strong> (<em>matrix</em>) – The lower Cholesky factorization of the data
covariance matrix. Defaults to None. Either <cite>C</cite> or
<cite>cho_C</cite> must be provided.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">set_prior</code><span class="sig-paren">(</span><em class="sig-param">*</em>, <em class="sig-param">mu=None</em>, <em class="sig-param">L=None</em>, <em class="sig-param">cho_L=None</em><span class="sig-paren">)</span></dt>
<dd><p>Set the prior mean and covariance of the spherical harmonic coefficients.</p>
<p>This method is required by the <code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code> method, which
analytically computes the posterior over surface maps given a
dataset and a prior, provided both are described as multivariate
Gaussians.</p>
<p>Note that the prior is placed on the <strong>amplitude-weighted</strong> coefficients,
i.e., the quantity <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">map.amp</span> <span class="pre">*</span> <span class="pre">map.y</span></code>. Because the first spherical
harmonic coefficient is fixed at unity, <code class="docutils literal notranslate"><span class="pre">x[0]</span></code> is
the amplitude of the map. The actual spherical harmonic coefficients
are given by <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">map.amp</span></code>.</p>
<p>This convention allows one to linearly fit for an arbitrary map normalization
at the same time as the spherical harmonic coefficients, while ensuring
the <code class="docutils literal notranslate"><span class="pre">starry</span></code> requirement that the coefficient of the <span class="math notranslate nohighlight">\(Y_{0,0}\)</span>
harmonic is always unity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> (<em>scalar</em><em> or </em><em>vector</em>) – The prior mean on the amplitude-weighted
spherical harmonic coefficients. Default is unity for the
first term and zero for the remaining terms. If this is a vector,
it must have length equal to <code class="xref py py-attr docutils literal notranslate"><span class="pre">Ny</span></code>.</p></li>
<li><p><strong>L</strong> (<em>scalar</em><em>, </em><em>vector</em><em>, or </em><em>matrix</em>) – The prior covariance. This may be
a scalar, in which case the covariance is assumed to be
homoscedastic, a vector, in which case the covariance
is assumed to be diagonal, or a matrix specifying the full
prior covariance. Default is None. Either <cite>L</cite> or
<cite>cho_L</cite> must be provided.</p></li>
<li><p><strong>cho_L</strong> (<em>matrix</em>) – The lower Cholesky factorization of the prior
covariance matrix. Defaults to None. Either <cite>L</cite> or
<cite>cho_L</cite> must be provided.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">solution</code></dt>
<dd><p>The posterior probability distribution for the map.</p>
<p>This is a tuple containing the mean and lower Cholesky factorization of the
covariance of the amplitude-weighted spherical harmonic coefficient vector,
obtained by solving the regularized least-squares problem
via the <code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code> method.</p>
<p>Note that to obtain the actual covariance matrix from the lower Cholesky
factorization <span class="math notranslate nohighlight">\(L\)</span>, simply compute <span class="math notranslate nohighlight">\(L L^\top\)</span>.</p>
<p>Note also that this is the posterior for the <strong>amplitude-weighted</strong>
map vector. Under this convention, the map amplitude is equal to the
first term of the vector and the spherical harmonic coefficients are
equal to the vector normalized by the first term.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">*</em>, <em class="sig-param">design_matrix=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Solve the linear least-squares problem for the posterior over maps.</p>
<p>This method solves the generalized least squares problem given a
light curve and its covariance (set via the <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_data()</span></code> method)
and a Gaussian prior on the spherical harmonic coefficients
(set via the <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_prior()</span></code> method). The map amplitude and
coefficients are set to the maximum a posteriori (MAP) solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>design_matrix</strong> (<em>matrix</em><em>, </em><em>optional</em>) – The flux design matrix, the
quantity returned by <code class="xref py py-meth docutils literal notranslate"><span class="pre">design_matrix()</span></code>. Default is
None, in which case this is computed based on <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>.</p></li>
<li><p><strong>kwargs</strong> (<em>optional</em>) – Keyword arguments to be passed directly to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">design_matrix()</span></code>, if a design matrix is not provided.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple containing the posterior mean for the amplitude-weighted             spherical harmonic coefficients (a vector) and the Cholesky factorization             of the posterior covariance (a lower triangular matrix).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Users may call <code class="xref py py-meth docutils literal notranslate"><span class="pre">draw()</span></code> to draw from the
posterior after calling this method.</p>
</div>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">u</code></dt>
<dd><p>The vector of limb darkening coefficients. <em>Read-only</em></p>
<p>To set this vector, index the map directly using one index:
<code class="docutils literal notranslate"><span class="pre">map[n]</span> <span class="pre">=</span> <span class="pre">...</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the degree of the limb darkening
coefficient. This may be an integer or an array of integers.
Slice notation may also be used.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">udeg</code></dt>
<dd><p>Limb darkening degree. <em>Read-only</em></p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">y</code></dt>
<dd><p>The spherical harmonic coefficient vector. <em>Read-only</em></p>
<p>To set this vector, index the map directly using two indices:
<code class="docutils literal notranslate"><span class="pre">map[l,</span> <span class="pre">m]</span> <span class="pre">=</span> <span class="pre">...</span></code> where <code class="docutils literal notranslate"><span class="pre">l</span></code> is the spherical harmonic degree and
<code class="docutils literal notranslate"><span class="pre">m</span></code> is the spherical harmonic order. These may be integers or
arrays of integers. Slice notation may also be used.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">ydeg</code></dt>
<dd><p>Spherical harmonic degree of the map. <em>Read-only</em></p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
  <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
    
    <a href="Kepler.html" class="btn btn-neutral float-right" title="Keplerian systems" accesskey="n"
      rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
    
    
    <a href="RadialVelocityMap.html" class="btn btn-neutral float-left" title="Radial velocity maps" accesskey="p"
      rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
    
  </div>
  

  <hr />

  <div role="contentinfo">
    <p>
      
      &copy; Copyright 2019, Rodrigo Luger.
      <span class="lastupdated">
        Last updated on 2020 Jan 05 at 07:06:01 UTC.
      </span>

    </p>
  </div>
  
  
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a
    href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by
  <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>