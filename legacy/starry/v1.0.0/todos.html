

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>todos &mdash; starry 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script type="text/javascript" src="_static/js/hacks.js"></script>
        <script type="text/javascript" src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
        <script type="text/javascript" src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Coverage reports" href="coverage.html" />
    <link rel="prev" title="Developer" href="developer.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> starry
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html"> Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="changes.html"> New in version 1.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html"> Examples &amp; tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html"> API</a></li>
<li class="toctree-l1"><a class="reference internal" href="extensions.html"> Extensions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="developer.html"> Developer</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">ToDo list</a></li>
<li class="toctree-l2"><a class="reference external" href="https://dev.azure.com/rodluger/starry/_build">Azure pipelines page</a></li>
<li class="toctree-l2"><a class="reference internal" href="coverage.html">Coverage reports</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/rodluger/starry"> Github</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/rodluger/starry/issues"> Submit an issue</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ui.adsabs.harvard.edu/public-libraries/b0KqtPtYRj6I7T8eAZc5Ig"> Papers</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">starry</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="developer.html">Developer</a> &raquo;</li>
        
      <li>todos</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="todos">
<h1>todos<a class="headerlink" href="#todos" title="Permalink to this headline">Â¶</a></h1>
<p>There are <strong>427</strong> todo items that need to be addressed in <code class="docutils literal notranslate"><span class="pre">starry</span></code>.</p>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/kepler.py#L1064">kepler.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        .. note::
            Users may call the :py:meth:`draw` method of this class to draw
            from the posterior after calling :py:meth:`solve`.
        &quot;&quot;&quot;
<span class="hll">        # TODO: Implement for spectral maps?
</span>        self._no_spectral()

        # Check that the data is set
        if self._flux is None or self._C is None:
            raise ValueError(&quot;Please provide a dataset with `set_data()`.&quot;)

        # Get the full design matrix
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/kepler.py#L1221">kepler.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1217
1218
1219
1220
1221
1222
1223
1224
1225
1226
1227</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">Returns</span><span class="p">:</span>
            <span class="n">lnlike</span><span class="p">:</span> <span class="n">The</span> <span class="n">log</span> <span class="n">marginal</span> <span class="n">likelihood</span><span class="o">.</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        # TODO: Implement for spectral maps?</span>
<span class="hll"><span class="s2">        self._no_spectral()</span>
</span>
<span class="s2">        # Check that the data is set</span>
<span class="s2">        if self._flux is None or self._C is None:</span>
<span class="s2">            raise ValueError(&quot;Please provide a dataset with `set_data()`.&quot;)</span>

<span class="s2">        # Get the full design matrix</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/maps.py#L2084">maps.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>2080
2081
2082
2083
2084
2085
2086
2087
2088
2089
2090
2091</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">),</span> <span class="s2">&quot;Differential rotation orders above 3 are not supported.&quot;</span>
    <span class="k">if</span> <span class="n">drorder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">ydeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Differential rotation requires `ydeg` &gt;= 1.&quot;</span>

<span class="hll">        <span class="c1"># TODO: phase this next warning out</span>
</span>        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Differential rotation is still an experimental feature. &quot;</span>
            <span class="s2">&quot;Use it with care.&quot;</span>
        <span class="p">)</span>

        <span class="n">Ddeg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">drorder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ydeg</span>
        <span class="k">if</span> <span class="n">Ddeg</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/maps.py#L2103">maps.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>2099
2100
2101
2102
2103
2104
2105
2106
2107
2108
2109</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="c1"># Limb-darkened?</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ydeg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">rv</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">reflected</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>

        <span class="c1"># TODO: Add support for wavelength-dependent limb darkening</span>
<span class="hll">        <span class="k">if</span> <span class="n">nw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span>            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Multi-wavelength limb-darkened maps are not yet supported.&quot;</span>
            <span class="p">)</span>

        <span class="n">Bases</span> <span class="o">=</span> <span class="p">(</span><span class="n">LimbDarkenedBase</span><span class="p">,</span> <span class="n">MapBase</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/core.py#L83">core.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>79
80
81
82
83
84
85
86
87
88
89
90</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">_tensordotRz</span> <span class="o">=</span> <span class="n">tensordotRzOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c_ops</span><span class="o">.</span><span class="n">tensordotRz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dotR</span> <span class="o">=</span> <span class="n">dotROp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c_ops</span><span class="o">.</span><span class="n">dotR</span><span class="p">)</span>

        <span class="c1"># Filter</span>
<span class="hll">        <span class="c1"># TODO: Make the filter operator sparse</span>
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_F</span> <span class="o">=</span> <span class="n">FOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c_ops</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_ops</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_ops</span><span class="o">.</span><span class="n">Ny</span><span class="p">)</span>

        <span class="c1"># Differential rotation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tensordotD</span> <span class="o">=</span> <span class="n">tensordotDOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c_ops</span><span class="o">.</span><span class="n">tensordotD</span><span class="p">)</span>

        <span class="c1"># Misc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spotYlm</span> <span class="o">=</span> <span class="n">spotYlmOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c_ops</span><span class="o">.</span><span class="n">spotYlm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nw</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/core.py#L106">core.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>102
103
104
105
106
107
108
109
110
111
112</pre></div></td><td class="code"><div class="highlight"><pre><span></span>                <span class="bp">self</span><span class="o">.</span><span class="n">_minimize</span> <span class="o">=</span> <span class="n">minimizeOp</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">intensity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">udeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdeg</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
<span class="hll">            <span class="c1"># TODO: Implement minimization for spectral maps?</span>
</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_minimize</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LimbDarkIsPhysical</span> <span class="o">=</span> <span class="n">LDPhysicalOp</span><span class="p">(</span><span class="n">_c_ops</span><span class="o">.</span><span class="n">nroots</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rT</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/core.py#L368">core.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>364
365
366
367
368
369
370
371
372
373
374
375</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydeg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">M</span>

        <span class="c1"># Rotate to the sky frame</span>
<span class="hll">        <span class="c1"># TODO: Do this in a single compound rotation</span>
</span>        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dotR</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dotR</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dotR</span><span class="p">(</span>
                    <span class="n">M</span><span class="p">,</span>
                    <span class="o">-</span><span class="n">tt</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">obl</span><span class="p">),</span>
                    <span class="o">-</span><span class="n">tt</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">obl</span><span class="p">),</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/core.py#L469">core.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>465
466
467
468
469
470
471
472
473
474
475
476</pre></div></td><td class="code"><div class="highlight"><pre><span></span>                <span class="o">-</span><span class="n">theta</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Rotate to the sky frame</span>
<span class="hll">        <span class="c1"># TODO: Do this in a single compound rotation</span>
</span>        <span class="n">MT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dotR</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dotR</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dotR</span><span class="p">(</span>
                    <span class="n">MT</span><span class="p">,</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/core.py#L631">core.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>627
628
629
630
631
632
633
634
635
636
637
638</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        The method `render` requires a bunch of dummy params for
        compatibility with the `System` class. This method is a
        convenience method for use in the `Map` class.
        &quot;&quot;&quot;
<span class="hll">        # TODO: There may be a bug in Theano related to
</span>        # tt.mgrid; I get different results depending on whether the
        # function is compiled using `theano.function()` or if it
        # is evaluated using `.eval()`. The small perturbation to `res`
        # is a temporary fix that ensures that `y` and `x` are of the
        # correct length in all cases I&#39;ve tested.

        # Compute the Cartesian grid
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/core.py#L1457">core.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1453
1454
1455
1456
1457
1458
1459
1460
1461
1462
1463
1464</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">sec_veq</span><span class="p">,</span>
        <span class="n">keplerian</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the observed system radial velocity (RV maps only).&quot;&quot;&quot;</span>
<span class="hll">        <span class="c1"># TODO: This method is currently very inefficient, as it</span>
</span>        <span class="c1"># calls `X` twice per call and instantiates an `orbit`</span>
        <span class="c1"># instance up to three separate times per call. We should</span>
        <span class="c1"># re-code the logic from `X()` in here to optimize it.</span>

        <span class="c1"># Compute the RV filter</span>
        <span class="n">pri_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">compute_rv_filter</span><span class="p">(</span>
            <span class="n">pri_inc</span><span class="p">,</span> <span class="n">pri_obl</span><span class="p">,</span> <span class="n">pri_veq</span><span class="p">,</span> <span class="n">pri_alpha</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/utils.py#L57">utils.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>53
54
55
56
57
58
59
60
61
62
63
64</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        - an integer (`int`, `np.int`, `np.int16`, `np.int32`, `np.int64`)
        - a numpy boolean (`np.array(True)`, `np.array(False)`)
        - a numpy float array with ndim equal to 0, 1, 2, or 3

<span class="hll">    # TODO: Cast lists to arrays and floats to np.array(float)
</span>
    &quot;&quot;&quot;
    ttype = type(arg)
    if is_theano(arg):
        return ttype
    else:
        if ttype in integers:
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/polybasis.py#L69">polybasis.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>65
66
67
68
69
70
71
72
73
74</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">bpT</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="c1"># TODO: When any of the coords are zero, there&#39;s a div</span>
<span class="hll">        <span class="c1"># by zero below. This hack fixes the issue. We should</span>
</span>        <span class="c1"># think of a better way of doing this!</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-8</span>
        <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="n">z</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="n">tol</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/include/basis.h#L47">basis.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>43
44
45
46
47
48
49
50
51
52
53</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">Compute the `P(z)` part of the Ylm vectors.</span>

<span class="cm">TODO: This can be sped up with sparse algebra.</span>
<span class="hll">
</span><span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">legendre</span><span class="p">(</span><span class="kt">int</span> <span class="n">lmax</span><span class="p">,</span>
                     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Triplet</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;&gt;&gt;</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Compute densely</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/include/filter.h#L251">filter.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>247
248
249
250
251
252
253
254
255
256
257</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">pf</span><span class="p">;</span>
    <span class="n">pf</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">A1_f</span> <span class="o">*</span> <span class="n">f</span><span class="p">;</span>

    <span class="c1">// Multiply them</span>
<span class="hll">    <span class="c1">// TODO: DpDpf and DpDpu are sparse, and we should probably exploit that</span>
</span>    <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">udeg</span> <span class="o">&gt;</span> <span class="n">fdeg</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">computePolynomialProduct</span><span class="p">(</span><span class="n">udeg</span><span class="p">,</span> <span class="n">pu</span><span class="p">,</span> <span class="n">fdeg</span><span class="p">,</span> <span class="n">pf</span><span class="p">,</span> <span class="n">DpDpu</span><span class="p">,</span> <span class="n">DpDpf</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">computePolynomialProduct</span><span class="p">(</span><span class="n">fdeg</span><span class="p">,</span> <span class="n">pf</span><span class="p">,</span> <span class="n">udeg</span><span class="p">,</span> <span class="n">pu</span><span class="p">,</span> <span class="n">DpDpf</span><span class="p">,</span> <span class="n">DpDpu</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/include/limbdark.h#L5">limbdark.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span>\file limbdark.h
\brief Limb darkening utilities from Agol, Luger &amp; Foreman-Mackey (2019).

<span class="hll">TODO: Loop downward in `v` until `J[v] != 0`
</span>TODO: Test all special cases

*/

#ifndef _STARRY_LIMBDARK_H_
#define _STARRY_LIMBDARK_H_
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/include/limbdark.h#L6">limbdark.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span>\file limbdark.h
\brief Limb darkening utilities from Agol, Luger &amp; Foreman-Mackey (2019).

TODO: Loop downward in `v` until `J[v] != 0`
<span class="hll">TODO: Test all special cases
</span>
*/

#ifndef _STARRY_LIMBDARK_H_
#define _STARRY_LIMBDARK_H_

#include &lt;cmath&gt;
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/include/misc.h#L100">misc.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 96
 97
 98
 99
100
101
102
103
104
105
106
107</pre></div></td><td class="code"><div class="highlight"><pre><span></span>                    <span class="n">RowVector</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">bamp</span><span class="p">,</span>
                    <span class="n">Scalar</span> <span class="o">&amp;</span><span class="n">bsigma</span><span class="p">,</span> <span class="n">Scalar</span> <span class="o">&amp;</span><span class="n">blat</span><span class="p">,</span> <span class="n">Scalar</span> <span class="o">&amp;</span><span class="n">blon</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// Forward diff for sigma</span>
<span class="hll">  <span class="c1">// TODO: Compute the backprop expression</span>
</span>  <span class="k">using</span> <span class="n">ADType</span> <span class="o">=</span> <span class="n">ADScalar</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">ADType</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma_</span><span class="p">;</span>
  <span class="n">sigma</span><span class="p">.</span><span class="n">derivatives</span><span class="p">()</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">Unit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Compute the integrals recursively</span>
  <span class="n">Vector</span><span class="o">&lt;</span><span class="n">ADType</span><span class="o">&gt;</span> <span class="n">IP</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Vector</span><span class="o">&lt;</span><span class="n">ADType</span><span class="o">&gt;</span> <span class="n">ID</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/include/solver_reflected.h#L180">solver_reflected.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>176
177
178
179
180
181
182
183
184
185
186</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  */
  inline Scalar compute(const Scalar &amp;bterm, const RowVector&lt;Scalar&gt; &amp;brT) {
    Scalar bb = 0.0;
    computeHI_with_grad(bterm);
<span class="hll">    // TODO: The gradient is infinite when bterm = +/- 1
</span>    // Not sure how best to handle this.
    Scalar fac = sqrt(max(Scalar(1.0) - bterm * bterm, tol));
    Scalar DfacDb = -bterm / fac;
    int n = 0;
    int i, j;
    int mu, nu;
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/include/wigner.h#L397">wigner.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>393
394
395
396
397
398
399
400
401
402
403
404</pre></div></td><td class="code"><div class="highlight"><pre><span></span>          <span class="n">tol_ad</span><span class="p">,</span> <span class="n">D_ad</span><span class="p">,</span> <span class="n">R_ad</span><span class="p">);</span>

    <span class="c1">// Extract the matrices and their derivatives</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">ydeg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">      <span class="c1">// TODO: This data copy is *very* slow; is there a better way?</span>
</span>      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">R</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">R_ad</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">).</span><span class="n">value</span><span class="p">();</span>
          <span class="n">DRDx</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">R_ad</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">).</span><span class="n">derivatives</span><span class="p">()(</span><span class="mi">0</span><span class="p">);</span>
          <span class="n">DRDy</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">R_ad</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">).</span><span class="n">derivatives</span><span class="p">()(</span><span class="mi">1</span><span class="p">);</span>
          <span class="n">DRDz</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">R_ad</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">).</span><span class="n">derivatives</span><span class="p">()(</span><span class="mi">2</span><span class="p">);</span>
          <span class="n">DRDtheta</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">R_ad</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">).</span><span class="n">derivatives</span><span class="p">()(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/include/wigner.h#L509">wigner.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>505
506
507
508
509
510
511
512
513
514
515
516</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">dotR_bM</span><span class="p">.</span><span class="n">setZero</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">Ny</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">npts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Dot them in</span>
<span class="hll">    <span class="c1">// TODO: There must be a more efficient way of doing this.</span>
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">ydeg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// d / dargs</span>
      <span class="n">dotR_bx</span> <span class="o">+=</span> <span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">DRDx</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                     <span class="p">.</span><span class="n">cwiseProduct</span><span class="p">(</span><span class="n">bMR</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                     <span class="p">.</span><span class="n">sum</span><span class="p">();</span>
      <span class="n">dotR_by</span> <span class="o">+=</span> <span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">DRDy</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                     <span class="p">.</span><span class="n">cwiseProduct</span><span class="p">(</span><span class="n">bMR</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/blas/BandTriangularSolver.h#L17">BandTriangularSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

 <span class="cm">/* \internal</span>
<span class="cm">  * Solve Ax=b with A a band triangular matrix</span>
<span class="hll"><span class="cm">  * TODO: extend it to matrices for x abd b */</span>
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Mode</span><span class="p">,</span> <span class="k">typename</span> <span class="n">LhsScalar</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ConjLhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">RhsScalar</span><span class="p">,</span> <span class="kt">int</span> <span class="n">StorageOrder</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">band_solve_triangular_selector</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Mode</span><span class="p">,</span> <span class="k">typename</span> <span class="n">LhsScalar</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ConjLhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">RhsScalar</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">band_solve_triangular_selector</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span><span class="n">Mode</span><span class="p">,</span><span class="n">LhsScalar</span><span class="p">,</span><span class="n">ConjLhs</span><span class="p">,</span><span class="n">RhsScalar</span><span class="p">,</span><span class="n">RowMajor</span><span class="o">&gt;</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/blas/PackedSelfadjointProduct.h#L34">PackedSelfadjointProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="n">size</span><span class="o">-</span><span class="nl">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">+=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">cj</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">ConjRhsType</span><span class="p">(</span><span class="n">OtherMap</span><span class="p">(</span><span class="n">vec</span><span class="o">+</span><span class="p">(</span><span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="nl">i</span> <span class="p">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="n">size</span><span class="o">-</span><span class="nl">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)));</span>
      <span class="c1">//FIXME This should be handled outside.</span>
<span class="hll">      <span class="n">mat</span><span class="p">[</span><span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numext</span><span class="o">::</span><span class="n">real</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">i</span><span class="p">]);</span>
</span>      <span class="n">mat</span> <span class="o">+=</span> <span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="n">size</span><span class="o">-</span><span class="nl">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">UpLo</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ConjLhs</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ConjRhs</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/blas/Rank2Update.h#L48">Rank2Update.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>44
45
46
47
48
49
50
51
52
53
54
55</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">{</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">mat</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="n">size</span><span class="o">-</span><span class="nl">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">+=</span>
      <span class="n">numext</span><span class="o">::</span><span class="n">conj</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">numext</span><span class="o">::</span><span class="n">conj</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">OtherMap</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="p">(</span><span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="nl">i</span> <span class="p">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="n">size</span><span class="o">-</span><span class="nl">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">numext</span><span class="o">::</span><span class="n">conj</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">OtherMap</span><span class="p">(</span><span class="n">u</span><span class="o">+</span><span class="p">(</span><span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="nl">i</span> <span class="p">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="n">size</span><span class="o">-</span><span class="nl">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="hll">      <span class="c1">//FIXME This should be handled outside.</span>
</span>      <span class="n">mat</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="p">(</span><span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">numext</span><span class="o">::</span><span class="n">real</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="p">(</span><span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">i</span><span class="p">)]);</span>
      <span class="n">offset</span> <span class="o">+=</span> <span class="n">UpLo</span><span class="o">==</span><span class="n">Lower</span> <span class="o">?</span> <span class="n">size</span><span class="o">-</span><span class="nl">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace internal</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/blas/level1_cplx_impl.h#L112">level1_cplx_impl.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>108
109
110
111
112
113
114
115
116
117</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">Reverse</span><span class="o">&lt;</span><span class="n">StridedVectorType</span><span class="o">&gt;</span> <span class="n">rvx</span><span class="p">(</span><span class="n">vx</span><span class="p">);</span>
  <span class="n">Reverse</span><span class="o">&lt;</span><span class="n">StridedVectorType</span><span class="o">&gt;</span> <span class="n">rvy</span><span class="p">(</span><span class="n">vy</span><span class="p">);</span>

  <span class="c1">// TODO implement mixed real-scalar rotations</span>
<span class="hll">       <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">incx</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">incy</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">internal</span><span class="o">::</span><span class="n">apply_rotation_in_the_plane</span><span class="p">(</span><span class="n">rvx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">JacobiRotation</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">));</span>
</span>  <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="o">*</span><span class="n">incx</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">incy</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">internal</span><span class="o">::</span><span class="n">apply_rotation_in_the_plane</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span> <span class="n">rvy</span><span class="p">,</span> <span class="n">JacobiRotation</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">));</span>
  <span class="k">else</span>                        <span class="n">internal</span><span class="o">::</span><span class="n">apply_rotation_in_the_plane</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span>  <span class="n">JacobiRotation</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/blas/level1_real_impl.h#L45">level1_real_impl.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>41
42
43
44
45
46
47
48
49
50
51</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">else</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// computes the Euclidean norm of a vector.</span>
<span class="hll"><span class="c1">// FIXME</span>
</span><span class="n">Scalar</span> <span class="n">EIGEN_BLAS_FUNC</span><span class="p">(</span><span class="n">nrm2</span><span class="p">)(</span><span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">RealScalar</span> <span class="o">*</span><span class="n">px</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">incx</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">//   std::cerr &lt;&lt; &quot;_nrm2 &quot; &lt;&lt; *n &lt;&lt; &quot; &quot; &lt;&lt; *incx &lt;&lt; &quot;\n&quot;;</span>
  <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">Scalar</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">px</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/blas/level1_real_impl.h#L88">level1_real_impl.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>84
85
86
87
88
89
90
91
92
93
94
95</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="n">Scalar</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">px</span><span class="p">);</span>
  <span class="n">Scalar</span><span class="o">*</span> <span class="n">y</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">py</span><span class="p">);</span>

<span class="hll">  <span class="c1">// TODO</span>
</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// computes the modified parameters for a Givens rotation.</span>
<span class="kt">int</span> <span class="n">EIGEN_BLAS_FUNC</span><span class="p">(</span><span class="n">rotmg</span><span class="p">)(</span><span class="n">RealScalar</span> <span class="o">*</span><span class="n">d1</span><span class="p">,</span> <span class="n">RealScalar</span> <span class="o">*</span><span class="n">d2</span><span class="p">,</span> <span class="n">RealScalar</span> <span class="o">*</span><span class="n">x1</span><span class="p">,</span> <span class="n">RealScalar</span> <span class="o">*</span><span class="n">x2</span><span class="p">,</span> <span class="n">RealScalar</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/blas/level1_real_impl.h#L96">level1_real_impl.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>92
93
94
95
96
97
98
99</pre></div></td><td class="code"><div class="highlight"><pre><span></span>// computes the modified parameters for a Givens rotation.
int EIGEN_BLAS_FUNC(rotmg)(RealScalar *d1, RealScalar *d2, RealScalar *x1, RealScalar *x2, RealScalar *param)
{
  // TODO
<span class="hll">
</span>  return 0;
}
*/
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/blas/level3_impl.h#L268">level3_impl.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>264
265
266
267
268
269
270
271
272
273
274</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="o">*</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// FIXME find a way to avoid this copy</span>
<span class="hll">  <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">ColMajor</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="o">*</span><span class="n">ldb</span><span class="p">);</span>
</span>  <span class="n">matrix</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="o">*</span><span class="n">ldb</span><span class="p">).</span><span class="n">setZero</span><span class="p">();</span>

  <span class="k">if</span><span class="p">(</span><span class="n">SIDE</span><span class="p">(</span><span class="o">*</span><span class="n">side</span><span class="p">)</span><span class="o">==</span><span class="n">LEFT</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">internal</span><span class="o">::</span><span class="n">gemm_blocking_space</span><span class="o">&lt;</span><span class="n">ColMajor</span><span class="p">,</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">blocking</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">func</span><span class="p">[</span><span class="n">code</span><span class="p">](</span><span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">lda</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">tmp</span><span class="p">.</span><span class="n">outerStride</span><span class="p">(),</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">ldb</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">blocking</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/blas/level3_impl.h#L321">level3_impl.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>317
318
319
320
321
322
323
324
325
326
327
328</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIDE</span><span class="p">(</span><span class="o">*</span><span class="n">side</span><span class="p">)</span><span class="o">==</span><span class="n">LEFT</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="cp">#if ISCOMPLEX</span>
<span class="hll">  <span class="c1">// FIXME add support for symmetric complex matrix</span>
</span>  <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">ColMajor</span><span class="o">&gt;</span> <span class="n">matA</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">UPLO</span><span class="p">(</span><span class="o">*</span><span class="n">uplo</span><span class="p">)</span><span class="o">==</span><span class="n">UP</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">matA</span><span class="p">.</span><span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Upper</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="o">*</span><span class="n">lda</span><span class="p">);</span>
    <span class="n">matA</span><span class="p">.</span><span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Lower</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="o">*</span><span class="n">lda</span><span class="p">).</span><span class="n">transpose</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">UPLO</span><span class="p">(</span><span class="o">*</span><span class="n">uplo</span><span class="p">)</span><span class="o">==</span><span class="n">LO</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/blas/level3_impl.h#L410">level3_impl.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>406
407
408
409
410
411
412
413
414
415
416
417</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="o">*</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cp">#if ISCOMPLEX</span>
<span class="hll">  <span class="c1">// FIXME add support for symmetric complex matrix</span>
</span>  <span class="k">if</span><span class="p">(</span><span class="n">UPLO</span><span class="p">(</span><span class="o">*</span><span class="n">uplo</span><span class="p">)</span><span class="o">==</span><span class="n">UP</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">OP</span><span class="p">(</span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="o">==</span><span class="n">NOTR</span><span class="p">)</span>
      <span class="n">matrix</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">ldc</span><span class="p">).</span><span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Upper</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="o">*</span><span class="n">k</span><span class="p">,</span><span class="o">*</span><span class="n">lda</span><span class="p">)</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="o">*</span><span class="n">k</span><span class="p">,</span><span class="o">*</span><span class="n">lda</span><span class="p">).</span><span class="n">transpose</span><span class="p">();</span>
    <span class="k">else</span>
      <span class="nf">matrix</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">ldc</span><span class="p">).</span><span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Upper</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="o">*</span><span class="n">k</span><span class="p">,</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="o">*</span><span class="n">lda</span><span class="p">).</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="o">*</span><span class="n">k</span><span class="p">,</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="o">*</span><span class="n">lda</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/lapack/eigenvalues.cpp#L16">eigenvalues.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// computes eigen values and vectors of a general N-by-N matrix A</span>
<span class="n">EIGEN_LAPACK_FUNC</span><span class="p">(</span><span class="n">syev</span><span class="p">,(</span><span class="kt">char</span> <span class="o">*</span><span class="n">jobz</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uplo</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lda</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">*</span> <span class="cm">/*work*/</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">lwork</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">info</span><span class="p">))</span>
<span class="p">{</span>
  <span class="c1">// TODO exploit the work buffer</span>
<span class="hll">  <span class="kt">bool</span> <span class="n">query_size</span> <span class="o">=</span> <span class="o">*</span><span class="n">lwork</span><span class="o">==-</span><span class="mi">1</span><span class="p">;</span>
</span>
  <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">jobz</span><span class="o">!=</span><span class="sc">&#39;N&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">jobz</span><span class="o">!=</span><span class="sc">&#39;V&#39;</span><span class="p">)</span>                    <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span>  <span class="nf">if</span><span class="p">(</span><span class="n">UPLO</span><span class="p">(</span><span class="o">*</span><span class="n">uplo</span><span class="p">)</span><span class="o">==</span><span class="n">INVALID</span><span class="p">)</span>                        <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
  <span class="k">else</span>  <span class="nf">if</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>                                        <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
  <span class="k">else</span>  <span class="nf">if</span><span class="p">(</span><span class="o">*</span><span class="n">lda</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>                         <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/lapack/svd.cpp#L17">svd.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span>// computes the singular values/vectors a general M-by-N matrix A using divide-and-conquer
EIGEN_LAPACK_FUNC(gesdd,(char *jobz, int *m, int* n, Scalar* a, int *lda, RealScalar *s, Scalar *u, int *ldu, Scalar *vt, int *ldvt, Scalar* /*work*/, int* lwork,
                         EIGEN_LAPACK_ARG_IF_COMPLEX(RealScalar */*rwork*/) int * /*iwork*/, int *info))
{
<span class="hll">  // TODO exploit the work buffer
</span>  bool query_size = *lwork==-1;
  int diag_size = (std::min)(*m,*n);

  *info = 0;
        if(*jobz!=&#39;A&#39; &amp;&amp; *jobz!=&#39;S&#39; &amp;&amp; *jobz!=&#39;O&#39; &amp;&amp; *jobz!=&#39;N&#39;)  *info = -1;
  else  if(*m&lt;0)                                                  *info = -2;
  else  if(*n&lt;0)                                                  *info = -3;
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/lapack/svd.cpp#L88">svd.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>84
85
86
87
88
89
90
91
92
93
94
95</pre></div></td><td class="code"><div class="highlight"><pre><span></span>// computes the singular values/vectors a general M-by-N matrix A using two sided jacobi algorithm
EIGEN_LAPACK_FUNC(gesvd,(char *jobu, char *jobv, int *m, int* n, Scalar* a, int *lda, RealScalar *s, Scalar *u, int *ldu, Scalar *vt, int *ldvt, Scalar* /*work*/, int* lwork,
                         EIGEN_LAPACK_ARG_IF_COMPLEX(RealScalar */*rwork*/) int *info))
{
<span class="hll">  // TODO exploit the work buffer
</span>  bool query_size = *lwork==-1;
  int diag_size = (std::min)(*m,*n);

  *info = 0;
        if( *jobu!=&#39;A&#39; &amp;&amp; *jobu!=&#39;S&#39; &amp;&amp; *jobu!=&#39;O&#39; &amp;&amp; *jobu!=&#39;N&#39;) *info = -1;
  else  if((*jobv!=&#39;A&#39; &amp;&amp; *jobv!=&#39;S&#39; &amp;&amp; *jobv!=&#39;O&#39; &amp;&amp; *jobv!=&#39;N&#39;)
           || (*jobu==&#39;O&#39; &amp;&amp; *jobv==&#39;O&#39;))                         *info = -2;
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/array.cpp#L202">array.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>198
199
200
201
202
203
204
205
206
207
208
209</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">VERIFY</span><span class="p">(</span> <span class="p">(</span><span class="n">m1</span><span class="o">&lt;-</span><span class="n">a</span> <span class="o">||</span> <span class="n">m1</span><span class="o">&gt;</span><span class="n">a</span><span class="p">).</span><span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">m1</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="o">&gt;</span><span class="n">a</span><span class="p">).</span><span class="n">count</span><span class="p">());</span>

  <span class="k">typedef</span> <span class="n">Array</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ArrayType</span><span class="o">::</span><span class="n">Index</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">ArrayOfIndices</span><span class="p">;</span>

<span class="hll">  <span class="c1">// TODO allows colwise/rowwise for array</span>
</span>  <span class="n">VERIFY_IS_APPROX</span><span class="p">(((</span><span class="n">m1</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">RealScalar</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)).</span><span class="n">colwise</span><span class="p">().</span><span class="n">count</span><span class="p">(),</span> <span class="n">ArrayOfIndices</span><span class="o">::</span><span class="n">Constant</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span><span class="n">rows</span><span class="p">).</span><span class="n">transpose</span><span class="p">());</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(((</span><span class="n">m1</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">RealScalar</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)).</span><span class="n">rowwise</span><span class="p">().</span><span class="n">count</span><span class="p">(),</span> <span class="n">ArrayOfIndices</span><span class="o">::</span><span class="n">Constant</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ArrayType</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">array_real</span><span class="p">(</span><span class="k">const</span> <span class="n">ArrayType</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/array_for_matrix.cpp#L145">array_for_matrix.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>141
142
143
144
145
146
147
148
149
150
151
152</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">VERIFY</span><span class="p">(</span> <span class="p">((</span><span class="n">m1</span><span class="p">.</span><span class="n">array</span><span class="p">()</span><span class="o">&lt;-</span><span class="n">a</span><span class="p">).</span><span class="n">matrix</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">m1</span><span class="p">.</span><span class="n">array</span><span class="p">()</span><span class="o">&gt;</span><span class="n">a</span><span class="p">).</span><span class="n">matrix</span><span class="p">()).</span><span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">m1</span><span class="p">.</span><span class="n">cwiseAbs</span><span class="p">().</span><span class="n">array</span><span class="p">()</span><span class="o">&gt;</span><span class="n">a</span><span class="p">).</span><span class="n">count</span><span class="p">());</span>

  <span class="k">typedef</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Index</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">VectorOfIndices</span><span class="p">;</span>

<span class="hll">  <span class="c1">// TODO allows colwise/rowwise for array</span>
</span>  <span class="n">VERIFY_IS_APPROX</span><span class="p">(((</span><span class="n">m1</span><span class="p">.</span><span class="n">array</span><span class="p">().</span><span class="n">abs</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">RealScalar</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)).</span><span class="n">matrix</span><span class="p">().</span><span class="n">colwise</span><span class="p">().</span><span class="n">count</span><span class="p">(),</span> <span class="n">VectorOfIndices</span><span class="o">::</span><span class="n">Constant</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span><span class="n">rows</span><span class="p">).</span><span class="n">transpose</span><span class="p">());</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(((</span><span class="n">m1</span><span class="p">.</span><span class="n">array</span><span class="p">().</span><span class="n">abs</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">RealScalar</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)).</span><span class="n">matrix</span><span class="p">().</span><span class="n">rowwise</span><span class="p">().</span><span class="n">count</span><span class="p">(),</span> <span class="n">VectorOfIndices</span><span class="o">::</span><span class="n">Constant</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">VectorType</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">lpNorm</span><span class="p">(</span><span class="k">const</span> <span class="n">VectorType</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/ctorleak.cpp#L14">ctorleak.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">Foo</span><span class="p">()</span>
  <span class="p">{</span>
<span class="cp">#ifdef EIGEN_EXCEPTIONS</span>
    <span class="c1">// TODO: Is this the correct way to handle this?</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">Foo</span><span class="o">::</span><span class="n">object_count</span> <span class="o">&gt;</span> <span class="n">Foo</span><span class="o">::</span><span class="n">object_limit</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Throw!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="k">throw</span> <span class="n">Foo</span><span class="o">::</span><span class="n">Fail</span><span class="p">();</span> <span class="p">}</span>
</span><span class="cp">#endif</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;+&#39;</span><span class="p">;</span>
    <span class="o">++</span><span class="n">Foo</span><span class="o">::</span><span class="n">object_count</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Foo</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/denseLM.cpp#L110">denseLM.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>106
107
108
109
110
111
112
113
114
115
116</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">info</span> <span class="o">=</span> <span class="n">lm</span><span class="p">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>

  <span class="n">VERIFY_IS_EQUAL</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="c1">//FIXME Check other parameters</span>
<span class="hll">  <span class="k">return</span> <span class="n">info</span><span class="p">;</span>
</span><span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FunctorType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">VectorType</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">test_lmder</span><span class="p">(</span><span class="n">FunctorType</span><span class="o">&amp;</span> <span class="n">functor</span><span class="p">,</span> <span class="n">VectorType</span><span class="o">&amp;</span> <span class="n">uv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">VectorType</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/denseLM.cpp#L123">denseLM.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>119
120
121
122
123
124
125
126
127
128
129
130</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">LevenbergMarquardt</span><span class="o">&lt;</span><span class="n">FunctorType</span><span class="o">&gt;</span> <span class="n">lm</span><span class="p">(</span><span class="n">functor</span><span class="p">);</span>
  <span class="n">info</span> <span class="o">=</span> <span class="n">lm</span><span class="p">.</span><span class="n">lmder1</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>

  <span class="n">VERIFY_IS_EQUAL</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="hll">  <span class="c1">//FIXME Check other parameters</span>
</span>  <span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FunctorType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">VectorType</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">test_minimizeSteps</span><span class="p">(</span><span class="n">FunctorType</span><span class="o">&amp;</span> <span class="n">functor</span><span class="p">,</span> <span class="n">VectorType</span><span class="o">&amp;</span> <span class="n">uv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">LevenbergMarquardtSpace</span><span class="o">::</span><span class="n">Status</span> <span class="n">info</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/denseLM.cpp#L141">denseLM.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>137
138
139
140
141
142
143
144
145
146
147
148</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">info</span> <span class="o">=</span> <span class="n">lm</span><span class="p">.</span><span class="n">minimizeOneStep</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">info</span><span class="o">==</span><span class="n">LevenbergMarquardtSpace</span><span class="o">::</span><span class="n">Running</span><span class="p">);</span>

  <span class="n">VERIFY_IS_EQUAL</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="hll">  <span class="c1">//FIXME Check other parameters</span>
</span>  <span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">test_denseLM_T</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">VectorType</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/dynalloc.cpp#L86">dynalloc.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>82
83
84
85
86
87
88
89
90
91
92
93</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">check_dynaligned</span><span class="p">()</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO have to be updated once we support multiple alignment values</span>
</span>  <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="n">SizeAtCompileTime</span> <span class="o">%</span> <span class="n">ALIGNMENT</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">;</span>
    <span class="n">VERIFY</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="n">NeedsToAlign</span><span class="o">==</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">VERIFY</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">UIntPtr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">%</span><span class="n">ALIGNMENT</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">obj</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/eigensolver_generalized_real.cpp#L56">eigensolver_generalized_real.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>52
53
54
55
56
57
58
59
60
61
62</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c1">// non symmetric case:</span>
  <span class="p">{</span>
    <span class="n">GeneralizedEigenSolver</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;</span> <span class="n">eig</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
    <span class="c1">// TODO enable full-prealocation of required memory, this probably requires an in-place mode for HessenbergDecomposition</span>
<span class="hll">    <span class="c1">//Eigen::internal::set_is_malloc_allowed(false);</span>
</span>    <span class="n">eig</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
    <span class="c1">//Eigen::internal::set_is_malloc_allowed(true);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">Index</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">ComplexScalar</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Dynamic</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">eig</span><span class="p">.</span><span class="n">betas</span><span class="p">()(</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">).</span><span class="k">template</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">ComplexScalar</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">-</span> <span class="n">eig</span><span class="p">.</span><span class="n">alphas</span><span class="p">()(</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="p">.</span><span class="n">norm</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">)())</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/eigensolver_selfadjoint.cpp#L153">eigensolver_selfadjoint.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>149
150
151
152
153
154
155
156
157
158
159</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">tridiag</span><span class="p">.</span><span class="n">diagonal</span><span class="p">(),</span> <span class="n">tridiag</span><span class="p">.</span><span class="n">matrixT</span><span class="p">().</span><span class="n">diagonal</span><span class="p">());</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">tridiag</span><span class="p">.</span><span class="n">subDiagonal</span><span class="p">(),</span> <span class="n">tridiag</span><span class="p">.</span><span class="n">matrixT</span><span class="p">().</span><span class="k">template</span> <span class="n">diagonal</span><span class="o">&lt;-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">RealScalar</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Dynamic</span><span class="o">&gt;</span> <span class="n">T</span> <span class="o">=</span> <span class="n">tridiag</span><span class="p">.</span><span class="n">matrixT</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span><span class="n">rows</span><span class="o">&gt;</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cols</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME check that upper and lower part are 0:</span>
</span>    <span class="c1">//VERIFY(T.topRightCorner(rows-2, cols-2).template triangularView&lt;Upper&gt;().isZero());</span>
  <span class="p">}</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">tridiag</span><span class="p">.</span><span class="n">diagonal</span><span class="p">(),</span> <span class="n">T</span><span class="p">.</span><span class="n">diagonal</span><span class="p">());</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">tridiag</span><span class="p">.</span><span class="n">subDiagonal</span><span class="p">(),</span> <span class="n">T</span><span class="p">.</span><span class="k">template</span> <span class="n">diagonal</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">MatrixType</span><span class="p">(</span><span class="n">symmC</span><span class="p">.</span><span class="k">template</span> <span class="n">selfadjointView</span><span class="o">&lt;</span><span class="n">Lower</span><span class="o">&gt;</span><span class="p">()),</span> <span class="n">tridiag</span><span class="p">.</span><span class="n">matrixQ</span><span class="p">()</span> <span class="o">*</span> <span class="n">tridiag</span><span class="p">.</span><span class="n">matrixT</span><span class="p">().</span><span class="n">eval</span><span class="p">()</span> <span class="o">*</span> <span class="n">MatrixType</span><span class="p">(</span><span class="n">tridiag</span><span class="p">.</span><span class="n">matrixQ</span><span class="p">()).</span><span class="n">adjoint</span><span class="p">());</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">MatrixType</span><span class="p">(</span><span class="n">symmC</span><span class="p">.</span><span class="k">template</span> <span class="n">selfadjointView</span><span class="o">&lt;</span><span class="n">Lower</span><span class="o">&gt;</span><span class="p">()),</span> <span class="n">tridiag</span><span class="p">.</span><span class="n">matrixQ</span><span class="p">()</span> <span class="o">*</span> <span class="n">tridiag</span><span class="p">.</span><span class="n">matrixT</span><span class="p">()</span> <span class="o">*</span> <span class="n">tridiag</span><span class="p">.</span><span class="n">matrixQ</span><span class="p">().</span><span class="n">adjoint</span><span class="p">());</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/evaluators.cpp#L264">evaluators.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>260
261
262
263
264
265
266
267
268
269
270
271</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="c1">// test direct traversal</span>
    <span class="n">Matrix3f</span> <span class="n">m3</span><span class="p">;</span>
    <span class="n">Array33f</span> <span class="n">a3</span><span class="p">;</span>
    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span> <span class="n">Matrix3f</span><span class="o">::</span><span class="n">Identity</span><span class="p">());</span>  <span class="c1">// matrix, nullary</span>
<span class="hll">    <span class="c1">// TODO: find a way to test direct traversal with array</span>
</span>    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">m3</span><span class="p">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">Matrix3f</span><span class="o">::</span><span class="n">Identity</span><span class="p">().</span><span class="n">transpose</span><span class="p">());</span>  <span class="c1">// transpose</span>
    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Matrix3f</span><span class="o">::</span><span class="n">Identity</span><span class="p">());</span>  <span class="c1">// unary</span>
    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span> <span class="n">Matrix3f</span><span class="o">::</span><span class="n">Identity</span><span class="p">()</span> <span class="o">+</span> <span class="n">Matrix3f</span><span class="o">::</span><span class="n">Zero</span><span class="p">());</span>  <span class="c1">// binary</span>
    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">m3</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">Matrix3f</span><span class="o">::</span><span class="n">Identity</span><span class="p">().</span><span class="n">block</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>  <span class="c1">// block</span>

    <span class="c1">// test linear traversal</span>
    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span> <span class="n">Matrix3f</span><span class="o">::</span><span class="n">Zero</span><span class="p">());</span>  <span class="c1">// matrix, nullary</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/evaluators.cpp#L283">evaluators.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>279
280
281
282
283
284
285
286
287
288
289
290</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">Array44f</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a4src</span> <span class="o">=</span> <span class="n">Matrix4f</span><span class="o">::</span><span class="n">Random</span><span class="p">();</span>
    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">m4</span><span class="p">,</span> <span class="n">m4src</span><span class="p">);</span>  <span class="c1">// matrix</span>
    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">a4</span><span class="p">,</span> <span class="n">a4src</span><span class="p">);</span>  <span class="c1">// array</span>
    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">m4</span><span class="p">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">m4src</span><span class="p">.</span><span class="n">transpose</span><span class="p">());</span>  <span class="c1">// transpose</span>
<span class="hll">    <span class="c1">// TODO: find out why Matrix4f::Zero() does not allow inner vectorization</span>
</span>    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">m4</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m4src</span><span class="p">);</span>  <span class="c1">// unary</span>
    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">m4</span><span class="p">,</span> <span class="n">m4src</span> <span class="o">+</span> <span class="n">m4src</span><span class="p">);</span>  <span class="c1">// binary</span>

    <span class="c1">// test linear vectorization</span>
    <span class="n">MatrixXf</span> <span class="nf">mX</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">mXsrc</span> <span class="o">=</span> <span class="n">MatrixXf</span><span class="o">::</span><span class="n">Random</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">ArrayXXf</span> <span class="nf">aX</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">aXsrc</span> <span class="o">=</span> <span class="n">ArrayXXf</span><span class="o">::</span><span class="n">Random</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">VERIFY_IS_APPROX_EVALUATOR</span><span class="p">(</span><span class="n">mX</span><span class="p">,</span> <span class="n">mXsrc</span><span class="p">);</span>  <span class="c1">// matrix</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/geo_quaternion.cpp#L243">geo_quaternion.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>239
240
241
242
243
244
245
246
247
248
249
250</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">const</span> <span class="n">Quaternionx</span><span class="o">&amp;</span> <span class="n">cq3</span><span class="p">(</span><span class="n">q3</span><span class="p">);</span>
  <span class="n">VERIFY</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">cq3</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">q3</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="p">);</span>
  <span class="k">const</span> <span class="n">MQuaternionUA</span><span class="o">&amp;</span> <span class="n">cmq3</span><span class="p">(</span><span class="n">mq3</span><span class="p">);</span>
  <span class="n">VERIFY</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">cmq3</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">mq3</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="p">);</span>
<span class="hll">  <span class="c1">// FIXME the following should be ok. The problem is that currently the LValueBit flag</span>
</span>  <span class="c1">// is used to determine wether we can return a coeff by reference or not, which is not enough for Map&lt;const ...&gt;.</span>
  <span class="c1">//const MCQuaternionUA&amp; cmcq3(mcq3);</span>
  <span class="c1">//VERIFY( &amp;cmcq3.x() == &amp;mcq3.x() );</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">quaternionAlignment</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="k">typedef</span> <span class="n">Quaternion</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">AutoAlign</span><span class="o">&gt;</span> <span class="n">QuaternionA</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/geo_transformations.cpp#L169">geo_transformations.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>165
166
167
168
169
170
171
172
173
174
175
176</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">AngleAxisx</span><span class="p">(</span><span class="n">m</span><span class="p">).</span><span class="n">toRotationMatrix</span><span class="p">(),</span>
    <span class="n">Quaternionx</span><span class="p">(</span><span class="n">m</span><span class="p">).</span><span class="n">toRotationMatrix</span><span class="p">());</span>

  <span class="c1">// Transform</span>
<span class="hll">  <span class="c1">// TODO complete the tests !</span>
</span>  <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">(</span><span class="mf">0.1</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">random</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="n">Scalar</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span><span class="o">*</span><span class="n">Scalar</span><span class="p">(</span><span class="n">EIGEN_PI</span><span class="p">),</span> <span class="n">Scalar</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span><span class="o">*</span><span class="n">Scalar</span><span class="p">(</span><span class="n">EIGEN_PI</span><span class="p">));</span>
  <span class="n">q1</span> <span class="o">=</span> <span class="n">AngleAxisx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v0</span><span class="p">.</span><span class="n">normalized</span><span class="p">());</span>
  <span class="n">Transform3</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// first test setIdentity() and Identity()</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/hessenberg.cpp#L49">hessenberg.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>45
46
47
48
49
50
51
52
53
54
55
56</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">VERIFY_RAISES_ASSERT</span><span class="p">(</span> <span class="n">hessUninitialized</span><span class="p">.</span><span class="n">matrixQ</span><span class="p">()</span> <span class="p">);</span>
  <span class="n">VERIFY_RAISES_ASSERT</span><span class="p">(</span> <span class="n">hessUninitialized</span><span class="p">.</span><span class="n">householderCoefficients</span><span class="p">()</span> <span class="p">);</span>
  <span class="n">VERIFY_RAISES_ASSERT</span><span class="p">(</span> <span class="n">hessUninitialized</span><span class="p">.</span><span class="n">packedMatrix</span><span class="p">()</span> <span class="p">);</span>

<span class="hll">  <span class="c1">// TODO: Add tests for packedMatrix() and householderCoefficients()</span>
</span><span class="p">}</span>

<span class="kt">void</span> <span class="n">test_hessenberg</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">CALL_SUBTEST_1</span><span class="p">((</span> <span class="n">hessenberg</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">));</span>
  <span class="n">CALL_SUBTEST_2</span><span class="p">((</span> <span class="n">hessenberg</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">));</span>
  <span class="n">CALL_SUBTEST_3</span><span class="p">((</span> <span class="n">hessenberg</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">));</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/nomalloc.cpp#L152">nomalloc.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>148
149
150
151
152
153
154
155
156
157
158
159</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">Eigen</span><span class="o">::</span><span class="n">ColPivHouseholderQR</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&gt;</span>  <span class="n">cpQR</span><span class="p">;</span> <span class="n">cpQR</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
  <span class="n">X</span> <span class="o">=</span> <span class="n">cpQR</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">cpQR</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">FullPivHouseholderQR</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&gt;</span> <span class="n">fpQR</span><span class="p">;</span> <span class="n">fpQR</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="hll">  <span class="c1">// FIXME X = fpQR.solve(B);</span>
</span>  <span class="n">x</span> <span class="o">=</span> <span class="n">fpQR</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

  <span class="c1">// SVD module</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">JacobiSVD</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&gt;</span> <span class="n">jSVD</span><span class="p">;</span> <span class="n">jSVD</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ComputeFullU</span> <span class="o">|</span> <span class="n">ComputeFullV</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">test_zerosized</span><span class="p">()</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/prec_inverse_4x4.cpp#L52">prec_inverse_4x4.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>48
49
50
51
52
53
54
55
56
57
58
59</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;inverse_general_4x4, Scalar = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">type_name</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">error_avg</span> <span class="o">=</span> <span class="n">error_sum</span> <span class="o">/</span> <span class="n">repeat</span><span class="p">;</span>
  <span class="n">EIGEN_DEBUG_VAR</span><span class="p">(</span><span class="n">error_avg</span><span class="p">);</span>
  <span class="n">EIGEN_DEBUG_VAR</span><span class="p">(</span><span class="n">error_max</span><span class="p">);</span>
<span class="hll">   <span class="c1">// FIXME that 1.25 used to be a 1.0 until the NumTraits changes on 28 April 2010, what&#39;s going wrong??</span>
</span>   <span class="c1">// FIXME that 1.25 used to be 1.2 until we tested gcc 4.1 on 30 June 2010 and got 1.21.</span>
  <span class="n">VERIFY</span><span class="p">(</span><span class="n">error_avg</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">IsComplex</span> <span class="o">?</span> <span class="mf">8.0</span> <span class="o">:</span> <span class="mf">1.25</span><span class="p">));</span>
  <span class="n">VERIFY</span><span class="p">(</span><span class="n">error_max</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">IsComplex</span> <span class="o">?</span> <span class="mf">64.0</span> <span class="o">:</span> <span class="mf">20.0</span><span class="p">));</span>

  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span><span class="c1">//internal::random&lt;int&gt;(4,10);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//internal::random&lt;int&gt;(0,s-4);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/prec_inverse_4x4.cpp#L53">prec_inverse_4x4.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="kt">double</span> <span class="n">error_avg</span> <span class="o">=</span> <span class="n">error_sum</span> <span class="o">/</span> <span class="n">repeat</span><span class="p">;</span>
  <span class="n">EIGEN_DEBUG_VAR</span><span class="p">(</span><span class="n">error_avg</span><span class="p">);</span>
  <span class="n">EIGEN_DEBUG_VAR</span><span class="p">(</span><span class="n">error_max</span><span class="p">);</span>
   <span class="c1">// FIXME that 1.25 used to be a 1.0 until the NumTraits changes on 28 April 2010, what&#39;s going wrong??</span>
<span class="hll">   <span class="c1">// FIXME that 1.25 used to be 1.2 until we tested gcc 4.1 on 30 June 2010 and got 1.21.</span>
</span>  <span class="n">VERIFY</span><span class="p">(</span><span class="n">error_avg</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">IsComplex</span> <span class="o">?</span> <span class="mf">8.0</span> <span class="o">:</span> <span class="mf">1.25</span><span class="p">));</span>
  <span class="n">VERIFY</span><span class="p">(</span><span class="n">error_max</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">IsComplex</span> <span class="o">?</span> <span class="mf">64.0</span> <span class="o">:</span> <span class="mf">20.0</span><span class="p">));</span>

  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span><span class="c1">//internal::random&lt;int&gt;(4,10);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//internal::random&lt;int&gt;(0,s-4);</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//internal::random&lt;int&gt;(0,s-4);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/product_large.cpp#L63">product_large.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>59
60
61
62
63
64
65
66
67
68
69
70</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>

  <span class="p">{</span>
    <span class="c1">// check the functions to setup blocking sizes compile and do not segfault</span>
<span class="hll">    <span class="c1">// FIXME check they do what they are supposed to do !!</span>
</span>    <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">random</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="mi">20000</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">random</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100000</span><span class="p">,</span><span class="mi">200000</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">l3</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">random</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1000000</span><span class="p">,</span><span class="mi">2000000</span><span class="p">);</span>
    <span class="n">setCpuCacheSizes</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">l3</span><span class="p">);</span>
    <span class="n">VERIFY</span><span class="p">(</span><span class="n">l1</span><span class="o">==</span><span class="n">l1CacheSize</span><span class="p">());</span>
    <span class="n">VERIFY</span><span class="p">(</span><span class="n">l2</span><span class="o">==</span><span class="n">l2CacheSize</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">k1</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">random</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/product_trmm.cpp#L80">product_trmm.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>76
77
78
79
80
81
82
83
84
85
86
87</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span> <span class="n">ge_xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="o">*</span><span class="n">mat</span><span class="p">).</span><span class="n">adjoint</span><span class="p">().</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Mode</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">*</span> <span class="n">ge_left</span><span class="p">.</span><span class="n">adjoint</span><span class="p">(),</span> <span class="n">numext</span><span class="o">::</span><span class="n">conj</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">*</span> <span class="n">triTr</span><span class="p">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">ge_left</span><span class="p">.</span><span class="n">adjoint</span><span class="p">());</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span> <span class="n">ge_xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="o">*</span><span class="n">mat</span><span class="p">).</span><span class="n">transpose</span><span class="p">().</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Mode</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">*</span> <span class="n">ge_left</span><span class="p">.</span><span class="n">adjoint</span><span class="p">(),</span> <span class="n">s1triTr</span> <span class="o">*</span> <span class="n">ge_left</span><span class="p">.</span><span class="n">adjoint</span><span class="p">());</span>


<span class="hll">  <span class="c1">// TODO check with sub-matrix expressions ?</span>
</span><span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">TriOrder</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">trmv</span><span class="p">(</span><span class="kt">int</span> <span class="n">rows</span><span class="o">=</span><span class="n">get_random_size</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">(),</span> <span class="kt">int</span> <span class="n">cols</span><span class="o">=</span><span class="n">get_random_size</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">())</span>
<span class="p">{</span>
  <span class="n">trmm</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Mode</span><span class="p">,</span><span class="n">TriOrder</span><span class="p">,</span><span class="n">ColMajor</span><span class="p">,</span><span class="n">ColMajor</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/product_trmv.cpp#L71">product_trmv.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>67
68
69
70
71
72
73
74
75
76
77
78</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">VERIFY</span><span class="p">((</span><span class="n">v1</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">m3</span><span class="p">).</span><span class="n">isApprox</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">m1</span><span class="p">.</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Lower</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">largerEps</span><span class="p">));</span>
  <span class="n">VERIFY</span><span class="p">((</span><span class="n">v1</span><span class="p">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">m3</span><span class="p">).</span><span class="n">isApprox</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">m1</span><span class="p">.</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Lower</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">largerEps</span><span class="p">));</span>
  <span class="n">VERIFY</span><span class="p">((</span><span class="n">v1</span><span class="p">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">m3</span><span class="p">.</span><span class="n">adjoint</span><span class="p">()).</span><span class="n">isApprox</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">m1</span><span class="p">.</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Lower</span><span class="o">&gt;</span><span class="p">().</span><span class="n">adjoint</span><span class="p">(),</span> <span class="n">largerEps</span><span class="p">));</span>

<span class="hll">  <span class="c1">// TODO check with sub-matrices</span>
</span><span class="p">}</span>

<span class="kt">void</span> <span class="n">test_product_trmv</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g_repeat</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CALL_SUBTEST_1</span><span class="p">(</span> <span class="n">trmv</span><span class="p">(</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/qr.cpp#L41">qr.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Rows</span><span class="p">,</span><span class="n">Cols</span><span class="o">&gt;</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Rows</span><span class="p">,</span><span class="n">Cols</span><span class="o">&gt;::</span><span class="n">Random</span><span class="p">();</span>
  <span class="n">HouseholderQR</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Rows</span><span class="p">,</span><span class="n">Cols</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">qr</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>

  <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Rows</span><span class="p">,</span><span class="n">Cols</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">qr</span><span class="p">.</span><span class="n">matrixQR</span><span class="p">();</span>
<span class="hll">  <span class="c1">// FIXME need better way to construct trapezoid</span>
</span>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">j</span><span class="p">)</span> <span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">qr</span><span class="p">.</span><span class="n">householderQ</span><span class="p">()</span> <span class="o">*</span> <span class="n">r</span><span class="p">);</span>

  <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Cols</span><span class="p">,</span><span class="n">Cols2</span><span class="o">&gt;</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Cols</span><span class="p">,</span><span class="n">Cols2</span><span class="o">&gt;::</span><span class="n">Random</span><span class="p">(</span><span class="n">Cols</span><span class="p">,</span><span class="n">Cols2</span><span class="p">);</span>
  <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Rows</span><span class="p">,</span><span class="n">Cols2</span><span class="o">&gt;</span> <span class="n">m3</span> <span class="o">=</span> <span class="n">m1</span><span class="o">*</span><span class="n">m2</span><span class="p">;</span>
  <span class="n">m2</span> <span class="o">=</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Cols</span><span class="p">,</span><span class="n">Cols2</span><span class="o">&gt;::</span><span class="n">Random</span><span class="p">(</span><span class="n">Cols</span><span class="p">,</span><span class="n">Cols2</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/qr_fullpivoting.cpp#L41">qr_fullpivoting.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>37
38
39
40
41
42
43
44
45
46
47</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">MatrixQType</span> <span class="n">q</span> <span class="o">=</span> <span class="n">qr</span><span class="p">.</span><span class="n">matrixQ</span><span class="p">();</span>
  <span class="n">VERIFY_IS_UNITARY</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

  <span class="c1">// FIXME need better way to construct trapezoid</span>
<span class="hll">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">j</span><span class="p">)</span> <span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span>
  <span class="n">MatrixType</span> <span class="n">c</span> <span class="o">=</span> <span class="n">qr</span><span class="p">.</span><span class="n">matrixQ</span><span class="p">()</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">qr</span><span class="p">.</span><span class="n">colsPermutation</span><span class="p">().</span><span class="n">inverse</span><span class="p">();</span>

  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

  <span class="c1">// stress the ReturnByValue mechanism</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/qr_fullpivoting.cpp#L132">qr_fullpivoting.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>128
129
130
131
132
133
134
135
136
137
138</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">test_qr_fullpivoting</span><span class="p">()</span>
<span class="p">{</span>
 <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// FIXME : very weird bug here</span>
<span class="hll"><span class="c1">//     CALL_SUBTEST(qr(Matrix2f()) );</span>
</span>    <span class="n">CALL_SUBTEST_1</span><span class="p">(</span> <span class="n">qr</span><span class="o">&lt;</span><span class="n">MatrixXf</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">CALL_SUBTEST_2</span><span class="p">(</span> <span class="n">qr</span><span class="o">&lt;</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">CALL_SUBTEST_3</span><span class="p">(</span> <span class="n">qr</span><span class="o">&lt;</span><span class="n">MatrixXcd</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g_repeat</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/real_qz.cpp#L46">real_qz.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>42
43
44
45
46
47
48
49
50
51
52
53</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">RealQZ</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;</span> <span class="n">qz</span><span class="p">(</span><span class="n">dim</span><span class="p">);</span>
<span class="hll">  <span class="c1">// TODO enable full-prealocation of required memory, this probably requires an in-place mode for HessenbergDecomposition</span>
</span>  <span class="c1">//Eigen::internal::set_is_malloc_allowed(false);</span>
  <span class="n">qz</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
  <span class="c1">//Eigen::internal::set_is_malloc_allowed(true);</span>

  <span class="n">VERIFY_IS_EQUAL</span><span class="p">(</span><span class="n">qz</span><span class="p">.</span><span class="n">info</span><span class="p">(),</span> <span class="n">Success</span><span class="p">);</span>
  <span class="c1">// check for zeros</span>
  <span class="kt">bool</span> <span class="n">all_zeros</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/sparse.h#L80">sparse.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>76
77
78
79
80
81
82
83
84
85
86
87</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">);</span>
      <span class="n">Scalar</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">random</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">density</span><span class="p">)</span> <span class="o">?</span> <span class="n">internal</span><span class="o">::</span><span class="n">random</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">:</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">ForceNonZeroDiag</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">))</span>
      <span class="p">{</span>
<span class="hll">        <span class="c1">// FIXME: the following is too conservative</span>
</span>        <span class="n">v</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">random</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">()</span><span class="o">*</span><span class="n">Scalar</span><span class="p">(</span><span class="mf">3.</span><span class="p">);</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">v</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">numext</span><span class="o">::</span><span class="n">real</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">v</span> <span class="o">+=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="k">else</span>                  <span class="n">v</span> <span class="o">-=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MakeLowerTriangular</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">aj</span><span class="o">&gt;</span><span class="n">ai</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/test/sparse_product.cpp#L290">sparse_product.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>286
287
288
289
290
291
292
293
294
295
296
297</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">mLo</span> <span class="o">=</span> <span class="n">mUp</span><span class="p">.</span><span class="n">adjoint</span><span class="p">();</span>
    <span class="n">refS</span> <span class="o">=</span> <span class="n">refUp</span> <span class="o">+</span> <span class="n">refLo</span><span class="p">;</span>
    <span class="n">refS</span><span class="p">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="p">;</span>
    <span class="n">mS</span> <span class="o">=</span> <span class="n">mUp</span> <span class="o">+</span> <span class="n">mLo</span><span class="p">;</span>
<span class="hll">    <span class="c1">// TODO be able to address the diagonal....</span>
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">mS</span><span class="p">.</span><span class="n">outerSize</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">typename</span> <span class="n">SparseMatrixType</span><span class="o">::</span><span class="n">InnerIterator</span> <span class="n">it</span><span class="p">(</span><span class="n">mS</span><span class="p">,</span><span class="n">k</span><span class="p">);</span> <span class="n">it</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">index</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span>
          <span class="n">it</span><span class="p">.</span><span class="n">valueRef</span><span class="p">()</span> <span class="o">*=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span>

    <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">refS</span><span class="p">.</span><span class="n">adjoint</span><span class="p">(),</span> <span class="n">refS</span><span class="p">);</span>
    <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">mS</span><span class="p">.</span><span class="n">adjoint</span><span class="p">(),</span> <span class="n">mS</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/bench/tensors/tensor_benchmarks.h#L16">tensor_benchmarks.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Tensor</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">TensorMap</span><span class="p">;</span>

<span class="c1">// TODO(bsteiner): also templatize on the input type since we have users</span>
<span class="hll"><span class="c1">// for int8 as well as floats.</span>
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Device</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">BenchmarkSuite</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">BenchmarkSuite</span><span class="p">(</span><span class="k">const</span> <span class="n">Device</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">m_</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">k_</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">n_</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">device_</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">initialize</span><span class="p">();</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/demos/opengl/camera.cpp#L104">camera.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>100
101
102
103
104
105
106
107
108
109
110
111</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span>

<span class="kt">void</span> <span class="n">Camera</span><span class="o">::</span><span class="n">setDirection</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector3f</span><span class="o">&amp;</span> <span class="n">newDirection</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">    <span class="c1">// TODO implement it computing the rotation between newDirection and current dir ?</span>
</span>    <span class="n">Vector3f</span> <span class="n">up</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>

    <span class="n">Matrix3f</span> <span class="n">camAxes</span><span class="p">;</span>

    <span class="n">camAxes</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">newDirection</span><span class="p">).</span><span class="n">normalized</span><span class="p">();</span>
    <span class="n">camAxes</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">up</span><span class="p">.</span><span class="n">cross</span><span class="p">(</span> <span class="n">camAxes</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">).</span><span class="n">normalized</span><span class="p">();</span>
    <span class="n">camAxes</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">camAxes</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">cross</span><span class="p">(</span> <span class="n">camAxes</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">).</span><span class="n">normalized</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/demos/opengl/camera.cpp#L261">camera.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>257
258
259
260
261
262
263
264</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">Vector3f</span> <span class="nf">a</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="o">/</span><span class="kt">float</span><span class="p">(</span><span class="n">mVpWidth</span><span class="p">)</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="o">*</span><span class="n">uv</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="o">/</span><span class="kt">float</span><span class="p">(</span><span class="n">mVpHeight</span><span class="p">)</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">);</span>
    <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">*=</span> <span class="n">depth</span><span class="o">/</span><span class="n">mProjectionMatrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">*=</span> <span class="n">depth</span><span class="o">/</span><span class="n">mProjectionMatrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">a</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">=</span> <span class="o">-</span><span class="n">depth</span><span class="p">;</span>
<span class="hll">    <span class="c1">// FIXME /\/|</span>
</span>    <span class="n">Vector4f</span> <span class="n">b</span> <span class="o">=</span> <span class="n">invModelview</span> <span class="o">*</span> <span class="n">Vector4f</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">z</span><span class="p">(),</span> <span class="mf">1.</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">Vector3f</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">z</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/doc/snippets/MatrixBase_triangularView.cpp#L9">MatrixBase_triangularView.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Here is the strictly-upper-triangular matrix extracted from m:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
     <span class="o">&lt;&lt;</span> <span class="n">Matrix3i</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">StrictlyUpper</span><span class="o">&gt;</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Here is the unit-lower-triangular matrix extracted from m:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
     <span class="o">&lt;&lt;</span> <span class="n">Matrix3i</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">UnitLower</span><span class="o">&gt;</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="hll"><span class="c1">// FIXME need to implement output for triangularViews (Bug 885)</span>
</span></pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/AlignedVector3#L37">AlignedVector3</a>:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="o">*</span> <span class="n">the</span> <span class="n">same</span> <span class="n">result</span> <span class="n">can</span> <span class="n">be</span> <span class="n">achieved</span> <span class="n">by</span> <span class="n">directly</span> <span class="n">using</span> <span class="n">a</span> <span class="mi">4</span><span class="n">D</span> <span class="n">vector</span><span class="o">.</span>
  <span class="o">*</span> <span class="n">This</span> <span class="k">class</span> <span class="nc">makes</span> <span class="n">this</span> <span class="n">process</span> <span class="n">simpler</span><span class="o">.</span>
  <span class="o">*</span>
  <span class="o">*/</span>
<span class="hll"><span class="o">//</span> <span class="n">TODO</span> <span class="n">specialize</span> <span class="n">Cwise</span>
</span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">_Scalar</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">AlignedVector3</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">internal</span> <span class="p">{</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">_Scalar</span><span class="o">&gt;</span> <span class="n">struct</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">AlignedVector3</span><span class="o">&lt;</span><span class="n">_Scalar</span><span class="o">&gt;</span> <span class="o">&gt;</span>
  <span class="p">:</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">_Scalar</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/FFT#L80">FFT</a>:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>76
77
78
79
80
81
82
83
84
85
86
87</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="o">//</span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">typedef</span> <span class="n">struct</span> <span class="n">internal</span><span class="p">::</span><span class="n">fftw_impl</span>  <span class="n">default_fft_impl</span><span class="p">;</span> <span class="n">this</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">work</span>
     <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">struct</span> <span class="n">default_fft_impl</span> <span class="p">:</span> <span class="n">public</span> <span class="n">internal</span><span class="p">::</span><span class="n">fftw_impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{};</span>
   <span class="p">}</span>
<span class="c1">#elif defined EIGEN_MKL_DEFAULT</span>
<span class="hll"><span class="o">//</span> <span class="n">TODO</span>
</span><span class="o">//</span> <span class="n">intel</span> <span class="n">Math</span> <span class="n">Kernel</span> <span class="n">Library</span><span class="p">:</span> <span class="n">fastest</span><span class="p">,</span> <span class="n">commercial</span> <span class="o">--</span> <span class="n">may</span> <span class="n">be</span> <span class="n">incompatible</span> <span class="k">with</span> <span class="n">Eigen</span> <span class="ow">in</span> <span class="n">GPL</span> <span class="n">form</span>
<span class="c1">#  include &quot;src/FFT/ei_imklfft_impl.h&quot;</span>
   <span class="n">namespace</span> <span class="n">Eigen</span> <span class="p">{</span>
     <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">struct</span> <span class="n">default_fft_impl</span> <span class="p">:</span> <span class="n">public</span> <span class="n">internal</span><span class="p">::</span><span class="n">imklfft_impl</span> <span class="p">{};</span>
   <span class="p">}</span>
<span class="c1">#else</span>
<span class="o">//</span> <span class="n">internal</span><span class="p">::</span><span class="n">kissfft_impl</span><span class="p">:</span>  <span class="n">small</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">reasonably</span> <span class="n">efficient</span> <span class="n">default</span><span class="p">,</span> <span class="n">derived</span> <span class="kn">from</span> <span class="nn">kissfft</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/FFT#L359">FFT</a>:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>355
356
357
358
359
360
361
362
363
364
365
366</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">}</span>


    <span class="o">/*</span>
<span class="hll">    <span class="o">//</span> <span class="n">TODO</span><span class="p">:</span> <span class="n">multi</span><span class="o">-</span><span class="n">dimensional</span> <span class="n">FFTs</span>
</span>    <span class="n">inline</span>
    <span class="n">void</span> <span class="n">inv2</span><span class="p">(</span><span class="n">Complex</span> <span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="n">const</span> <span class="n">Complex</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n0</span><span class="p">,</span><span class="nb">int</span> <span class="n">n1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">m_impl</span><span class="o">.</span><span class="n">inv2</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="n">src</span><span class="p">,</span><span class="n">n0</span><span class="p">,</span><span class="n">n1</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">HasFlag</span><span class="p">(</span> <span class="n">Unscaled</span> <span class="p">)</span> <span class="o">==</span> <span class="n">false</span><span class="p">)</span>
          <span class="n">scale</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">n0</span><span class="o">*</span><span class="n">n1</span><span class="p">),</span><span class="n">n0</span><span class="o">*</span><span class="n">n1</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/NonLinearOptimization.cpp#L239">NonLinearOptimization.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>235
236
237
238
239
240
241
242
243
244</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">MatrixXd</span> <span class="n">cov</span><span class="p">;</span>
  <span class="n">cov</span> <span class="o">=</span>  <span class="n">covfac</span><span class="o">*</span><span class="n">lm</span><span class="p">.</span><span class="n">fjac</span><span class="p">.</span><span class="n">topLeftCorner</span><span class="o">&lt;</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span> <span class="n">cov</span><span class="p">,</span> <span class="n">cov_ref</span><span class="p">);</span>
  <span class="c1">// TODO: why isn&#39;t this allowed ? :</span>
<span class="hll">  <span class="c1">// VERIFY_IS_APPROX( covfac*fjac.topLeftCorner&lt;n,n&gt;() , cov_ref);</span>
</span><span class="p">}</span>

<span class="k">struct</span> <span class="nl">hybrj_functor</span> <span class="p">:</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">hybrj_functor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">:</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/NonLinearOptimization.cpp#L630">NonLinearOptimization.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>626
627
628
629
630
631
632
633
634
635
636</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">MatrixXd</span> <span class="n">cov</span><span class="p">;</span>
  <span class="n">cov</span> <span class="o">=</span>  <span class="n">covfac</span><span class="o">*</span><span class="n">lm</span><span class="p">.</span><span class="n">fjac</span><span class="p">.</span><span class="n">topLeftCorner</span><span class="o">&lt;</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span> <span class="n">cov</span><span class="p">,</span> <span class="n">cov_ref</span><span class="p">);</span>
  <span class="c1">// TODO: why isn&#39;t this allowed ? :</span>
<span class="hll">  <span class="c1">// VERIFY_IS_APPROX( covfac*fjac.topLeftCorner&lt;n,n&gt;() , cov_ref);</span>
</span><span class="p">}</span>

<span class="k">struct</span> <span class="nl">chwirut2_functor</span> <span class="p">:</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">chwirut2_functor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">:</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">54</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">m_x</span><span class="p">[</span><span class="mi">54</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/autodiff.cpp#L214">autodiff.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>210
211
212
213
214
215
216
217
218
219
220
221</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yref</span><span class="p">);</span>
    <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">jref</span><span class="p">);</span>
<span class="p">}</span>

<span class="hll"><span class="c1">// TODO also check actual derivatives!</span>
</span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">test_autodiff_scalar</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Vector2f</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Vector2f</span><span class="o">::</span><span class="n">Random</span><span class="p">();</span>
  <span class="k">typedef</span> <span class="n">AutoDiffScalar</span><span class="o">&lt;</span><span class="n">Vector2f</span><span class="o">&gt;</span> <span class="n">AD</span><span class="p">;</span>
  <span class="n">AD</span> <span class="nf">ax</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span><span class="n">Vector2f</span><span class="o">::</span><span class="n">UnitX</span><span class="p">());</span>
  <span class="n">AD</span> <span class="nf">ay</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span><span class="n">Vector2f</span><span class="o">::</span><span class="n">UnitY</span><span class="p">());</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/autodiff.cpp#L227">autodiff.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>223
224
225
226
227
228
229
230
231
232
233
234</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">foo</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">()));</span>
<span class="p">}</span>


<span class="hll"><span class="c1">// TODO also check actual derivatives!</span>
</span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">test_autodiff_vector</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Vector2f</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Vector2f</span><span class="o">::</span><span class="n">Random</span><span class="p">();</span>
  <span class="k">typedef</span> <span class="n">AutoDiffScalar</span><span class="o">&lt;</span><span class="n">Vector2f</span><span class="o">&gt;</span> <span class="n">AD</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">AD</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">VectorAD</span><span class="p">;</span>
  <span class="n">VectorAD</span> <span class="n">ap</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AD</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/autodiff_scalar.cpp#L15">autodiff_scalar.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;unsupported/Eigen/AutoDiff&gt;</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * In this file scalar derivations are tested for correctness.</span>
<span class="hll"><span class="cm"> * TODO add more tests!</span>
</span><span class="cm"> */</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">check_atan2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Deriv1</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">AutoDiffScalar</span><span class="o">&lt;</span><span class="n">Deriv1</span><span class="o">&gt;</span> <span class="n">AD</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/cxx11_tensor_concatenation.cpp#L103">cxx11_tensor_concatenation.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 99
100
101
102
103
104
105
106
107
108
109
110</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>
<span class="p">}</span>


<span class="hll"><span class="c1">// TODO(phli): Add test once we have a real vectorized implementation.</span>
</span><span class="c1">// static void test_vectorized_concatenation() {}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">test_concatenation_as_lvalue</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Tensor</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">t1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">Tensor</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">t1</span><span class="p">.</span><span class="n">setRandom</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/cxx11_tensor_random.cpp#L19">cxx11_tensor_random.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="n">Tensor</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">setRandom</span><span class="p">();</span>

<span class="hll">  <span class="c1">// Fixme: we should check that the generated numbers follow a uniform</span>
</span>  <span class="c1">// distribution instead.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VERIFY_IS_NOT_EQUAL</span><span class="p">(</span><span class="n">vec</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">vec</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">test_normal</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/cxx11_tensor_random.cpp#L31">cxx11_tensor_random.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="n">Tensor</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">setRandom</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">NormalRandomGenerator</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span><span class="p">();</span>

<span class="hll">  <span class="c1">// Fixme: we should check that the generated numbers follow a gaussian</span>
</span>  <span class="c1">// distribution instead.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VERIFY_IS_NOT_EQUAL</span><span class="p">(</span><span class="n">vec</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">vec</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/levenberg_marquardt.cpp#L12">levenberg_marquardt.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// Public License v. 2.0. If a copy of the MPL was not distributed</span>
<span class="c1">// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.</span>


<span class="hll"><span class="c1">// FIXME: These tests all check for hard-coded values. Ideally, parameters and start estimates should be randomized.</span>
</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;main.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unsupported/Eigen/LevenbergMarquardt&gt;</span><span class="cp"></span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/levenberg_marquardt.cpp#L137">levenberg_marquardt.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>133
134
135
136
137
138
139
140
141
142
143</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">MatrixXd</span> <span class="n">cov</span><span class="p">;</span>
  <span class="n">cov</span> <span class="o">=</span>  <span class="n">covfac</span><span class="o">*</span><span class="n">lm</span><span class="p">.</span><span class="n">matrixR</span><span class="p">().</span><span class="n">topLeftCorner</span><span class="o">&lt;</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span> <span class="n">cov</span><span class="p">,</span> <span class="n">cov_ref</span><span class="p">);</span>
  <span class="c1">// TODO: why isn&#39;t this allowed ? :</span>
<span class="hll">  <span class="c1">// VERIFY_IS_APPROX( covfac*fjac.topLeftCorner&lt;n,n&gt;() , cov_ref);</span>
</span><span class="p">}</span>

<span class="k">struct</span> <span class="nl">lmdif_functor</span> <span class="p">:</span> <span class="n">DenseFunctor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">lmdif_functor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">:</span> <span class="n">DenseFunctor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">VectorXd</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">VectorXd</span> <span class="o">&amp;</span><span class="n">fvec</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/levenberg_marquardt.cpp#L240">levenberg_marquardt.cpp</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>236
237
238
239
240
241
242
243
244
245
246</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">MatrixXd</span> <span class="n">cov</span><span class="p">;</span>
  <span class="n">cov</span> <span class="o">=</span>  <span class="n">covfac</span><span class="o">*</span><span class="n">lm</span><span class="p">.</span><span class="n">matrixR</span><span class="p">().</span><span class="n">topLeftCorner</span><span class="o">&lt;</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">VERIFY_IS_APPROX</span><span class="p">(</span> <span class="n">cov</span><span class="p">,</span> <span class="n">cov_ref</span><span class="p">);</span>
  <span class="c1">// TODO: why isn&#39;t this allowed ? :</span>
<span class="hll">  <span class="c1">// VERIFY_IS_APPROX( covfac*fjac.topLeftCorner&lt;n,n&gt;() , cov_ref);</span>
</span><span class="p">}</span>

<span class="k">struct</span> <span class="nl">chwirut2_functor</span> <span class="p">:</span> <span class="n">DenseFunctor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">chwirut2_functor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">:</span> <span class="n">DenseFunctor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">54</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">m_x</span><span class="p">[</span><span class="mi">54</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Cholesky/LDLT.h#L228">LDLT.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>224
225
226
227
228
229
230
231
232
233
234</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">LDLT</span><span class="o">&amp;</span> <span class="n">rankUpdate</span><span class="p">(</span><span class="k">const</span> <span class="n">MatrixBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;&amp;</span> <span class="n">w</span><span class="p">,</span> <span class="k">const</span> <span class="n">RealScalar</span><span class="o">&amp;</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>

    <span class="cm">/** \returns the internal LDLT decomposition matrix</span>
<span class="cm">      *</span>
<span class="hll"><span class="cm">      * TODO: document the storage layout</span>
</span><span class="cm">      */</span>
    <span class="kr">inline</span> <span class="k">const</span> <span class="n">MatrixType</span><span class="o">&amp;</span> <span class="n">matrixLDLT</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="n">eigen_assert</span><span class="p">(</span><span class="n">m_isInitialized</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;LDLT is not initialized.&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">m_matrix</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Cholesky/LDLT.h#L503">LDLT.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>499
500
501
502
503
504
505
506
507
508
509
510</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">m_matrix</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">derived</span><span class="p">();</span>

  <span class="c1">// Compute matrix L1 norm = max abs column sum.</span>
  <span class="n">m_l1_norm</span> <span class="o">=</span> <span class="n">RealScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="hll">  <span class="c1">// TODO move this code to SelfAdjointView</span>
</span>  <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">col</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RealScalar</span> <span class="n">abs_col_sum</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_UpLo</span> <span class="o">==</span> <span class="n">Lower</span><span class="p">)</span>
      <span class="n">abs_col_sum</span> <span class="o">=</span> <span class="n">m_matrix</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">col</span><span class="p">).</span><span class="k">template</span> <span class="n">lpNorm</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+</span> <span class="n">m_matrix</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="n">head</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="k">template</span> <span class="n">lpNorm</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">else</span>
      <span class="n">abs_col_sum</span> <span class="o">=</span> <span class="n">m_matrix</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="n">head</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="k">template</span> <span class="n">lpNorm</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+</span> <span class="n">m_matrix</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">col</span><span class="p">).</span><span class="k">template</span> <span class="n">lpNorm</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">abs_col_sum</span> <span class="o">&gt;</span> <span class="n">m_l1_norm</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Cholesky/LLT.h#L170">LLT.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>166
167
168
169
170
171
172
173
174
175
176</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">}</span>

    <span class="cm">/** \returns the LLT decomposition matrix</span>
<span class="cm">      *</span>
<span class="hll"><span class="cm">      * TODO: document the storage layout</span>
</span><span class="cm">      */</span>
    <span class="kr">inline</span> <span class="k">const</span> <span class="n">MatrixType</span><span class="o">&amp;</span> <span class="n">matrixLLT</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="n">eigen_assert</span><span class="p">(</span><span class="n">m_isInitialized</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;LLT is not initialized.&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">m_matrix</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Cholesky/LLT.h#L437">LLT.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>433
434
435
436
437
438
439
440
441
442
443
444</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">m_matrix</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">derived</span><span class="p">();</span>

  <span class="c1">// Compute matrix L1 norm = max abs column sum.</span>
  <span class="n">m_l1_norm</span> <span class="o">=</span> <span class="n">RealScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="hll">  <span class="c1">// TODO move this code to SelfAdjointView</span>
</span>  <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">col</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RealScalar</span> <span class="n">abs_col_sum</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_UpLo</span> <span class="o">==</span> <span class="n">Lower</span><span class="p">)</span>
      <span class="n">abs_col_sum</span> <span class="o">=</span> <span class="n">m_matrix</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">col</span><span class="p">).</span><span class="k">template</span> <span class="n">lpNorm</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+</span> <span class="n">m_matrix</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="n">head</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="k">template</span> <span class="n">lpNorm</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">else</span>
      <span class="n">abs_col_sum</span> <span class="o">=</span> <span class="n">m_matrix</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="n">head</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="k">template</span> <span class="n">lpNorm</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+</span> <span class="n">m_matrix</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">col</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">col</span><span class="p">).</span><span class="k">template</span> <span class="n">lpNorm</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">abs_col_sum</span> <span class="o">&gt;</span> <span class="n">m_l1_norm</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/CholmodSupport/CholmodSupport.h#L302">CholmodSupport.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>298
299
300
301
302
303
304
305
306
307
308
309</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_info</span> <span class="o">=</span> <span class="n">NumericalIssue</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
<span class="hll">      <span class="c1">// TODO optimize this copy by swapping when possible (be careful with alignment, etc.)</span>
</span>      <span class="n">dest</span> <span class="o">=</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Dest</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="p">,</span><span class="n">Dest</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="o">&gt;::</span><span class="n">Map</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">x_cd</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">),</span><span class="n">b</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="n">b</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
      <span class="n">cholmod_free_dense</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x_cd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_cholmod</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/** \internal */</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">RhsDerived</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DestDerived</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">_solve_impl</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseMatrixBase</span><span class="o">&lt;</span><span class="n">RhsDerived</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">SparseMatrixBase</span><span class="o">&lt;</span><span class="n">DestDerived</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/CholmodSupport/CholmodSupport.h#L325">CholmodSupport.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>321
322
323
324
325
326
327
328
329
330
331
332</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_info</span> <span class="o">=</span> <span class="n">NumericalIssue</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
<span class="hll">      <span class="c1">// TODO optimize this copy by swapping when possible (be careful with alignment, etc.)</span>
</span>      <span class="n">dest</span><span class="p">.</span><span class="n">derived</span><span class="p">()</span> <span class="o">=</span> <span class="n">viewAsEigen</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DestDerived</span><span class="o">::</span><span class="n">Scalar</span><span class="p">,</span><span class="n">ColMajor</span><span class="p">,</span><span class="k">typename</span> <span class="n">DestDerived</span><span class="o">::</span><span class="n">StorageIndex</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">x_cs</span><span class="p">);</span>
      <span class="n">cholmod_free_sparse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x_cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_cholmod</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cp">#endif </span><span class="c1">// EIGEN_PARSED_BY_DOXYGEN</span>


    <span class="cm">/** Sets the shift parameter that will be used to adjust the diagonal coefficients during the numerical factorization.</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Array.h#L139">Array.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>135
136
137
138
139
140
141
142
143
144
145
146</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED</span>
    <span class="p">}</span>

<span class="cp">#ifndef EIGEN_PARSED_BY_DOXYGEN</span>
<span class="hll">    <span class="c1">// FIXME is it still needed ??</span>
</span>    <span class="cm">/** \internal */</span>
    <span class="n">EIGEN_DEVICE_FUNC</span>
    <span class="n">Array</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">constructor_without_unaligned_array_assert</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">constructor_without_unaligned_array_assert</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">Base</span><span class="o">::</span><span class="n">_check_template_params</span><span class="p">();</span>
      <span class="n">EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/AssignEvaluator.h#L58">AssignEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>54
55
56
57
58
59
60
61
62
63
64
65</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">OuterStride</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">outer_stride_at_compile_time</span><span class="o">&lt;</span><span class="n">Dst</span><span class="o">&gt;::</span><span class="n">ret</span><span class="p">),</span>
    <span class="n">MaxSizeAtCompileTime</span> <span class="o">=</span> <span class="n">Dst</span><span class="o">::</span><span class="n">SizeAtCompileTime</span>
  <span class="p">};</span>

<span class="hll">  <span class="c1">// TODO distinguish between linear traversal and inner-traversals</span>
</span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">find_best_packet</span><span class="o">&lt;</span><span class="n">DstScalar</span><span class="p">,</span><span class="n">Dst</span><span class="o">::</span><span class="n">SizeAtCompileTime</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">LinearPacketType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">find_best_packet</span><span class="o">&lt;</span><span class="n">DstScalar</span><span class="p">,</span><span class="n">InnerSize</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">InnerPacketType</span><span class="p">;</span>

  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">LinearPacketSize</span> <span class="o">=</span> <span class="n">unpacket_traits</span><span class="o">&lt;</span><span class="n">LinearPacketType</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">,</span>
    <span class="n">InnerPacketSize</span> <span class="o">=</span> <span class="n">unpacket_traits</span><span class="o">&lt;</span><span class="n">InnerPacketType</span><span class="o">&gt;::</span><span class="n">size</span>
  <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/AssignEvaluator.h#L195">AssignEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>191
192
193
194
195
196
197
198
199
200
201</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Kernel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Stop</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">copy_using_evaluator_DefaultTraversal_CompleteUnrolling</span>
<span class="p">{</span>
  <span class="c1">// FIXME: this is not very clean, perhaps this information should be provided by the kernel?</span>
<span class="hll">  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">DstEvaluatorType</span> <span class="n">DstEvaluatorType</span><span class="p">;</span>
</span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">DstEvaluatorType</span><span class="o">::</span><span class="n">XprType</span> <span class="n">DstXprType</span><span class="p">;</span>

  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">outer</span> <span class="o">=</span> <span class="n">Index</span> <span class="o">/</span> <span class="n">DstXprType</span><span class="o">::</span><span class="n">InnerSizeAtCompileTime</span><span class="p">,</span>
    <span class="n">inner</span> <span class="o">=</span> <span class="n">Index</span> <span class="o">%</span> <span class="n">DstXprType</span><span class="o">::</span><span class="n">InnerSizeAtCompileTime</span>
  <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/AssignEvaluator.h#L260">AssignEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>256
257
258
259
260
261
262
263
264
265
266</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Kernel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Stop</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">copy_using_evaluator_innervec_CompleteUnrolling</span>
<span class="p">{</span>
  <span class="c1">// FIXME: this is not very clean, perhaps this information should be provided by the kernel?</span>
<span class="hll">  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">DstEvaluatorType</span> <span class="n">DstEvaluatorType</span><span class="p">;</span>
</span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">DstEvaluatorType</span><span class="o">::</span><span class="n">XprType</span> <span class="n">DstXprType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">PacketType</span> <span class="n">PacketType</span><span class="p">;</span>

  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">outer</span> <span class="o">=</span> <span class="n">Index</span> <span class="o">/</span> <span class="n">DstXprType</span><span class="o">::</span><span class="n">InnerSizeAtCompileTime</span><span class="p">,</span>
    <span class="n">inner</span> <span class="o">=</span> <span class="n">Index</span> <span class="o">%</span> <span class="n">DstXprType</span><span class="o">::</span><span class="n">InnerSizeAtCompileTime</span><span class="p">,</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/AssignEvaluator.h#L376">AssignEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>372
373
374
375
376
377
378
379
380
381
382
383</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">unaligned_dense_assignment_loop</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="c1">// MSVC must not inline this functions. If it does, it fails to optimize the</span>
  <span class="c1">// packet access path.</span>
<span class="hll">  <span class="c1">// FIXME check which version exhibits this issue</span>
</span><span class="cp">#if EIGEN_COMP_MSVC</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Kernel</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="n">EIGEN_DONT_INLINE</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="n">Kernel</span> <span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span>
                                    <span class="n">Index</span> <span class="n">start</span><span class="p">,</span>
                                    <span class="n">Index</span> <span class="n">end</span><span class="p">)</span>
<span class="cp">#else</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Kernel</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/AssignEvaluator.h#L696">AssignEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>692
693
694
695
696
697
698
699
700
701
702</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">protected</span><span class="o">:</span>
  <span class="n">DstEvaluatorType</span><span class="o">&amp;</span> <span class="n">m_dst</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">SrcEvaluatorType</span><span class="o">&amp;</span> <span class="n">m_src</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Functor</span> <span class="o">&amp;</span><span class="n">m_functor</span><span class="p">;</span>
<span class="hll">  <span class="c1">// TODO find a way to avoid the needs of the original expression</span>
</span>  <span class="n">DstXprType</span><span class="o">&amp;</span> <span class="n">m_dstExpr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">* Part 5 : Entry point for dense rectangular assignment</span>
<span class="cm">***************************************************************************/</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/AssignEvaluator.h#L831">AssignEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>827
828
829
830
831
832
833
834
835
836
837
838</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="n">NeedToTranspose</span><span class="p">,</span> <span class="n">Transpose</span><span class="o">&lt;</span><span class="n">Dst</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Dst</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">ActualDstTypeCleaned</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="n">NeedToTranspose</span><span class="p">,</span> <span class="n">Transpose</span><span class="o">&lt;</span><span class="n">Dst</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Dst</span><span class="o">&amp;&gt;::</span><span class="n">type</span> <span class="n">ActualDstType</span><span class="p">;</span>
  <span class="n">ActualDstType</span> <span class="nf">actualDst</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>

<span class="hll">  <span class="c1">// TODO check whether this is the right place to perform these checks:</span>
</span>  <span class="n">EIGEN_STATIC_ASSERT_LVALUE</span><span class="p">(</span><span class="n">Dst</span><span class="p">)</span>
  <span class="n">EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE</span><span class="p">(</span><span class="n">ActualDstTypeCleaned</span><span class="p">,</span><span class="n">Src</span><span class="p">)</span>
  <span class="n">EIGEN_CHECK_BINARY_COMPATIBILIY</span><span class="p">(</span><span class="n">Func</span><span class="p">,</span><span class="k">typename</span> <span class="n">ActualDstTypeCleaned</span><span class="o">::</span><span class="n">Scalar</span><span class="p">,</span><span class="k">typename</span> <span class="n">Src</span><span class="o">::</span><span class="n">Scalar</span><span class="p">);</span>

  <span class="n">Assignment</span><span class="o">&lt;</span><span class="n">ActualDstTypeCleaned</span><span class="p">,</span><span class="n">Src</span><span class="p">,</span><span class="n">Func</span><span class="o">&gt;::</span><span class="n">run</span><span class="p">(</span><span class="n">actualDst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dst</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Src</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/AssignEvaluator.h#L849">AssignEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>845
846
847
848
849
850
851
852
853
854
855
856</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dst</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Src</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Func</span><span class="o">&gt;</span>
<span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span>
<span class="kt">void</span> <span class="n">call_assignment_no_alias_no_transpose</span><span class="p">(</span><span class="n">Dst</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Src</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Func</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO check whether this is the right place to perform these checks:</span>
</span>  <span class="n">EIGEN_STATIC_ASSERT_LVALUE</span><span class="p">(</span><span class="n">Dst</span><span class="p">)</span>
  <span class="n">EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE</span><span class="p">(</span><span class="n">Dst</span><span class="p">,</span><span class="n">Src</span><span class="p">)</span>
  <span class="n">EIGEN_CHECK_BINARY_COMPATIBILIY</span><span class="p">(</span><span class="n">Func</span><span class="p">,</span><span class="k">typename</span> <span class="n">Dst</span><span class="o">::</span><span class="n">Scalar</span><span class="p">,</span><span class="k">typename</span> <span class="n">Src</span><span class="o">::</span><span class="n">Scalar</span><span class="p">);</span>

  <span class="n">Assignment</span><span class="o">&lt;</span><span class="n">Dst</span><span class="p">,</span><span class="n">Src</span><span class="p">,</span><span class="n">Func</span><span class="o">&gt;::</span><span class="n">run</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dst</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Src</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/AssignEvaluator.h#L884">AssignEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>880
881
882
883
884
885
886
887
888
889
890
891</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Generic assignment through evalTo.</span>
<span class="hll"><span class="c1">// TODO: not sure we have to keep that one, but it helps porting current code to new evaluator mechanism.</span>
</span><span class="c1">// Note that the last template argument &quot;Weak&quot; is needed to make it possible to perform</span>
<span class="c1">// both partial specialization+SFINAE without ambiguous specialization</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">DstXprType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">SrcXprType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Functor</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Weak</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Assignment</span><span class="o">&lt;</span><span class="n">DstXprType</span><span class="p">,</span> <span class="n">SrcXprType</span><span class="p">,</span> <span class="n">Functor</span><span class="p">,</span> <span class="n">EigenBase2EigenBase</span><span class="p">,</span> <span class="n">Weak</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">EIGEN_DEVICE_FUNC</span>
  <span class="k">static</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="n">DstXprType</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">SrcXprType</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">internal</span><span class="o">::</span><span class="n">assign_op</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DstXprType</span><span class="o">::</span><span class="n">Scalar</span><span class="p">,</span><span class="k">typename</span> <span class="n">SrcXprType</span><span class="o">::</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="cm">/*func*/</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Block.h#L50">Block.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>46
47
48
49
50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">OuterStrideAtCompileTime</span> <span class="o">=</span> <span class="n">HasSameStorageOrderAsXprType</span>
                             <span class="o">?</span> <span class="kt">int</span><span class="p">(</span><span class="n">outer_stride_at_compile_time</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">ret</span><span class="p">)</span>
                             <span class="o">:</span> <span class="kt">int</span><span class="p">(</span><span class="n">inner_stride_at_compile_time</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">ret</span><span class="p">),</span>

<span class="hll">    <span class="c1">// FIXME, this traits is rather specialized for dense object and it needs to be cleaned further</span>
</span>    <span class="n">FlagsLvalueBit</span> <span class="o">=</span> <span class="n">is_lvalue</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">?</span> <span class="nl">LvalueBit</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">FlagsRowMajorBit</span> <span class="o">=</span> <span class="n">IsRowMajor</span> <span class="o">?</span> <span class="nl">RowMajorBit</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">traits</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DirectAccessBit</span> <span class="o">|</span> <span class="p">(</span><span class="n">InnerPanel</span><span class="o">?</span><span class="nl">CompressedAccessBit</span><span class="p">:</span><span class="mi">0</span><span class="p">)))</span> <span class="o">|</span> <span class="n">FlagsLvalueBit</span> <span class="o">|</span> <span class="n">FlagsRowMajorBit</span><span class="p">,</span>
    <span class="c1">// FIXME DirectAccessBit should not be handled by expressions</span>
    <span class="c1">//</span>
    <span class="c1">// Alignment is needed by MapBase&#39;s assertions</span>
    <span class="c1">// We can sefely set it to false here. Internal alignment errors will be detected by an eigen_internal_assert in the respective evaluator</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Block.h#L54">Block.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="c1">// FIXME, this traits is rather specialized for dense object and it needs to be cleaned further</span>
    <span class="n">FlagsLvalueBit</span> <span class="o">=</span> <span class="n">is_lvalue</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">?</span> <span class="nl">LvalueBit</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">FlagsRowMajorBit</span> <span class="o">=</span> <span class="n">IsRowMajor</span> <span class="o">?</span> <span class="nl">RowMajorBit</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">traits</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DirectAccessBit</span> <span class="o">|</span> <span class="p">(</span><span class="n">InnerPanel</span><span class="o">?</span><span class="nl">CompressedAccessBit</span><span class="p">:</span><span class="mi">0</span><span class="p">)))</span> <span class="o">|</span> <span class="n">FlagsLvalueBit</span> <span class="o">|</span> <span class="n">FlagsRowMajorBit</span><span class="p">,</span>
<span class="hll">    <span class="c1">// FIXME DirectAccessBit should not be handled by expressions</span>
</span>    <span class="c1">//</span>
    <span class="c1">// Alignment is needed by MapBase&#39;s assertions</span>
    <span class="c1">// We can sefely set it to false here. Internal alignment errors will be detected by an eigen_internal_assert in the respective evaluator</span>
    <span class="n">Alignment</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Block.h#L418">Block.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>414
415
416
417
418
419
420
421
422
423
424
425</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="k">return</span> <span class="n">m_startCol</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

  <span class="cp">#ifndef __SUNPRO_CC</span>
<span class="hll">  <span class="c1">// FIXME sunstudio is not friendly with the above friend...</span>
</span>  <span class="c1">// META-FIXME there is no &#39;friend&#39; keyword around here. Is this obsolete?</span>
  <span class="k">protected</span><span class="o">:</span>
  <span class="cp">#endif</span>

    <span class="cp">#ifndef EIGEN_PARSED_BY_DOXYGEN</span>
    <span class="cm">/** \internal used by allowAligned() */</span>
    <span class="n">EIGEN_DEVICE_FUNC</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CommaInitializer.h#L49">CommaInitializer.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>45
46
47
48
49
50
51
52
53
54
55
56</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>

  <span class="cm">/* Copy/Move constructor which transfers ownership. This is crucial in</span>
<span class="cm">   * absence of return value optimization to avoid assertions during destruction. */</span>
<span class="hll">  <span class="c1">// FIXME in C++11 mode this could be replaced by a proper RValue constructor</span>
</span>  <span class="n">EIGEN_DEVICE_FUNC</span>
  <span class="kr">inline</span> <span class="n">CommaInitializer</span><span class="p">(</span><span class="k">const</span> <span class="n">CommaInitializer</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">m_xpr</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">m_xpr</span><span class="p">),</span> <span class="n">m_row</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">m_row</span><span class="p">),</span> <span class="n">m_col</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">m_col</span><span class="p">),</span> <span class="n">m_currentBlockRows</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">m_currentBlockRows</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Mark original object as finished. In absence of R-value references we need to const_cast:</span>
    <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">CommaInitializer</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">o</span><span class="p">).</span><span class="n">m_row</span> <span class="o">=</span> <span class="n">m_xpr</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span>
    <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">CommaInitializer</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">o</span><span class="p">).</span><span class="n">m_col</span> <span class="o">=</span> <span class="n">m_xpr</span><span class="p">.</span><span class="n">cols</span><span class="p">();</span>
    <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">CommaInitializer</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">o</span><span class="p">).</span><span class="n">m_currentBlockRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreEvaluators.h#L97">CoreEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="k">explicit</span> <span class="nf">evaluator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">xpr</span><span class="p">)</span> <span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">xpr</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>


<span class="hll"><span class="c1">// TODO: Think about const-correctness</span>
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">EIGEN_DEVICE_FUNC</span>
  <span class="k">explicit</span> <span class="n">evaluator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">xpr</span><span class="p">)</span> <span class="o">:</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xpr</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreEvaluators.h#L111">CoreEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>107
108
109
110
111
112
113
114
115
116</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ExpressionType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">evaluator_base</span> <span class="p">:</span> <span class="k">public</span> <span class="n">noncopyable</span>
<span class="p">{</span>
  <span class="c1">// TODO that&#39;s not very nice to have to propagate all these traits. They are currently only needed to handle outer,inner indices.</span>
<span class="hll">  <span class="k">typedef</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">ExpressionType</span><span class="o">&gt;</span> <span class="n">ExpressionTraits</span><span class="p">;</span>
</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">Alignment</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreEvaluators.h#L802">CoreEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>798
799
800
801
802
803
804
805
806
807
808
809</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">};</span>

<span class="c1">// -------------------- Map --------------------</span>

<span class="hll"><span class="c1">// FIXME perhaps the PlainObjectType could be provided by Derived::PlainObject ?</span>
</span><span class="c1">// but that might complicate template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="p">,</span> <span class="k">typename</span> <span class="n">PlainObjectType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">mapbase_evaluator</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="p">,</span> <span class="k">typename</span> <span class="n">PlainObjectType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">mapbase_evaluator</span> <span class="p">:</span> <span class="n">evaluator_base</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreEvaluators.h#L901">CoreEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>897
898
899
900
901
902
903
904
905
906
907
908</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="o">:</span> <span class="k">public</span> <span class="n">mapbase_evaluator</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">PlainObjectType</span><span class="p">,</span> <span class="n">MapOptions</span><span class="p">,</span> <span class="n">StrideType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">PlainObjectType</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">PlainObjectType</span><span class="p">,</span> <span class="n">MapOptions</span><span class="p">,</span> <span class="n">StrideType</span><span class="o">&gt;</span> <span class="n">XprType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">XprType</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
<span class="hll">  <span class="c1">// TODO: should check for smaller packet types once we can handle multi-sized packet types</span>
</span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">PacketScalar</span><span class="p">;</span>

  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">InnerStrideAtCompileTime</span> <span class="o">=</span> <span class="n">StrideType</span><span class="o">::</span><span class="n">InnerStrideAtCompileTime</span> <span class="o">==</span> <span class="mi">0</span>
                             <span class="o">?</span> <span class="kt">int</span><span class="p">(</span><span class="n">PlainObjectType</span><span class="o">::</span><span class="n">InnerStrideAtCompileTime</span><span class="p">)</span>
                             <span class="o">:</span> <span class="kt">int</span><span class="p">(</span><span class="n">StrideType</span><span class="o">::</span><span class="n">InnerStrideAtCompileTime</span><span class="p">),</span>
    <span class="n">OuterStrideAtCompileTime</span> <span class="o">=</span> <span class="n">StrideType</span><span class="o">::</span><span class="n">OuterStrideAtCompileTime</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreEvaluators.h#L957">CoreEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>953
954
955
956
957
958
959
960
961
962
963
964</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="o">:</span> <span class="n">block_evaluator</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="p">,</span> <span class="n">BlockRows</span><span class="p">,</span> <span class="n">BlockCols</span><span class="p">,</span> <span class="n">InnerPanel</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Block</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="p">,</span> <span class="n">BlockRows</span><span class="p">,</span> <span class="n">BlockCols</span><span class="p">,</span> <span class="n">InnerPanel</span><span class="o">&gt;</span> <span class="n">XprType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">XprType</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
<span class="hll">  <span class="c1">// TODO: should check for smaller packet types once we can handle multi-sized packet types</span>
</span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">PacketScalar</span><span class="p">;</span>

  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">CoeffReadCost</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="o">&gt;::</span><span class="n">CoeffReadCost</span><span class="p">,</span>

    <span class="n">RowsAtCompileTime</span> <span class="o">=</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">RowsAtCompileTime</span><span class="p">,</span>
    <span class="n">ColsAtCompileTime</span> <span class="o">=</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">ColsAtCompileTime</span><span class="p">,</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreEvaluators.h#L1109">CoreEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1105
1106
1107
1108
1109
1110
1111
1112
1113
1114
1115
1116</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">const</span> <span class="n">variable_if_dynamic</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span> <span class="p">(</span><span class="n">ArgType</span><span class="o">::</span><span class="n">ColsAtCompileTime</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">BlockCols</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">Dynamic</span><span class="o">&gt;</span> <span class="n">m_startCol</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">variable_if_dynamic</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span> <span class="n">InnerPanel</span> <span class="o">?</span> <span class="nl">Dynamic</span> <span class="p">:</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">m_linear_offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="hll"><span class="c1">// TODO: This evaluator does not actually use the child evaluator;</span>
</span><span class="c1">// all action is via the data() as returned by the Block expression.</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ArgType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">BlockRows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">BlockCols</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">InnerPanel</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">block_evaluator</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="p">,</span> <span class="n">BlockRows</span><span class="p">,</span> <span class="n">BlockCols</span><span class="p">,</span> <span class="n">InnerPanel</span><span class="p">,</span> <span class="cm">/* HasDirectAccess */</span> <span class="nb">true</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">mapbase_evaluator</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="p">,</span> <span class="n">BlockRows</span><span class="p">,</span> <span class="n">BlockCols</span><span class="p">,</span> <span class="n">InnerPanel</span><span class="o">&gt;</span><span class="p">,</span>
                      <span class="k">typename</span> <span class="n">Block</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="p">,</span> <span class="n">BlockRows</span><span class="p">,</span> <span class="n">BlockCols</span><span class="p">,</span> <span class="n">InnerPanel</span><span class="o">&gt;::</span><span class="n">PlainObject</span><span class="o">&gt;</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreEvaluators.h#L1123">CoreEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1119
1120
1121
1122
1123
1124
1125
1126
1127
1128
1129</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="k">explicit</span> <span class="nf">block_evaluator</span><span class="p">(</span><span class="k">const</span> <span class="n">XprType</span><span class="o">&amp;</span> <span class="n">block</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">mapbase_evaluator</span><span class="o">&lt;</span><span class="n">XprType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">XprType</span><span class="o">::</span><span class="n">PlainObject</span><span class="o">&gt;</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// TODO: for the 3.3 release, this should be turned to an internal assertion, but let&#39;s keep it as is for the beta lifetime</span>
<span class="hll">    <span class="n">eigen_assert</span><span class="p">(((</span><span class="n">internal</span><span class="o">::</span><span class="n">UIntPtr</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">data</span><span class="p">())</span> <span class="o">%</span> <span class="n">EIGEN_PLAIN_ENUM_MAX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">evaluator</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">Alignment</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;data is not aligned&quot;</span><span class="p">);</span>
</span>  <span class="p">}</span>
<span class="p">};</span>


<span class="c1">// -------------------- Select --------------------</span>
<span class="c1">// NOTE shall we introduce a ternary_evaluator?</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreEvaluators.h#L1132">CoreEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1128
1129
1130
1131
1132
1133
1134
1135
1136
1137
1138</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// -------------------- Select --------------------</span>
<span class="c1">// NOTE shall we introduce a ternary_evaluator?</span>

<span class="c1">// TODO enable vectorization for Select</span>
<span class="hll"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ConditionMatrixType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ThenMatrixType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ElseMatrixType</span><span class="o">&gt;</span>
</span><span class="k">struct</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">Select</span><span class="o">&lt;</span><span class="n">ConditionMatrixType</span><span class="p">,</span> <span class="n">ThenMatrixType</span><span class="p">,</span> <span class="n">ElseMatrixType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">evaluator_base</span><span class="o">&lt;</span><span class="n">Select</span><span class="o">&lt;</span><span class="n">ConditionMatrixType</span><span class="p">,</span> <span class="n">ThenMatrixType</span><span class="p">,</span> <span class="n">ElseMatrixType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Select</span><span class="o">&lt;</span><span class="n">ConditionMatrixType</span><span class="p">,</span> <span class="n">ThenMatrixType</span><span class="p">,</span> <span class="n">ElseMatrixType</span><span class="o">&gt;</span> <span class="n">XprType</span><span class="p">;</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">CoeffReadCost</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">ConditionMatrixType</span><span class="o">&gt;::</span><span class="n">CoeffReadCost</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreEvaluators.h#L1452">CoreEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1448
1449
1450
1451
1452
1453
1454
1455
1456
1457</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">CoeffReadCost</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="o">&gt;::</span><span class="n">CoeffReadCost</span><span class="p">,</span>

    <span class="c1">// let&#39;s enable LinearAccess only with vectorization because of the product overhead</span>
    <span class="c1">// FIXME enable DirectAccess with negative strides?</span>
<span class="hll">    <span class="n">Flags0</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="o">&gt;::</span><span class="n">Flags</span><span class="p">,</span>
</span>    <span class="n">LinearAccess</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">Direction</span><span class="o">==</span><span class="n">BothDirections</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">Flags0</span><span class="p">)</span><span class="o">&amp;</span><span class="n">PacketAccessBit</span><span class="p">)</span> <span class="p">)</span>
                  <span class="o">||</span> <span class="p">((</span><span class="n">ReverseRow</span> <span class="o">&amp;&amp;</span> <span class="n">XprType</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ReverseCol</span> <span class="o">&amp;&amp;</span> <span class="n">XprType</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="o">==</span><span class="mi">1</span><span class="p">))</span>
                 <span class="o">?</span> <span class="nl">LinearAccessBit</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>

    <span class="n">Flags</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">Flags0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HereditaryBits</span> <span class="o">|</span> <span class="n">PacketAccessBit</span> <span class="o">|</span> <span class="n">LinearAccess</span><span class="p">),</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreEvaluators.h#L1522">CoreEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1518
1519
1520
1521
1522
1523
1524
1525
1526
1527
1528
1529</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">LoadMode</span><span class="p">,</span> <span class="k">typename</span> <span class="n">PacketType</span><span class="o">&gt;</span>
  <span class="n">EIGEN_STRONG_INLINE</span>
  <span class="kt">void</span> <span class="n">writePacket</span><span class="p">(</span><span class="n">Index</span> <span class="n">row</span><span class="p">,</span> <span class="n">Index</span> <span class="n">col</span><span class="p">,</span> <span class="k">const</span> <span class="n">PacketType</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME we could factorize some code with packet(i,j)</span>
</span>    <span class="k">enum</span> <span class="p">{</span>
      <span class="n">PacketSize</span> <span class="o">=</span> <span class="n">unpacket_traits</span><span class="o">&lt;</span><span class="n">PacketType</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">,</span>
      <span class="n">OffsetRow</span>  <span class="o">=</span> <span class="n">ReverseRow</span> <span class="o">&amp;&amp;</span> <span class="n">IsColMajor</span> <span class="o">?</span> <span class="nl">PacketSize</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="n">OffsetCol</span>  <span class="o">=</span> <span class="n">ReverseCol</span> <span class="o">&amp;&amp;</span> <span class="n">IsRowMajor</span> <span class="o">?</span> <span class="nl">PacketSize</span> <span class="p">:</span> <span class="mi">1</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">reverse_packet_cond</span><span class="o">&lt;</span><span class="n">PacketType</span><span class="p">,</span><span class="n">ReversePacket</span><span class="o">&gt;</span> <span class="n">reverse_packet</span><span class="p">;</span>
    <span class="n">m_argImpl</span><span class="p">.</span><span class="k">template</span> <span class="n">writePacket</span><span class="o">&lt;</span><span class="n">LoadMode</span><span class="o">&gt;</span><span class="p">(</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/CoreIterators.h#L30">CoreIterators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  * \brief An InnerIterator allows to loop over the element of any matrix expression.
  *
  * \warning To be used with care because an evaluator is constructed every time an InnerIterator iterator is constructed.
  *
<span class="hll">  * TODO: add a usage example
</span>  */
template&lt;typename XprType&gt;
class InnerIterator
{
protected:
  typedef internal::inner_iterator_selector&lt;XprType, typename internal::evaluator_traits&lt;XprType&gt;::Kind&gt; IteratorType;
  typedef internal::evaluator&lt;XprType&gt; EvaluatorType;
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/DenseCoeffsBase.h#L512">DenseCoeffsBase.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>508
509
510
511
512
513
514
515
516
517
518
519</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">{</span>
      <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">outerStride</span><span class="p">();</span>
    <span class="p">}</span>

<span class="hll">    <span class="c1">// FIXME shall we remove it ?</span>
</span>    <span class="kr">inline</span> <span class="n">Index</span> <span class="n">stride</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">Derived</span><span class="o">::</span><span class="n">IsVectorAtCompileTime</span> <span class="o">?</span> <span class="n">innerStride</span><span class="p">()</span> <span class="o">:</span> <span class="n">outerStride</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/** \returns the pointer increment between two consecutive rows.</span>
<span class="cm">      *</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/DenseCoeffsBase.h#L586">DenseCoeffsBase.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>582
583
584
585
586
587
588
589
590
591
592
593</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">{</span>
      <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">outerStride</span><span class="p">();</span>
    <span class="p">}</span>

<span class="hll">    <span class="c1">// FIXME shall we remove it ?</span>
</span>    <span class="kr">inline</span> <span class="n">Index</span> <span class="n">stride</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">Derived</span><span class="o">::</span><span class="n">IsVectorAtCompileTime</span> <span class="o">?</span> <span class="n">innerStride</span><span class="p">()</span> <span class="o">:</span> <span class="n">outerStride</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/** \returns the pointer increment between two consecutive rows.</span>
<span class="cm">      *</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/EigenBase.h#L40">EigenBase.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>36
37
38
39
40
41
42
43
44
45
46
47</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    * \sa StorageIndex, \ref TopicPreprocessorDirectives.
    */
  typedef Eigen::Index Index;

<span class="hll">  // FIXME is it needed?
</span>  typedef typename internal::traits&lt;Derived&gt;::StorageKind StorageKind;

  /** \returns a reference to the derived object */
  EIGEN_DEVICE_FUNC
  Derived&amp; derived() { return *static_cast&lt;Derived*&gt;(this); }
  /** \returns a const reference to the derived object */
  EIGEN_DEVICE_FUNC
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/GeneralProduct.h#L88">GeneralProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>84
85
86
87
88
89
90
91
92
93
94</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/* The following allows to select the kind of product at compile time</span>
<span class="cm"> * based on the three dimensions of the product.</span>
<span class="cm"> * This is a compile time mapping from {1,Small,Large}^3 -&gt; {product types} */</span>
<span class="c1">// FIXME I&#39;m not sure the current mapping is the ideal one.</span>
<span class="hll"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>  <span class="k">struct</span> <span class="n">product_type_selector</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span>              <span class="p">{</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">OuterProduct</span> <span class="p">};</span> <span class="p">};</span>
</span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">M</span><span class="o">&gt;</span>         <span class="k">struct</span> <span class="n">product_type_selector</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span>            <span class="p">{</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">LazyCoeffBasedProductMode</span> <span class="p">};</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>         <span class="k">struct</span> <span class="n">product_type_selector</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span>            <span class="p">{</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">LazyCoeffBasedProductMode</span> <span class="p">};</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">Depth</span><span class="o">&gt;</span>     <span class="k">struct</span> <span class="n">product_type_selector</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span>    <span class="n">Depth</span><span class="o">&gt;</span>  <span class="p">{</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">InnerProduct</span> <span class="p">};</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>              <span class="k">struct</span> <span class="n">product_type_selector</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="o">&gt;</span>      <span class="p">{</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">InnerProduct</span> <span class="p">};</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>              <span class="k">struct</span> <span class="n">product_type_selector</span><span class="o">&lt;</span><span class="n">Small</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span>    <span class="n">Small</span><span class="o">&gt;</span>  <span class="p">{</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">CoeffBasedProductMode</span> <span class="p">};</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>              <span class="k">struct</span> <span class="n">product_type_selector</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>    <span class="n">Small</span><span class="p">,</span><span class="n">Small</span><span class="o">&gt;</span>  <span class="p">{</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">CoeffBasedProductMode</span> <span class="p">};</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/GeneralProduct.h#L120">GeneralProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>116
117
118
119
120
121
122
123
124
125
126
127</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/***********************************************************************</span>
<span class="cm">*  Implementation of Inner Vector Vector Product</span>
<span class="cm">***********************************************************************/</span>

<span class="hll"><span class="c1">// FIXME : maybe the &quot;inner product&quot; could return a Scalar</span>
</span><span class="c1">// instead of a 1x1 matrix ??</span>
<span class="c1">// Pro: more natural for the user</span>
<span class="c1">// Cons: this could be a problem if in a meta unrolled algorithm a matrix-matrix</span>
<span class="c1">// product ends up to a row-vector times col-vector product... To tackle this use</span>
<span class="c1">// case, we could have a specialization for Block&lt;MatrixType,1,1&gt; with: operator=(Scalar x);</span>

<span class="cm">/***********************************************************************</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/GeneralProduct.h#L228">GeneralProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>224
225
226
227
228
229
230
231
232
233
234
235</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="c1">// make sure Dest is a compile-time vector type (bug 1166)</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">conditional</span><span class="o">&lt;</span><span class="n">Dest</span><span class="o">::</span><span class="n">IsVectorAtCompileTime</span><span class="p">,</span> <span class="n">Dest</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Dest</span><span class="o">::</span><span class="n">ColXpr</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">ActualDest</span><span class="p">;</span>

    <span class="k">enum</span> <span class="p">{</span>
<span class="hll">      <span class="c1">// FIXME find a way to allow an inner stride on the result if packet_traits&lt;Scalar&gt;::size==1</span>
</span>      <span class="c1">// on, the other hand it is good for the cache to pack the vector anyways...</span>
      <span class="n">EvalToDestAtCompileTime</span> <span class="o">=</span> <span class="p">(</span><span class="n">ActualDest</span><span class="o">::</span><span class="n">InnerStrideAtCompileTime</span><span class="o">==</span><span class="mi">1</span><span class="p">),</span>
      <span class="n">ComplexByReal</span> <span class="o">=</span> <span class="p">(</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="o">&gt;::</span><span class="n">IsComplex</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="o">&gt;::</span><span class="n">IsComplex</span><span class="p">),</span>
      <span class="n">MightCannotUseDest</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">EvalToDestAtCompileTime</span><span class="p">)</span> <span class="o">||</span> <span class="n">ComplexByReal</span>
    <span class="p">};</span>

    <span class="k">typedef</span> <span class="n">const_blas_data_mapper</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span><span class="n">Index</span><span class="p">,</span><span class="n">ColMajor</span><span class="o">&gt;</span> <span class="n">LhsMapper</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/GeneralProduct.h#L317">GeneralProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>313
314
315
316
317
318
319
320
321
322
323
324</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">ResScalar</span> <span class="n">actualAlpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">LhsBlasTraits</span><span class="o">::</span><span class="n">extractScalarFactor</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>
                                  <span class="o">*</span> <span class="n">RhsBlasTraits</span><span class="o">::</span><span class="n">extractScalarFactor</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>

    <span class="k">enum</span> <span class="p">{</span>
<span class="hll">      <span class="c1">// FIXME find a way to allow an inner stride on the result if packet_traits&lt;Scalar&gt;::size==1</span>
</span>      <span class="c1">// on, the other hand it is good for the cache to pack the vector anyways...</span>
      <span class="n">DirectlyUseRhs</span> <span class="o">=</span> <span class="n">ActualRhsTypeCleaned</span><span class="o">::</span><span class="n">InnerStrideAtCompileTime</span><span class="o">==</span><span class="mi">1</span>
    <span class="p">};</span>

    <span class="n">gemv_static_vector_if</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="p">,</span><span class="n">ActualRhsTypeCleaned</span><span class="o">::</span><span class="n">SizeAtCompileTime</span><span class="p">,</span><span class="n">ActualRhsTypeCleaned</span><span class="o">::</span><span class="n">MaxSizeAtCompileTime</span><span class="p">,</span><span class="o">!</span><span class="n">DirectlyUseRhs</span><span class="o">&gt;</span> <span class="n">static_rhs</span><span class="p">;</span>

    <span class="n">ei_declare_aligned_stack_constructed_variable</span><span class="p">(</span><span class="n">RhsScalar</span><span class="p">,</span><span class="n">actualRhsPtr</span><span class="p">,</span><span class="n">actualRhs</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/GeneralProduct.h#L354">GeneralProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>350
351
352
353
354
355
356
357
358
359
360</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Dest</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="k">const</span> <span class="n">Lhs</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rhs</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">,</span> <span class="n">Dest</span><span class="o">&amp;</span> <span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="k">typename</span> <span class="n">Dest</span><span class="o">::</span><span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">alpha</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">EIGEN_STATIC_ASSERT</span><span class="p">((</span><span class="o">!</span><span class="n">nested_eval</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">Evaluate</span><span class="p">),</span><span class="n">EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE</span><span class="p">);</span>
<span class="hll">    <span class="c1">// TODO if rhs is large enough it might be beneficial to make sure that dest is sequentially stored in memory, otherwise use a temp</span>
</span>    <span class="k">typename</span> <span class="n">nested_eval</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">actual_rhs</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">Index</span> <span class="n">size</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="n">Index</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
      <span class="n">dest</span> <span class="o">+=</span> <span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">actual_rhs</span><span class="p">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="o">*</span> <span class="n">lhs</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/GenericPacketMath.h#L354">GenericPacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>350
351
352
353
354
355
356
357
358
359
360</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/** \internal \returns \a a with real and imaginary part flipped (for complex type only) */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Packet</span><span class="o">&gt;</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kr">inline</span> <span class="n">Packet</span> <span class="n">pcplxflip</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// FIXME: uncomment the following in case we drop the internal imag and real functions.</span>
<span class="hll"><span class="c1">//   using std::imag;</span>
</span><span class="c1">//   using std::real;</span>
  <span class="k">return</span> <span class="n">Packet</span><span class="p">(</span><span class="n">imag</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">real</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**************************</span>
<span class="cm">* Special math functions</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/GlobalFunctions.h#L185">GlobalFunctions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>181
182
183
184
185
186
187</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">EIGEN_ARRAY_DECLARE_GLOBAL_EIGEN_UNARY</span><span class="p">(</span><span class="n">abs2</span><span class="p">,</span><span class="n">scalar_abs2_op</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="hll"><span class="c1">// TODO: cleanly disable those functions that are not supported on Array (numext::real_ref, internal::random, internal::isApprox...)</span>
</span>
<span class="cp">#endif </span><span class="c1">// EIGEN_GLOBAL_FUNCTIONS_H</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/IO.h#L60">IO.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>56
57
58
59
60
61
62
63
64
65
66
67</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">_matPrefix</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">_matSuffix</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">matPrefix</span><span class="p">(</span><span class="n">_matPrefix</span><span class="p">),</span> <span class="n">matSuffix</span><span class="p">(</span><span class="n">_matSuffix</span><span class="p">),</span> <span class="n">rowPrefix</span><span class="p">(</span><span class="n">_rowPrefix</span><span class="p">),</span> <span class="n">rowSuffix</span><span class="p">(</span><span class="n">_rowSuffix</span><span class="p">),</span> <span class="n">rowSeparator</span><span class="p">(</span><span class="n">_rowSeparator</span><span class="p">),</span>
    <span class="n">rowSpacer</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">),</span> <span class="n">coeffSeparator</span><span class="p">(</span><span class="n">_coeffSeparator</span><span class="p">),</span> <span class="n">precision</span><span class="p">(</span><span class="n">_precision</span><span class="p">),</span> <span class="n">flags</span><span class="p">(</span><span class="n">_flags</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO check if rowPrefix, rowSuffix or rowSeparator contains a newline</span>
</span>    <span class="c1">// don&#39;t add rowSpacer if columns are not to be aligned</span>
    <span class="k">if</span><span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DontAlignCols</span><span class="p">))</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">matSuffix</span><span class="p">.</span><span class="n">length</span><span class="p">())</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">matSuffix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">rowSpacer</span> <span class="o">+=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/MathFunctions.h#L14">MathFunctions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#ifndef EIGEN_MATHFUNCTIONS_H</span>
<span class="cp">#define EIGEN_MATHFUNCTIONS_H</span>

<span class="c1">// source: http://www.geom.uiuc.edu/~huberty/math5337/groupe/digits.html</span>
<span class="hll"><span class="c1">// TODO this should better be moved to NumTraits</span>
</span><span class="cp">#define EIGEN_PI 3.141592653589793238462643383279502884197169399375105820974944592307816406L</span>


<span class="k">namespace</span> <span class="n">Eigen</span> <span class="p">{</span>

<span class="c1">// On WINCE, std::abs is defined for int only, so let&#39;s defined our own overloads:</span>
<span class="c1">// This issue has been confirmed with MSVC 2008 only, but the issue might exist for more recent versions too.</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Matrix.h#L48">Matrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>44
45
46
47
48
49
50
51
52
53
54
55</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">Options</span> <span class="o">=</span> <span class="n">_Options</span><span class="p">,</span>
    <span class="n">InnerStrideAtCompileTime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">OuterStrideAtCompileTime</span> <span class="o">=</span> <span class="p">(</span><span class="n">Options</span><span class="o">&amp;</span><span class="n">RowMajor</span><span class="p">)</span> <span class="o">?</span> <span class="nl">ColsAtCompileTime</span> <span class="p">:</span> <span class="n">RowsAtCompileTime</span><span class="p">,</span>

<span class="hll">    <span class="c1">// FIXME, the following flag in only used to define NeedsToAlign in PlainObjectBase</span>
</span>    <span class="n">EvaluatorFlags</span> <span class="o">=</span> <span class="n">LinearAccessBit</span> <span class="o">|</span> <span class="n">DirectAccessBit</span> <span class="o">|</span> <span class="n">packet_access_bit</span> <span class="o">|</span> <span class="n">row_major_bit</span><span class="p">,</span>
    <span class="n">Alignment</span> <span class="o">=</span> <span class="n">actual_alignment</span>
  <span class="p">};</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="cm">/** \class Matrix</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Matrix.h#L265">Matrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>261
262
263
264
265
266
267
268
269
270
271
272</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">Base</span><span class="o">::</span><span class="n">_check_template_params</span><span class="p">();</span>
      <span class="n">EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED</span>
    <span class="p">}</span>

<span class="hll">    <span class="c1">// FIXME is it still needed</span>
</span>    <span class="n">EIGEN_DEVICE_FUNC</span>
    <span class="k">explicit</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">constructor_without_unaligned_array_assert</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">constructor_without_unaligned_array_assert</span><span class="p">())</span>
    <span class="p">{</span> <span class="n">Base</span><span class="o">::</span><span class="n">_check_template_params</span><span class="p">();</span> <span class="n">EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED</span> <span class="p">}</span>

<span class="cp">#if EIGEN_HAS_RVALUE_REFERENCES</span>
    <span class="n">EIGEN_DEVICE_FUNC</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/MatrixBase.h#L301">MatrixBase.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>297
298
299
300
301
302
303
304
305
306
307
308</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">{</span> <span class="k">return</span> <span class="n">cwiseNotEqual</span><span class="p">(</span><span class="n">other</span><span class="p">).</span><span class="n">any</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">NoAlias</span><span class="o">&lt;</span><span class="n">Derived</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixBase</span> <span class="o">&gt;</span> <span class="n">noalias</span><span class="p">();</span>

<span class="hll">    <span class="c1">// TODO forceAlignedAccess is temporarily disabled</span>
</span>    <span class="c1">// Need to find a nicer workaround.</span>
    <span class="kr">inline</span> <span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">forceAlignedAccess</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">();</span> <span class="p">}</span>
    <span class="kr">inline</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">forceAlignedAccess</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">Enable</span><span class="o">&gt;</span> <span class="kr">inline</span> <span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">forceAlignedAccessIf</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">Enable</span><span class="o">&gt;</span> <span class="kr">inline</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">forceAlignedAccessIf</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">Scalar</span> <span class="n">trace</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/PlainObjectBase.h#L491">PlainObjectBase.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>487
488
489
490
491
492
493
494
495
496
497
498</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">//       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED</span>
    <span class="p">}</span>

<span class="cp">#ifndef EIGEN_PARSED_BY_DOXYGEN</span>
<span class="hll">    <span class="c1">// FIXME is it still needed ?</span>
</span>    <span class="cm">/** \internal */</span>
    <span class="n">EIGEN_DEVICE_FUNC</span>
    <span class="k">explicit</span> <span class="n">PlainObjectBase</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">constructor_without_unaligned_array_assert</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">m_storage</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">constructor_without_unaligned_array_assert</span><span class="p">())</span>
    <span class="p">{</span>
<span class="c1">//       _check_template_params(); EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/PlainObjectBase.h#L556">PlainObjectBase.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>552
553
554
555
556
557
558
559
560
561
562
563</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">EIGEN_DEVICE_FUNC</span>
    <span class="n">EIGEN_STRONG_INLINE</span> <span class="nf">PlainObjectBase</span><span class="p">(</span><span class="k">const</span> <span class="n">ReturnByValue</span><span class="o">&lt;</span><span class="n">OtherDerived</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">_check_template_params</span><span class="p">();</span>
<span class="hll">      <span class="c1">// FIXME this does not automatically transpose vectors if necessary</span>
</span>      <span class="n">resize</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span> <span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
      <span class="n">other</span><span class="p">.</span><span class="n">evalTo</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">derived</span><span class="p">());</span>
    <span class="p">}</span>

  <span class="k">public</span><span class="o">:</span>

    <span class="cm">/** \brief Copies the generic expression \a other into *this.</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Product.h#L42">Product.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>38
39
40
41
42
43
44
45
46
47
48
49</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">ColsAtCompileTime</span>    <span class="o">=</span> <span class="n">RhsTraits</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="p">,</span>
    <span class="n">MaxRowsAtCompileTime</span> <span class="o">=</span> <span class="n">LhsTraits</span><span class="o">::</span><span class="n">MaxRowsAtCompileTime</span><span class="p">,</span>
    <span class="n">MaxColsAtCompileTime</span> <span class="o">=</span> <span class="n">RhsTraits</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span><span class="p">,</span>

<span class="hll">    <span class="c1">// FIXME: only needed by GeneralMatrixMatrixTriangular</span>
</span>    <span class="n">InnerSize</span> <span class="o">=</span> <span class="n">EIGEN_SIZE_MIN_PREFER_FIXED</span><span class="p">(</span><span class="n">LhsTraits</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="p">,</span> <span class="n">RhsTraits</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="p">),</span>

    <span class="c1">// The storage order is somewhat arbitrary here. The correct one will be determined through the evaluator.</span>
    <span class="n">Flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">MaxRowsAtCompileTime</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">MaxColsAtCompileTime</span><span class="o">!=</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nl">RowMajorBit</span>
          <span class="p">:</span> <span class="p">(</span><span class="n">MaxColsAtCompileTime</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">MaxRowsAtCompileTime</span><span class="o">!=</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span>
          <span class="o">:</span> <span class="p">(</span>   <span class="p">((</span><span class="n">LhsTraits</span><span class="o">::</span><span class="n">Flags</span><span class="o">&amp;</span><span class="n">NoPreferredStorageOrderBit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">RhsTraits</span><span class="o">::</span><span class="n">Flags</span><span class="o">&amp;</span><span class="n">RowMajorBit</span><span class="p">))</span>
             <span class="o">||</span> <span class="p">((</span><span class="n">RhsTraits</span><span class="o">::</span><span class="n">Flags</span><span class="o">&amp;</span><span class="n">NoPreferredStorageOrderBit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">LhsTraits</span><span class="o">::</span><span class="n">Flags</span><span class="o">&amp;</span><span class="n">RowMajorBit</span><span class="p">))</span> <span class="p">)</span> <span class="o">?</span> <span class="n">RowMajorBit</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L39">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>35
36
37
38
39
40
41
42
43
44
45
46</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="k">explicit</span> <span class="nf">evaluator</span><span class="p">(</span><span class="k">const</span> <span class="n">XprType</span><span class="o">&amp;</span> <span class="n">xpr</span><span class="p">)</span> <span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">xpr</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// Catch &quot;scalar * ( A * B )&quot; and transform it to &quot;(A*scalar) * B&quot;</span>
<span class="hll"><span class="c1">// TODO we should apply that rule only if that&#39;s really helpful</span>
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Scalar1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Scalar2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Plain1</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">evaluator_assume_aliasing</span><span class="o">&lt;</span><span class="n">CwiseBinaryOp</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">scalar_product_op</span><span class="o">&lt;</span><span class="n">Scalar1</span><span class="p">,</span><span class="n">Scalar2</span><span class="o">&gt;</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">CwiseNullaryOp</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">scalar_constant_op</span><span class="o">&lt;</span><span class="n">Scalar1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Plain1</span><span class="o">&gt;</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="p">,</span> <span class="n">DefaultProduct</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L112">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>108
109
110
111
112
113
114
115
116
117
118
119</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="o">:</span> <span class="n">m_result</span><span class="p">(</span><span class="n">xpr</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span> <span class="n">xpr</span><span class="p">.</span><span class="n">cols</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="n">Base</span><span class="p">(</span><span class="n">m_result</span><span class="p">);</span>

<span class="hll"><span class="c1">// FIXME shall we handle nested_eval here?,</span>
</span><span class="c1">// if so, then we must take care at removing the call to nested_eval in the specializations (e.g., in permutation_matrix_product, transposition_matrix_product, etc.)</span>
<span class="c1">//     typedef typename internal::nested_eval&lt;Lhs,Rhs::ColsAtCompileTime&gt;::type LhsNested;</span>
<span class="c1">//     typedef typename internal::nested_eval&lt;Rhs,Lhs::RowsAtCompileTime&gt;::type RhsNested;</span>
<span class="c1">//     typedef typename internal::remove_all&lt;LhsNested&gt;::type LhsNestedCleaned;</span>
<span class="c1">//     typedef typename internal::remove_all&lt;RhsNested&gt;::type RhsNestedCleaned;</span>
<span class="c1">//</span>
<span class="c1">//     const LhsNested lhs(xpr.lhs());</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L132">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>128
129
130
131
132
133
134
135
136
137
138
139</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">PlainObject</span> <span class="n">m_result</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The following three shortcuts are enabled only if the scalar types match excatly.</span>
<span class="hll"><span class="c1">// TODO: we could enable them for different scalar types when the product is not vectorized.</span>
</span>
<span class="c1">// Dense = Product</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">DstXprType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Options</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Assignment</span><span class="o">&lt;</span><span class="n">DstXprType</span><span class="p">,</span> <span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="p">,</span><span class="n">Options</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">assign_op</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Dense2Dense</span><span class="p">,</span>
  <span class="k">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Options</span><span class="o">==</span><span class="n">DefaultProduct</span> <span class="o">||</span> <span class="n">Options</span><span class="o">==</span><span class="n">AliasFreeProduct</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="p">,</span><span class="n">Options</span><span class="o">&gt;</span> <span class="n">SrcXprType</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L147">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>143
144
145
146
147
148
149
150
151
152
153
154</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">Index</span> <span class="n">dstRows</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span>
    <span class="n">Index</span> <span class="n">dstCols</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">();</span>
    <span class="k">if</span><span class="p">((</span><span class="n">dst</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span><span class="o">!=</span><span class="n">dstRows</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span><span class="o">!=</span><span class="n">dstCols</span><span class="p">))</span>
      <span class="n">dst</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">dstRows</span><span class="p">,</span> <span class="n">dstCols</span><span class="p">);</span>
<span class="hll">    <span class="c1">// FIXME shall we handle nested_eval here?</span>
</span>    <span class="n">generic_product_impl</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="o">&gt;::</span><span class="n">evalTo</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">rhs</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Dense += Product</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">DstXprType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Options</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Assignment</span><span class="o">&lt;</span><span class="n">DstXprType</span><span class="p">,</span> <span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="p">,</span><span class="n">Options</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">add_assign_op</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Dense2Dense</span><span class="p">,</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L162">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>158
159
160
161
162
163
164
165
166
167
168
169</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">static</span> <span class="n">EIGEN_STRONG_INLINE</span>
  <span class="kt">void</span> <span class="nf">run</span><span class="p">(</span><span class="n">DstXprType</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">SrcXprType</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">internal</span><span class="o">::</span><span class="n">add_assign_op</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">eigen_assert</span><span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span> <span class="o">==</span> <span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span> <span class="o">==</span> <span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
<span class="hll">    <span class="c1">// FIXME shall we handle nested_eval here?</span>
</span>    <span class="n">generic_product_impl</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="o">&gt;::</span><span class="n">addTo</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">rhs</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Dense -= Product</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">DstXprType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Options</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Assignment</span><span class="o">&lt;</span><span class="n">DstXprType</span><span class="p">,</span> <span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="p">,</span><span class="n">Options</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">sub_assign_op</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Dense2Dense</span><span class="p">,</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L177">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>173
174
175
176
177
178
179
180
181
182
183
184</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">static</span> <span class="n">EIGEN_STRONG_INLINE</span>
  <span class="kt">void</span> <span class="nf">run</span><span class="p">(</span><span class="n">DstXprType</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">SrcXprType</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">internal</span><span class="o">::</span><span class="n">sub_assign_op</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">eigen_assert</span><span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span> <span class="o">==</span> <span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span> <span class="o">==</span> <span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
<span class="hll">    <span class="c1">// FIXME shall we handle nested_eval here?</span>
</span>    <span class="n">generic_product_impl</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="o">&gt;::</span><span class="n">subTo</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">rhs</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>


<span class="c1">// Dense ?= scalar * Product</span>
<span class="c1">// TODO we should apply that rule if that&#39;s really helpful</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L184">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>180
181
182
183
184
185
186
187
188
189
190
191</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">};</span>


<span class="c1">// Dense ?= scalar * Product</span>
<span class="hll"><span class="c1">// TODO we should apply that rule if that&#39;s really helpful</span>
</span><span class="c1">// for instance, this is not good for inner products</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">DstXprType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">AssignFunc</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ScalarBis</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Plain</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Assignment</span><span class="o">&lt;</span><span class="n">DstXprType</span><span class="p">,</span> <span class="n">CwiseBinaryOp</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">scalar_product_op</span><span class="o">&lt;</span><span class="n">ScalarBis</span><span class="p">,</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">CwiseNullaryOp</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">scalar_constant_op</span><span class="o">&lt;</span><span class="n">ScalarBis</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Plain</span><span class="o">&gt;</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="p">,</span><span class="n">DefaultProduct</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">AssignFunc</span><span class="p">,</span> <span class="n">Dense2Dense</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">CwiseBinaryOp</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">scalar_product_op</span><span class="o">&lt;</span><span class="n">ScalarBis</span><span class="p">,</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">CwiseNullaryOp</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">scalar_constant_op</span><span class="o">&lt;</span><span class="n">ScalarBis</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Plain</span><span class="o">&gt;</span><span class="p">,</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L202">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>198
199
200
201
202
203
204
205
206
207
208</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">};</span>

<span class="c1">//----------------------------------------</span>
<span class="c1">// Catch &quot;Dense ?= xpr + Product&lt;&gt;&quot; expression to save one temporary</span>
<span class="hll"><span class="c1">// FIXME we could probably enable these rules for any product, i.e., not only Dense and DefaultProduct</span>
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherXpr</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">evaluator_assume_aliasing</span><span class="o">&lt;</span><span class="n">CwiseBinaryOp</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">scalar_sum_op</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherXpr</span><span class="o">::</span><span class="n">Scalar</span><span class="p">,</span><span class="k">typename</span> <span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="p">,</span><span class="n">DefaultProduct</span><span class="o">&gt;::</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">OtherXpr</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="p">,</span><span class="n">DefaultProduct</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">DenseShape</span> <span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L276">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>272
273
274
275
276
277
278
279
280
281
282
283</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">outer_product_selector_run</span><span class="p">(</span><span class="n">Dst</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Lhs</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rhs</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Func</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="k">const</span> <span class="n">false_type</span><span class="o">&amp;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span> <span class="n">rhsEval</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
  <span class="k">typename</span> <span class="n">nested_eval</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="o">::</span><span class="n">SizeAtCompileTime</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">actual_lhs</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
<span class="hll">  <span class="c1">// FIXME if cols is large enough, then it might be useful to make sure that lhs is sequentially stored</span>
</span>  <span class="c1">// FIXME not very good if rhs is real and lhs complex while alpha is real too</span>
  <span class="k">const</span> <span class="n">Index</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">cols</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="n">func</span><span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">rhsEval</span><span class="p">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">Index</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">actual_lhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Row major result</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L277">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>273
274
275
276
277
278
279
280
281
282
283
284</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span> <span class="n">rhsEval</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
  <span class="k">typename</span> <span class="n">nested_eval</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="o">::</span><span class="n">SizeAtCompileTime</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">actual_lhs</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
  <span class="c1">// FIXME if cols is large enough, then it might be useful to make sure that lhs is sequentially stored</span>
<span class="hll">  <span class="c1">// FIXME not very good if rhs is real and lhs complex while alpha is real too</span>
</span>  <span class="k">const</span> <span class="n">Index</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">cols</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="n">func</span><span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">rhsEval</span><span class="p">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">Index</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">actual_lhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Row major result</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dst</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Func</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L289">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>285
286
287
288
289
290
291
292
293
294
295
296</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">outer_product_selector_run</span><span class="p">(</span><span class="n">Dst</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Lhs</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rhs</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Func</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="k">const</span> <span class="n">true_type</span><span class="o">&amp;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span> <span class="n">lhsEval</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
  <span class="k">typename</span> <span class="n">nested_eval</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="p">,</span><span class="n">Lhs</span><span class="o">::</span><span class="n">SizeAtCompileTime</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">actual_rhs</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
<span class="hll">  <span class="c1">// FIXME if rows is large enough, then it might be useful to make sure that rhs is sequentially stored</span>
</span>  <span class="c1">// FIXME not very good if lhs is real and rhs complex while alpha is real too</span>
  <span class="k">const</span> <span class="n">Index</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">func</span><span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">lhsEval</span><span class="p">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">Index</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">actual_rhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L290">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>286
287
288
289
290
291
292
293
294
295
296
297</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span> <span class="n">lhsEval</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
  <span class="k">typename</span> <span class="n">nested_eval</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="p">,</span><span class="n">Lhs</span><span class="o">::</span><span class="n">SizeAtCompileTime</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">actual_rhs</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
  <span class="c1">// FIXME if rows is large enough, then it might be useful to make sure that rhs is sequentially stored</span>
<span class="hll">  <span class="c1">// FIXME not very good if lhs is real and rhs complex while alpha is real too</span>
</span>  <span class="k">const</span> <span class="n">Index</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">func</span><span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">lhsEval</span><span class="p">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">Index</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">actual_rhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">generic_product_impl</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="p">,</span><span class="n">DenseShape</span><span class="p">,</span><span class="n">DenseShape</span><span class="p">,</span><span class="n">OuterProduct</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L302">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>298
299
300
301
302
303
304
305
306
307
308
309</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nl">is_row_major</span> <span class="p">:</span> <span class="n">internal</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="n">Flags</span><span class="p">)</span><span class="o">&amp;</span><span class="n">RowMajorBit</span><span class="p">),</span> <span class="n">internal</span><span class="o">::</span><span class="n">true_type</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">false_type</span><span class="o">&gt;::</span><span class="n">type</span> <span class="p">{};</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="o">&gt;::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>

<span class="hll">  <span class="c1">// TODO it would be nice to be able to exploit our *_assign_op functors for that purpose</span>
</span>  <span class="k">struct</span> <span class="n">set</span>  <span class="p">{</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dst</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Src</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Dst</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Src</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">dst</span><span class="p">.</span><span class="n">const_cast_derived</span><span class="p">()</span>  <span class="o">=</span> <span class="n">src</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
  <span class="k">struct</span> <span class="n">add</span>  <span class="p">{</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dst</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Src</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Dst</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Src</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">dst</span><span class="p">.</span><span class="n">const_cast_derived</span><span class="p">()</span> <span class="o">+=</span> <span class="n">src</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
  <span class="k">struct</span> <span class="n">sub</span>  <span class="p">{</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dst</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Src</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Dst</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Src</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">dst</span><span class="p">.</span><span class="n">const_cast_derived</span><span class="p">()</span> <span class="o">-=</span> <span class="n">src</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
  <span class="k">struct</span> <span class="n">adds</span> <span class="p">{</span>
    <span class="n">Scalar</span> <span class="n">m_scale</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="nf">adds</span><span class="p">(</span><span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_scale</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dst</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Src</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Dst</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Src</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L527">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>523
524
525
526
527
528
529
530
531
532
533
534</pre></div></td><td class="code"><div class="highlight"><pre><span></span>                    <span class="o">:</span> <span class="p">(</span><span class="kt">bool</span><span class="p">(</span><span class="n">RhsRowMajor</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">CanVectorizeLhs</span><span class="p">),</span>

    <span class="n">Flags</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">LhsFlags</span> <span class="o">|</span> <span class="n">RhsFlags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HereditaryBits</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RowMajorBit</span><span class="p">)</span>
          <span class="o">|</span> <span class="p">(</span><span class="n">EvalToRowMajor</span> <span class="o">?</span> <span class="nl">RowMajorBit</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="hll">          <span class="c1">// TODO enable vectorization for mixed types</span>
</span>          <span class="o">|</span> <span class="p">(</span><span class="n">SameType</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">CanVectorizeLhs</span> <span class="o">||</span> <span class="n">CanVectorizeRhs</span><span class="p">)</span> <span class="o">?</span> <span class="nl">PacketAccessBit</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
          <span class="o">|</span> <span class="p">(</span><span class="n">XprType</span><span class="o">::</span><span class="n">IsVectorAtCompileTime</span> <span class="o">?</span> <span class="nl">LinearAccessBit</span> <span class="p">:</span> <span class="mi">0</span><span class="p">),</span>

    <span class="n">LhsOuterStrideBytes</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">LhsNestedCleaned</span><span class="o">::</span><span class="n">OuterStrideAtCompileTime</span><span class="p">)</span> <span class="o">*</span> <span class="kt">int</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">typename</span> <span class="n">LhsNestedCleaned</span><span class="o">::</span><span class="n">Scalar</span><span class="p">)),</span>
    <span class="n">RhsOuterStrideBytes</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">RhsNestedCleaned</span><span class="o">::</span><span class="n">OuterStrideAtCompileTime</span><span class="p">)</span> <span class="o">*</span> <span class="kt">int</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">typename</span> <span class="n">RhsNestedCleaned</span><span class="o">::</span><span class="n">Scalar</span><span class="p">)),</span>

    <span class="n">Alignment</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="n">CanVectorizeLhs</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">LhsOuterStrideBytes</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">LhsOuterStrideBytes</span><span class="p">)</span> <span class="o">%</span> <span class="n">EIGEN_PLAIN_ENUM_MAX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">LhsAlignment</span><span class="p">))</span><span class="o">!=</span><span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">LhsAlignment</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L557">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>553
554
555
556
557
558
559
560
561
562
563
564</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>

  <span class="cm">/* Allow index-based non-packet access. It is impossible though to allow index-based packed access,</span>
<span class="cm">   * which is why we don&#39;t set the LinearAccessBit.</span>
<span class="hll"><span class="cm">   * TODO: this seems possible when the result is a vector</span>
</span><span class="cm">   */</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="k">const</span> <span class="n">CoeffReturnType</span> <span class="n">coeff</span><span class="p">(</span><span class="n">Index</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="k">const</span> <span class="n">Index</span> <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">RowsAtCompileTime</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">MaxRowsAtCompileTime</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">index</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">Index</span> <span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="n">RowsAtCompileTime</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">MaxRowsAtCompileTime</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nl">index</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m_lhs</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">row</span><span class="p">).</span><span class="n">transpose</span><span class="p">().</span><span class="n">cwiseProduct</span><span class="p">(</span> <span class="n">m_rhs</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="p">)).</span><span class="n">sum</span><span class="p">();</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L592">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>588
589
590
591
592
593
594
595
596
597
598</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">LhsEtorType</span> <span class="n">m_lhsImpl</span><span class="p">;</span>
  <span class="n">RhsEtorType</span> <span class="n">m_rhsImpl</span><span class="p">;</span>

  <span class="c1">// TODO: Get rid of m_innerDim if known at compile time</span>
<span class="hll">  <span class="n">Index</span> <span class="n">m_innerDim</span><span class="p">;</span>
</span><span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">product_evaluator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="p">,</span> <span class="n">DefaultProduct</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">LazyCoeffBasedProductMode</span><span class="p">,</span> <span class="n">DenseShape</span><span class="p">,</span> <span class="n">DenseShape</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">product_evaluator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="p">,</span> <span class="n">LazyProduct</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">CoeffBasedProductMode</span><span class="p">,</span> <span class="n">DenseShape</span><span class="p">,</span> <span class="n">DenseShape</span><span class="o">&gt;</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L783">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>779
780
781
782
783
784
785
786
787
788
789
790</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">_StorageOrder</span> <span class="o">=</span> <span class="n">MatrixFlags</span> <span class="o">&amp;</span> <span class="n">RowMajorBit</span> <span class="o">?</span> <span class="nl">RowMajor</span> <span class="p">:</span> <span class="n">ColMajor</span><span class="p">,</span>
    <span class="n">_ScalarAccessOnDiag</span> <span class="o">=</span>  <span class="o">!</span><span class="p">((</span><span class="kt">int</span><span class="p">(</span><span class="n">_StorageOrder</span><span class="p">)</span> <span class="o">==</span> <span class="n">ColMajor</span> <span class="o">&amp;&amp;</span> <span class="kt">int</span><span class="p">(</span><span class="n">ProductOrder</span><span class="p">)</span> <span class="o">==</span> <span class="n">OnTheLeft</span><span class="p">)</span>
                           <span class="o">||</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">_StorageOrder</span><span class="p">)</span> <span class="o">==</span> <span class="n">RowMajor</span> <span class="o">&amp;&amp;</span> <span class="kt">int</span><span class="p">(</span><span class="n">ProductOrder</span><span class="p">)</span> <span class="o">==</span> <span class="n">OnTheRight</span><span class="p">)),</span>
    <span class="n">_SameTypes</span> <span class="o">=</span> <span class="n">is_same</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DiagonalType</span><span class="o">::</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
<span class="hll">    <span class="c1">// FIXME currently we need same types, but in the future the next rule should be the one</span>
</span>    <span class="c1">//_Vectorizable = bool(int(MatrixFlags)&amp;PacketAccessBit) &amp;&amp; ((!_PacketOnDiag) || (_SameTypes &amp;&amp; bool(int(DiagFlags)&amp;PacketAccessBit))),</span>
    <span class="n">_Vectorizable</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">MatrixFlags</span><span class="p">)</span><span class="o">&amp;</span><span class="n">PacketAccessBit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">_SameTypes</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">_ScalarAccessOnDiag</span> <span class="o">||</span> <span class="p">(</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">DiagFlags</span><span class="p">)</span><span class="o">&amp;</span><span class="n">PacketAccessBit</span><span class="p">))),</span>
    <span class="n">_LinearAccessMask</span> <span class="o">=</span> <span class="p">(</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="o">==</span><span class="mi">1</span> <span class="o">||</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nl">LinearAccessBit</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Flags</span> <span class="o">=</span> <span class="p">((</span><span class="n">HereditaryBits</span><span class="o">|</span><span class="n">_LinearAccessMask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">MatrixFlags</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">_Vectorizable</span> <span class="o">?</span> <span class="nl">PacketAccessBit</span> <span class="p">:</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">Alignment</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">Alignment</span><span class="p">,</span>

    <span class="n">AsScalarProduct</span> <span class="o">=</span>     <span class="p">(</span><span class="n">DiagonalType</span><span class="o">::</span><span class="n">SizeAtCompileTime</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L865">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>861
862
863
864
865
866
867
868
869
870
871
872</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#ifndef __CUDACC__</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">LoadMode</span><span class="p">,</span><span class="k">typename</span> <span class="n">PacketType</span><span class="o">&gt;</span>
  <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">PacketType</span> <span class="n">packet</span><span class="p">(</span><span class="n">Index</span> <span class="n">row</span><span class="p">,</span> <span class="n">Index</span> <span class="n">col</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME: NVCC used to complain about the template keyword, but we have to check whether this is still the case.</span>
</span>    <span class="c1">// See also similar calls below.</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="k">template</span> <span class="n">packet_impl</span><span class="o">&lt;</span><span class="n">LoadMode</span><span class="p">,</span><span class="n">PacketType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span>
                                 <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">StorageOrder</span><span class="p">)</span><span class="o">==</span><span class="n">RowMajor</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">true_type</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">false_type</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">LoadMode</span><span class="p">,</span><span class="k">typename</span> <span class="n">PacketType</span><span class="o">&gt;</span>
  <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">PacketType</span> <span class="n">packet</span><span class="p">(</span><span class="n">Index</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L944">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>940
941
942
943
944
945
946
947
948
949
950
951</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">run</span><span class="p">(</span><span class="n">Dest</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">PermutationType</span><span class="o">&amp;</span> <span class="n">perm</span><span class="p">,</span> <span class="k">const</span> <span class="n">ExpressionType</span><span class="o">&amp;</span> <span class="n">xpr</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">MatrixType</span> <span class="n">mat</span><span class="p">(</span><span class="n">xpr</span><span class="p">);</span>
      <span class="k">const</span> <span class="n">Index</span> <span class="n">n</span> <span class="o">=</span> <span class="n">Side</span><span class="o">==</span><span class="n">OnTheLeft</span> <span class="o">?</span> <span class="n">mat</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span> <span class="o">:</span> <span class="n">mat</span><span class="p">.</span><span class="n">cols</span><span class="p">();</span>
<span class="hll">      <span class="c1">// FIXME we need an is_same for expression that is not sensitive to constness. For instance</span>
</span>      <span class="c1">// is_same_xpr&lt;Block&lt;const Matrix&gt;, Block&lt;Matrix&gt; &gt;::value should be true.</span>
      <span class="c1">//if(is_same&lt;MatrixTypeCleaned,Dest&gt;::value &amp;&amp; extract_data(dst) == extract_data(mat))</span>
      <span class="k">if</span><span class="p">(</span><span class="n">is_same_dense</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">mat</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="c1">// apply the permutation inplace</span>
        <span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="n">PermutationType</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">PermutationType</span><span class="o">::</span><span class="n">MaxRowsAtCompileTime</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">(</span><span class="n">perm</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="n">mask</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ProductEvaluators.h#L1035">ProductEvaluators.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1031
1032
1033
1034
1035
1036
1037
1038
1039
1040
1041
1042</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/***************************************************************************</span>
<span class="cm">* Products with transpositions matrices</span>
<span class="cm">***************************************************************************/</span>

<span class="hll"><span class="c1">// FIXME could we unify Transpositions and Permutation into a single &quot;shape&quot;??</span>
</span>
<span class="cm">/** \internal</span>
<span class="cm">  * \class transposition_matrix_product</span>
<span class="cm">  * Internal helper class implementing the product between a permutation matrix and a matrix.</span>
<span class="cm">  */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ExpressionType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Side</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">Transposed</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ExpressionShape</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">transposition_matrix_product</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Redux.h#L18">Redux.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">Eigen</span> <span class="p">{</span>

<span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

<span class="hll"><span class="c1">// TODO</span>
</span><span class="c1">//  * implement other kind of vectorization</span>
<span class="c1">//  * factorize code</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">* Part 1 : the logic deciding a strategy for vectorization and unrolling</span>
<span class="cm">***************************************************************************/</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Redux.h#L348">Redux.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>344
345
346
347
348
349
350
351
352
353
354</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">MaxRowsAtCompileTime</span> <span class="o">=</span> <span class="n">XprType</span><span class="o">::</span><span class="n">MaxRowsAtCompileTime</span><span class="p">,</span>
    <span class="n">MaxColsAtCompileTime</span> <span class="o">=</span> <span class="n">XprType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span><span class="p">,</span>
    <span class="c1">// TODO we should not remove DirectAccessBit and rather find an elegant way to query the alignment offset at runtime from the evaluator</span>
<span class="hll">    <span class="n">Flags</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DirectAccessBit</span><span class="p">,</span>
</span>    <span class="n">IsRowMajor</span> <span class="o">=</span> <span class="n">XprType</span><span class="o">::</span><span class="n">IsRowMajor</span><span class="p">,</span>
    <span class="n">SizeAtCompileTime</span> <span class="o">=</span> <span class="n">XprType</span><span class="o">::</span><span class="n">SizeAtCompileTime</span><span class="p">,</span>
    <span class="n">InnerSizeAtCompileTime</span> <span class="o">=</span> <span class="n">XprType</span><span class="o">::</span><span class="n">InnerSizeAtCompileTime</span><span class="p">,</span>
    <span class="n">CoeffReadCost</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">CoeffReadCost</span><span class="p">,</span>
    <span class="n">Alignment</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;::</span><span class="n">Alignment</span>
  <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Replicate.h#L32">Replicate.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span></span>                      <span class="o">:</span> <span class="n">RowFactor</span> <span class="o">*</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="p">,</span>
    <span class="n">ColsAtCompileTime</span> <span class="o">=</span> <span class="n">ColFactor</span><span class="o">==</span><span class="n">Dynamic</span> <span class="o">||</span> <span class="kt">int</span><span class="p">(</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="p">)</span><span class="o">==</span><span class="n">Dynamic</span>
                      <span class="o">?</span> <span class="nl">Dynamic</span>
                      <span class="p">:</span> <span class="n">ColFactor</span> <span class="o">*</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="p">,</span>
<span class="hll">   <span class="c1">//FIXME we don&#39;t propagate the max sizes !!!</span>
</span>    <span class="n">MaxRowsAtCompileTime</span> <span class="o">=</span> <span class="n">RowsAtCompileTime</span><span class="p">,</span>
    <span class="n">MaxColsAtCompileTime</span> <span class="o">=</span> <span class="n">ColsAtCompileTime</span><span class="p">,</span>
    <span class="n">IsRowMajor</span> <span class="o">=</span> <span class="n">MaxRowsAtCompileTime</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">MaxColsAtCompileTime</span><span class="o">!=</span><span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span>
               <span class="o">:</span> <span class="n">MaxColsAtCompileTime</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">MaxRowsAtCompileTime</span><span class="o">!=</span><span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span>
               <span class="o">:</span> <span class="p">(</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">RowMajorBit</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>

    <span class="c1">// FIXME enable DirectAccess with negative strides?</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Replicate.h#L39">Replicate.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>35
36
37
38
39
40
41
42
43
44
45
46</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">IsRowMajor</span> <span class="o">=</span> <span class="n">MaxRowsAtCompileTime</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">MaxColsAtCompileTime</span><span class="o">!=</span><span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span>
               <span class="o">:</span> <span class="n">MaxColsAtCompileTime</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">MaxRowsAtCompileTime</span><span class="o">!=</span><span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span>
               <span class="o">:</span> <span class="p">(</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">RowMajorBit</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>

<span class="hll">    <span class="c1">// FIXME enable DirectAccess with negative strides?</span>
</span>    <span class="n">Flags</span> <span class="o">=</span> <span class="n">IsRowMajor</span> <span class="o">?</span> <span class="nl">RowMajorBit</span> <span class="p">:</span> <span class="mi">0</span>
  <span class="p">};</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">  * \class Replicate</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ReturnByValue.h#L35">ReturnByValue.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>31
32
33
34
35
36
37
38
39
40
41
42</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/* The ReturnByValue object doesn&#39;t even have a coeff() method.</span>
<span class="cm"> * So the only way that nesting it in an expression can work, is by evaluating it into a plain matrix.</span>
<span class="cm"> * So internal::nested always gives the plain return matrix type.</span>
<span class="cm"> *</span>
<span class="hll"><span class="cm"> * FIXME: I don&#39;t understand why we need this specialization: isn&#39;t this taken care of by the EvalBeforeNestingBit ??</span>
</span><span class="cm"> * Answer: EvalBeforeNestingBit should be deprecated since we have the evaluators</span>
<span class="cm"> */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="k">typename</span> <span class="n">PlainObject</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">nested_eval</span><span class="o">&lt;</span><span class="n">ReturnByValue</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">PlainObject</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;::</span><span class="n">ReturnType</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/ReturnByValue.h#L92">ReturnByValue.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>88
89
90
91
92
93
94
95
96
97
98
99</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

<span class="c1">// Expression is evaluated in a temporary; default implementation of Assignment is bypassed so that</span>
<span class="c1">// when a ReturnByValue expression is assigned, the evaluator is not constructed.</span>
<span class="hll"><span class="c1">// TODO: Finalize port to new regime; ReturnByValue should not exist in the expression world</span>
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">ReturnByValue</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span> <span class="o">&gt;</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">traits</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;::</span><span class="n">ReturnType</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">ReturnByValue</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span> <span class="n">XprType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">traits</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;::</span><span class="n">ReturnType</span> <span class="n">PlainObject</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/SelfAdjointView.h#L268">SelfAdjointView.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>264
265
266
267
268
269
270
271
272
273
274
275</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// selfadjoint to dense matrix</span>

<span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

<span class="hll"><span class="c1">// TODO currently a selfadjoint expression has the form SelfAdjointView&lt;.,.&gt;</span>
</span><span class="c1">//      in the future selfadjoint-ness should be defined by the expression traits</span>
<span class="c1">//      such that Transpose&lt;SelfAdjointView&lt;.,.&gt; &gt; is valid. (currently TriangularBase::transpose() is overloaded to make it work)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Mode</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">evaluator_traits</span><span class="o">&lt;</span><span class="n">SelfAdjointView</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span><span class="n">Mode</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">storage_kind_to_evaluator_kind</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">StorageKind</span><span class="o">&gt;::</span><span class="n">Kind</span> <span class="n">Kind</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">SelfAdjointShape</span> <span class="n">Shape</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/SelfCwiseBinaryOp.h#L15">SelfCwiseBinaryOp.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#define EIGEN_SELFCWISEBINARYOP_H</span>

<span class="k">namespace</span> <span class="n">Eigen</span> <span class="p">{</span>

<span class="hll"><span class="c1">// TODO generalize the scalar type of &#39;other&#39;</span>
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="o">&gt;</span>
<span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">DenseBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">internal</span><span class="o">::</span><span class="n">call_assignment</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">derived</span><span class="p">(),</span> <span class="n">PlainObject</span><span class="o">::</span><span class="n">Constant</span><span class="p">(</span><span class="n">rows</span><span class="p">(),</span><span class="n">cols</span><span class="p">(),</span><span class="n">other</span><span class="p">),</span> <span class="n">internal</span><span class="o">::</span><span class="n">mul_assign_op</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="k">return</span> <span class="nf">derived</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/SolveTriangular.h#L61">SolveTriangular.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>57
58
59
60
61
62
63
64
65
66
67
68</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">static</span> <span class="kt">void</span> <span class="nf">run</span><span class="p">(</span><span class="k">const</span> <span class="n">Lhs</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ActualLhsType</span> <span class="n">actualLhs</span> <span class="o">=</span> <span class="n">LhsProductTraits</span><span class="o">::</span><span class="n">extract</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>

<span class="hll">    <span class="c1">// FIXME find a way to allow an inner stride if packet_traits&lt;Scalar&gt;::size==1</span>
</span>
    <span class="kt">bool</span> <span class="n">useRhsDirectly</span> <span class="o">=</span> <span class="n">Rhs</span><span class="o">::</span><span class="n">InnerStrideAtCompileTime</span><span class="o">==</span><span class="mi">1</span> <span class="o">||</span> <span class="n">rhs</span><span class="p">.</span><span class="n">innerStride</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">ei_declare_aligned_stack_constructed_variable</span><span class="p">(</span><span class="n">RhsScalar</span><span class="p">,</span><span class="n">actualRhs</span><span class="p">,</span><span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
                                                  <span class="p">(</span><span class="n">useRhsDirectly</span> <span class="o">?</span> <span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">useRhsDirectly</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/StableNorm.h#L47">StableNorm.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>43
44
45
46
47
48
49
50
51
52
53
54</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">{</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">maxCoeff</span><span class="p">;</span>
  <span class="p">}</span>

<span class="hll">  <span class="c1">// TODO if the maxCoeff is much much smaller than the current scale,</span>
</span>  <span class="c1">// then we can neglect this sub vector</span>
  <span class="k">if</span><span class="p">(</span><span class="n">scale</span><span class="o">&gt;</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="c1">// if scale==0, then bl is 0</span>
    <span class="n">ssq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bl</span><span class="o">*</span><span class="n">invScale</span><span class="p">).</span><span class="n">squaredNorm</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">typename</span> <span class="n">NumTraits</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;::</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">Real</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Swap.h#L53">Swap.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">SrcEvaluatorTypeT</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">m_src</span><span class="p">).</span><span class="k">template</span> <span class="n">writePacket</span><span class="o">&lt;</span><span class="n">LoadMode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">m_dst</span><span class="p">.</span><span class="k">template</span> <span class="n">packet</span><span class="o">&lt;</span><span class="n">StoreMode</span><span class="p">,</span><span class="n">PacketType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">));</span>
    <span class="n">m_dst</span><span class="p">.</span><span class="k">template</span> <span class="n">writePacket</span><span class="o">&lt;</span><span class="n">StoreMode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
  <span class="p">}</span>

<span class="hll">  <span class="c1">// TODO find a simple way not to have to copy/paste this function from generic_dense_assignment_kernel, by simple I mean no CRTP (Gael)</span>
</span>  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">StoreMode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">LoadMode</span><span class="p">,</span> <span class="k">typename</span> <span class="n">PacketType</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">assignPacketByOuterInner</span><span class="p">(</span><span class="n">Index</span> <span class="n">outer</span><span class="p">,</span> <span class="n">Index</span> <span class="n">inner</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Index</span> <span class="n">row</span> <span class="o">=</span> <span class="n">Base</span><span class="o">::</span><span class="n">rowIndexByOuterInner</span><span class="p">(</span><span class="n">outer</span><span class="p">,</span> <span class="n">inner</span><span class="p">);</span>
    <span class="n">Index</span> <span class="n">col</span> <span class="o">=</span> <span class="n">Base</span><span class="o">::</span><span class="n">colIndexByOuterInner</span><span class="p">(</span><span class="n">outer</span><span class="p">,</span> <span class="n">inner</span><span class="p">);</span>
    <span class="n">assignPacket</span><span class="o">&lt;</span><span class="n">StoreMode</span><span class="p">,</span><span class="n">LoadMode</span><span class="p">,</span><span class="n">PacketType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Transpose.h#L137">Transpose.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>133
134
135
136
137
138
139
140
141
142
143</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kr">inline</span> <span class="n">ScalarWithConstIfNotLvalue</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">nestedExpression</span><span class="p">().</span><span class="n">data</span><span class="p">();</span> <span class="p">}</span>
    <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kr">inline</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">nestedExpression</span><span class="p">().</span><span class="n">data</span><span class="p">();</span> <span class="p">}</span>

    <span class="c1">// FIXME: shall we keep the const version of coeffRef?</span>
<span class="hll">    <span class="n">EIGEN_DEVICE_FUNC</span>
</span>    <span class="kr">inline</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">coeffRef</span><span class="p">(</span><span class="n">Index</span> <span class="n">rowId</span><span class="p">,</span> <span class="n">Index</span> <span class="n">colId</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">nestedExpression</span><span class="p">().</span><span class="n">coeffRef</span><span class="p">(</span><span class="n">colId</span><span class="p">,</span> <span class="n">rowId</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">EIGEN_DEVICE_FUNC</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Transpose.h#L235">Transpose.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>231
232
233
234
235
236
237
238
239
240
241
242</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">m</span><span class="p">.</span><span class="n">matrix</span><span class="p">().</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">StrictlyUpper</span><span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matrix</span><span class="p">().</span><span class="n">transpose</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="hll"><span class="c1">// TODO: vectorized path is currently limited to LargestPacketSize x LargestPacketSize cases only.</span>
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">inplace_transpose_selector</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// PacketSize x PacketSize</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="n">MatrixType</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">packet_traits</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">Packet</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">Index</span> <span class="n">PacketSize</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">Index</span> <span class="n">Alignment</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">evaluator</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">Alignment</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/Transpositions.h#L86">Transpositions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>82
83
84
85
86
87
88
89
90
91
92
93</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="k">for</span><span class="p">(</span><span class="n">StorageIndex</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indices</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">coeffRef</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

<span class="hll">    <span class="c1">// FIXME: do we want such methods ?</span>
</span>    <span class="c1">// might be usefull when the target matrix expression is complex, e.g.:</span>
    <span class="c1">// object.matrix().block(..,..,..,..) = trans * object.matrix().block(..,..,..,..);</span>
    <span class="cm">/*</span>
<span class="cm">    template&lt;typename MatrixType&gt;</span>
<span class="cm">    void applyForwardToRows(MatrixType&amp; mat) const</span>
<span class="cm">    {</span>
<span class="cm">      for(Index k=0 ; k&lt;size() ; ++k)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/TriangularMatrix.h#L554">TriangularMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>550
551
552
553
554
555
556
557
558
559
560
561</pre></div></td><td class="code"><div class="highlight"><pre><span></span>* Implementation of triangular evaluation/assignment
***************************************************************************/

#ifndef EIGEN_PARSED_BY_DOXYGEN
<span class="hll">// FIXME should we keep that possibility
</span>template&lt;typename MatrixType, unsigned int Mode&gt;
template&lt;typename OtherDerived&gt;
inline TriangularView&lt;MatrixType, Mode&gt;&amp;
TriangularViewImpl&lt;MatrixType, Mode, Dense&gt;::operator=(const MatrixBase&lt;OtherDerived&gt;&amp; other)
{
  internal::call_assignment_no_alias(derived(), other.derived(), internal::assign_op&lt;Scalar,typename OtherDerived::Scalar&gt;());
  return derived();
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/TriangularMatrix.h#L564">TriangularMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>560
561
562
563
564
565
566
567
568
569
570</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">internal</span><span class="o">::</span><span class="n">call_assignment_no_alias</span><span class="p">(</span><span class="n">derived</span><span class="p">(),</span> <span class="n">other</span><span class="p">.</span><span class="n">derived</span><span class="p">(),</span> <span class="n">internal</span><span class="o">::</span><span class="n">assign_op</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="k">typename</span> <span class="n">OtherDerived</span><span class="o">::</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="k">return</span> <span class="nf">derived</span><span class="p">();</span>
<span class="p">}</span>

<span class="hll"><span class="c1">// FIXME should we keep that possibility</span>
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Mode</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherDerived</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">TriangularViewImpl</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span> <span class="n">Mode</span><span class="p">,</span> <span class="n">Dense</span><span class="o">&gt;::</span><span class="n">lazyAssign</span><span class="p">(</span><span class="k">const</span> <span class="n">MatrixBase</span><span class="o">&lt;</span><span class="n">OtherDerived</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">internal</span><span class="o">::</span><span class="n">call_assignment_no_alias</span><span class="p">(</span><span class="n">derived</span><span class="p">(),</span> <span class="n">other</span><span class="p">.</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Mode</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/TriangularMatrix.h#L702">TriangularMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>698
699
700
701
702
703
704
705
706
707
708</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>


<span class="c1">// TODO currently a triangular expression has the form TriangularView&lt;.,.&gt;</span>
<span class="hll"><span class="c1">//      in the future triangular-ness should be defined by the expression traits</span>
</span><span class="c1">//      such that Transpose&lt;TriangularView&lt;.,.&gt; &gt; is valid. (currently TriangularBase::transpose() is overloaded to make it work)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Mode</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">evaluator_traits</span><span class="o">&lt;</span><span class="n">TriangularView</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span><span class="n">Mode</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">storage_kind_to_evaluator_kind</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">StorageKind</span><span class="o">&gt;::</span><span class="n">Kind</span> <span class="n">Kind</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">glue_shapes</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">evaluator_traits</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">Shape</span><span class="p">,</span> <span class="n">TriangularShape</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">Shape</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/TriangularMatrix.h#L855">TriangularMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>851
852
853
854
855
856
857
858
859
860
861</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Kernel</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">UnrollCount</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">SetOpposite</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">triangular_assignment_loop</span>
<span class="p">{</span>
  <span class="c1">// FIXME: this is not very clean, perhaps this information should be provided by the kernel?</span>
<span class="hll">  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">DstEvaluatorType</span> <span class="n">DstEvaluatorType</span><span class="p">;</span>
</span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">DstEvaluatorType</span><span class="o">::</span><span class="n">XprType</span> <span class="n">DstXprType</span><span class="p">;</span>

  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="n">UnrollCount</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">DstXprType</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="p">,</span>
    <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">UnrollCount</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">DstXprType</span><span class="o">::</span><span class="n">RowsAtCompileTime</span>
  <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/TriangularMatrix.h#L890">TriangularMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>886
887
888
889
890
891
892
893
894
895
896
897</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">};</span>



<span class="hll"><span class="c1">// TODO: experiment with a recursive assignment procedure splitting the current</span>
</span><span class="c1">//       triangular part into one rectangular and two triangular parts.</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Kernel</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">SetOpposite</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">triangular_assignment_loop</span><span class="o">&lt;</span><span class="n">Kernel</span><span class="p">,</span> <span class="n">Mode</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">SetOpposite</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h#L126">MatrixBaseEigenvalues.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>122
123
124
125
126
127
128
129
130
131
132
133</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">MatrixBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;::</span><span class="n">operatorNorm</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">;</span>
  <span class="k">typename</span> <span class="n">Derived</span><span class="o">::</span><span class="n">PlainObject</span> <span class="n">m_eval</span><span class="p">(</span><span class="n">derived</span><span class="p">());</span>
<span class="hll">  <span class="c1">// FIXME if it is really guaranteed that the eigenvalues are already sorted,</span>
</span>  <span class="c1">// then we don&#39;t need to compute a maxCoeff() here, comparing the 1st and last ones is enough.</span>
  <span class="k">return</span> <span class="nf">sqrt</span><span class="p">((</span><span class="n">m_eval</span><span class="o">*</span><span class="n">m_eval</span><span class="p">.</span><span class="n">adjoint</span><span class="p">())</span>
                 <span class="p">.</span><span class="n">eval</span><span class="p">()</span>
             <span class="p">.</span><span class="k">template</span> <span class="n">selfadjointView</span><span class="o">&lt;</span><span class="n">Lower</span><span class="o">&gt;</span><span class="p">()</span>
             <span class="p">.</span><span class="n">eigenvalues</span><span class="p">()</span>
             <span class="p">.</span><span class="n">maxCoeff</span><span class="p">()</span>
             <span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Eigenvalues/RealSchur.h#L356">RealSchur.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>352
353
354
355
356
357
358
359
360
361
362
363</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">RealSchur</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">computeNormOfT</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="n">Index</span> <span class="n">size</span> <span class="o">=</span> <span class="n">m_matT</span><span class="p">.</span><span class="n">cols</span><span class="p">();</span>
<span class="hll">  <span class="c1">// FIXME to be efficient the following would requires a triangular reduxion code</span>
</span>  <span class="c1">// Scalar norm = m_matT.upper().cwiseAbs().sum()</span>
  <span class="c1">//               + m_matT.bottomLeftCorner(size-1,size-1).diagonal().cwiseAbs().sum();</span>
  <span class="n">Scalar</span> <span class="nf">norm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">+=</span> <span class="n">m_matT</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">j</span><span class="p">).</span><span class="n">segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">)(</span><span class="n">size</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">)).</span><span class="n">cwiseAbs</span><span class="p">().</span><span class="n">sum</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">norm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h#L453">SelfAdjointEigenSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>449
450
451
452
453
454
455
456
457
458
459
460</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">&gt;</span>
<span class="n">SelfAdjointEigenSolver</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;&amp;</span> <span class="n">SelfAdjointEigenSolver</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;</span>
<span class="o">::</span><span class="n">computeFromTridiagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">RealVectorType</span><span class="o">&amp;</span> <span class="n">diag</span><span class="p">,</span> <span class="k">const</span> <span class="n">SubDiagonalType</span><span class="o">&amp;</span> <span class="n">subdiag</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">//TODO : Add an option to scale the values beforehand</span>
</span>  <span class="kt">bool</span> <span class="n">computeEigenvectors</span> <span class="o">=</span> <span class="p">(</span><span class="n">options</span><span class="o">&amp;</span><span class="n">ComputeEigenvectors</span><span class="p">)</span><span class="o">==</span><span class="n">ComputeEigenvectors</span><span class="p">;</span>

  <span class="n">m_eivalues</span> <span class="o">=</span> <span class="n">diag</span><span class="p">;</span>
  <span class="n">m_subdiag</span> <span class="o">=</span> <span class="n">subdiag</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">computeEigenvectors</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">m_eivec</span><span class="p">.</span><span class="n">setIdentity</span><span class="p">(</span><span class="n">diag</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">diag</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h#L528">SelfAdjointEigenSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>524
525
526
527
528
529
530
531
532
533
534
535</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">else</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">NoConvergence</span><span class="p">;</span>

  <span class="c1">// Sort eigenvalues and corresponding vectors.</span>
<span class="hll">  <span class="c1">// TODO make the sort optional ?</span>
</span>  <span class="c1">// TODO use a better sort algorithm !!</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="n">Success</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Index</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">diag</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">).</span><span class="n">minCoeff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h#L529">SelfAdjointEigenSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>525
526
527
528
529
530
531
532
533
534
535
536</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">info</span> <span class="o">=</span> <span class="n">NoConvergence</span><span class="p">;</span>

  <span class="c1">// Sort eigenvalues and corresponding vectors.</span>
  <span class="c1">// TODO make the sort optional ?</span>
<span class="hll">  <span class="c1">// TODO use a better sort algorithm !!</span>
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="n">Success</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Index</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">diag</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">).</span><span class="n">minCoeff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h#L639">SelfAdjointEigenSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>635
636
637
638
639
640
641
642
643
644
645
646</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">VectorType</span><span class="o">&amp;</span> <span class="n">eivals</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">m_eivalues</span><span class="p">;</span>

    <span class="c1">// Shift the matrix to the mean eigenvalue and map the matrix coefficients to [-1:1] to avoid over- and underflow.</span>
    <span class="n">Scalar</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">mat</span><span class="p">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="hll">    <span class="c1">// TODO Avoid this copy. Currently it is necessary to suppress bogus values when determining maxCoeff and for computing the eigenvectors later</span>
</span>    <span class="n">MatrixType</span> <span class="n">scaledMat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">.</span><span class="k">template</span> <span class="n">selfadjointView</span><span class="o">&lt;</span><span class="n">Lower</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">scaledMat</span><span class="p">.</span><span class="n">diagonal</span><span class="p">().</span><span class="n">array</span><span class="p">()</span> <span class="o">-=</span> <span class="n">shift</span><span class="p">;</span>
    <span class="n">Scalar</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">scaledMat</span><span class="p">.</span><span class="n">cwiseAbs</span><span class="p">().</span><span class="n">maxCoeff</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">scaledMat</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">;</span>   <span class="c1">// TODO for scale==0 we could save the remaining operations</span>

    <span class="c1">// compute the eigenvalues</span>
    <span class="n">computeRoots</span><span class="p">(</span><span class="n">scaledMat</span><span class="p">,</span><span class="n">eivals</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h#L859">SelfAdjointEigenSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>855
856
857
858
859
860
861
862
863
864
865</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="c1">// apply the givens rotation to the unit matrix Q = Q * G</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">matrixQ</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// FIXME if StorageOrder == RowMajor this operation is not very efficient</span>
<span class="hll">      <span class="n">Map</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">StorageOrder</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">(</span><span class="n">matrixQ</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</span>      <span class="n">q</span><span class="p">.</span><span class="n">applyOnTheRight</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">rot</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace internal</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Geometry/Homogeneous.h#L270">Homogeneous.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>266
267
268
269
270
271
272
273
274
275
276
277</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kr">inline</span> <span class="n">Index</span> <span class="nf">cols</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_rhs</span><span class="p">.</span><span class="n">cols</span><span class="p">();</span> <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dest</span><span class="o">&gt;</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kt">void</span> <span class="n">evalTo</span><span class="p">(</span><span class="n">Dest</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME investigate how to allow lazy evaluation of this product when possible</span>
</span>    <span class="n">dst</span> <span class="o">=</span> <span class="n">Block</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">LhsMatrixTypeNested</span><span class="p">,</span>
              <span class="n">LhsMatrixTypeNested</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="p">,</span>
              <span class="n">LhsMatrixTypeNested</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="o">==</span><span class="n">Dynamic</span><span class="o">?</span><span class="nl">Dynamic</span><span class="p">:</span><span class="n">LhsMatrixTypeNested</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
            <span class="p">(</span><span class="n">m_lhs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">m_lhs</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="n">m_lhs</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m_rhs</span><span class="p">;</span>
    <span class="n">dst</span> <span class="o">+=</span> <span class="n">m_lhs</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">m_lhs</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">rowwise</span><span class="p">()</span>
            <span class="p">.</span><span class="k">template</span> <span class="n">replicate</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_rhs</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Geometry/Homogeneous.h#L308">Homogeneous.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>304
305
306
307
308
309
310
311
312
313
314
315</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kr">inline</span> <span class="n">Index</span> <span class="nf">cols</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_rhs</span><span class="p">.</span><span class="n">cols</span><span class="p">();</span> <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dest</span><span class="o">&gt;</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kt">void</span> <span class="n">evalTo</span><span class="p">(</span><span class="n">Dest</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME investigate how to allow lazy evaluation of this product when possible</span>
</span>    <span class="n">dst</span> <span class="o">=</span> <span class="n">m_lhs</span> <span class="o">*</span> <span class="n">Block</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RhsNested</span><span class="p">,</span>
                        <span class="n">RhsNested</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="o">==</span><span class="n">Dynamic</span><span class="o">?</span><span class="nl">Dynamic</span><span class="p">:</span><span class="n">RhsNested</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">RhsNested</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="o">&gt;</span>
            <span class="p">(</span><span class="n">m_rhs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">m_rhs</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m_rhs</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
    <span class="n">dst</span> <span class="o">+=</span> <span class="n">m_rhs</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">m_rhs</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">colwise</span><span class="p">()</span>
            <span class="p">.</span><span class="k">template</span> <span class="n">replicate</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_lhs</span><span class="p">.</span><span class="n">rows</span><span class="p">());</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Geometry/Homogeneous.h#L434">Homogeneous.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>430
431
432
433
434
435
436
437
438
439
440
441</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">homogeneous_left_product_impl</span><span class="o">&lt;</span><span class="n">Homogeneous</span><span class="o">&lt;</span><span class="n">RhsArg</span><span class="p">,</span><span class="n">Vertical</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Lhs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">nestedExpression</span><span class="p">()).</span><span class="n">evalTo</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="hll"><span class="c1">// TODO: the following specialization is to address a regression from 3.2 to 3.3</span>
</span><span class="c1">// In the future, this path should be optimized.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">RhsArg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ProductTag</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">generic_product_impl</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span> <span class="n">Homogeneous</span><span class="o">&lt;</span><span class="n">RhsArg</span><span class="p">,</span><span class="n">Vertical</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TriangularShape</span><span class="p">,</span> <span class="n">HomogeneousShape</span><span class="p">,</span> <span class="n">ProductTag</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dest</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">evalTo</span><span class="p">(</span><span class="n">Dest</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Lhs</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Homogeneous</span><span class="o">&lt;</span><span class="n">RhsArg</span><span class="p">,</span><span class="n">Vertical</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Geometry/Hyperplane.h#L122">Hyperplane.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>118
119
120
121
122
123
124
125
126
127
128
129</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="cm">/** Constructs a hyperplane passing through the parametrized line \a parametrized.</span>
<span class="cm">    * If the dimension of the ambient space is greater than 2, then there isn&#39;t uniqueness,</span>
<span class="cm">    * so an arbitrary choice is made.</span>
<span class="cm">    */</span>
<span class="hll">  <span class="c1">// FIXME to be consitent with the rest this could be implemented as a static Through function ??</span>
</span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="k">explicit</span> <span class="nf">Hyperplane</span><span class="p">(</span><span class="k">const</span> <span class="n">ParametrizedLine</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">AmbientDimAtCompileTime</span><span class="o">&gt;&amp;</span> <span class="n">parametrized</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">normal</span><span class="p">()</span> <span class="o">=</span> <span class="n">parametrized</span><span class="p">.</span><span class="n">direction</span><span class="p">().</span><span class="n">unitOrthogonal</span><span class="p">();</span>
    <span class="n">offset</span><span class="p">()</span> <span class="o">=</span> <span class="o">-</span><span class="n">parametrized</span><span class="p">.</span><span class="n">origin</span><span class="p">().</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="o">~</span><span class="n">Hyperplane</span><span class="p">()</span> <span class="p">{}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Geometry/Quaternion.h#L666">Quaternion.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>662
663
664
665
666
667
668
669
670
671
672
673</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  */
template &lt;class Derived&gt;
EIGEN_DEVICE_FUNC inline Quaternion&lt;typename internal::traits&lt;Derived&gt;::Scalar&gt; QuaternionBase&lt;Derived&gt;::inverse() const
{
<span class="hll">  // FIXME should this function be called multiplicativeInverse and conjugate() be called inverse() or opposite()  ??
</span>  Scalar n2 = this-&gt;squaredNorm();
  if (n2 &gt; Scalar(0))
    return Quaternion&lt;Scalar&gt;(conjugate().coeffs() / n2);
  else
  {
    // return an invalid result to flag the error
    return Quaternion&lt;Scalar&gt;(Coefficients::Zero());
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Geometry/Scaling.h#L71">Scaling.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>67
68
69
70
71
72
73
74
75
76
77
78</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/** Concatenates a uniform scaling and a linear transformation matrix */</span>
<span class="hll">  <span class="c1">// TODO returns an expression</span>
</span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="o">&gt;</span>
  <span class="kr">inline</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">plain_matrix_type</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;::</span><span class="n">type</span> <span class="k">operator</span><span class="o">*</span> <span class="p">(</span><span class="k">const</span> <span class="n">MatrixBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span> <span class="k">return</span> <span class="n">other</span> <span class="o">*</span> <span class="n">m_factor</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="p">,</span><span class="kt">int</span> <span class="n">Dim</span><span class="o">&gt;</span>
  <span class="kr">inline</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Dim</span><span class="p">,</span><span class="n">Dim</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">RotationBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="p">,</span><span class="n">Dim</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span> <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">toRotationMatrix</span><span class="p">()</span> <span class="o">*</span> <span class="n">m_factor</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Householder/BlockHouseholder.h#L66">BlockHouseholder.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>62
63
64
65
66
67
68
69
70
71
72</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">{</span>
      <span class="n">triFactor</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">rt</span><span class="p">).</span><span class="n">noalias</span><span class="p">()</span> <span class="o">=</span> <span class="o">-</span><span class="n">hCoeffs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">vectors</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">rs</span><span class="p">).</span><span class="n">adjoint</span><span class="p">()</span>
                                                        <span class="o">*</span> <span class="n">vectors</span><span class="p">.</span><span class="n">bottomRightCorner</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="n">rt</span><span class="p">).</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">UnitLower</span><span class="o">&gt;</span><span class="p">();</span>

<span class="hll">      <span class="c1">// FIXME add .noalias() once the triangular product can work inplace</span>
</span>      <span class="n">triFactor</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="o">=</span> <span class="n">triFactor</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="o">*</span> <span class="n">triFactor</span><span class="p">.</span><span class="n">bottomRightCorner</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span><span class="n">rt</span><span class="p">).</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Upper</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="p">}</span>
    <span class="n">triFactor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">hCoeffs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Householder/BlockHouseholder.h#L93">BlockHouseholder.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>89
90
91
92
93
94
95
96
97
98
99</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c1">// A -= V T V^* A</span>
  <span class="n">Matrix</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span><span class="p">,</span><span class="n">VectorsType</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="p">,</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="p">,</span>
         <span class="p">(</span><span class="n">VectorsType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span><span class="o">!=</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="nl">RowMajor</span><span class="p">:</span><span class="n">ColMajor</span><span class="p">,</span>
         <span class="n">VectorsType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span><span class="p">,</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">V</span><span class="p">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">mat</span><span class="p">;</span>
<span class="hll">  <span class="c1">// FIXME add .noalias() once the triangular product can work inplace</span>
</span>  <span class="k">if</span><span class="p">(</span><span class="n">forward</span><span class="p">)</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Upper</span><span class="o">&gt;</span><span class="p">()</span>           <span class="o">*</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">else</span>        <span class="n">tmp</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Upper</span><span class="o">&gt;</span><span class="p">().</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="n">mat</span><span class="p">.</span><span class="n">noalias</span><span class="p">()</span> <span class="o">-=</span> <span class="n">V</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace internal</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h#L249">IncompleteCholesky.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>245
246
247
248
249
250
251
252
253
254
255
256</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">m_scale</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">RealScalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">m_scale</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="nf">m_scale</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="hll">  <span class="c1">// TODO disable scaling if not needed, i.e., if it is roughly uniform? (this will make solve() faster)</span>
</span>
  <span class="c1">// Scale and compute the shift for the matrix</span>
  <span class="n">RealScalar</span> <span class="n">mindiag</span> <span class="o">=</span> <span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">RealScalar</span><span class="o">&gt;::</span><span class="n">highest</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">k</span> <span class="o">=</span> <span class="n">colPtr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">colPtr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
      <span class="n">vals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">m_scale</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">m_scale</span><span class="p">(</span><span class="n">rowIdx</span><span class="p">[</span><span class="n">k</span><span class="p">]));</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h#L232">IncompleteLUT.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>228
229
230
231
232
233
234
235
236
237
238
239</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#ifndef EIGEN_MPL2_ONLY</span>
  <span class="c1">// To this end, let&#39;s symmetrize the pattern and perform AMD on it.</span>
  <span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">ColMajor</span><span class="p">,</span> <span class="n">StorageIndex</span><span class="o">&gt;</span> <span class="n">mat1</span> <span class="o">=</span> <span class="n">amat</span><span class="p">;</span>
  <span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">ColMajor</span><span class="p">,</span> <span class="n">StorageIndex</span><span class="o">&gt;</span> <span class="n">mat2</span> <span class="o">=</span> <span class="n">amat</span><span class="p">.</span><span class="n">transpose</span><span class="p">();</span>
<span class="hll">  <span class="c1">// FIXME for a matrix with nearly symmetric pattern, mat2+mat1 is the appropriate choice.</span>
</span>  <span class="c1">//       on the other hand for a really non-symmetric pattern, mat2*mat1 should be prefered...</span>
  <span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">ColMajor</span><span class="p">,</span> <span class="n">StorageIndex</span><span class="o">&gt;</span> <span class="n">AtA</span> <span class="o">=</span> <span class="n">mat2</span> <span class="o">+</span> <span class="n">mat1</span><span class="p">;</span>
  <span class="n">AMDOrdering</span><span class="o">&lt;</span><span class="n">StorageIndex</span><span class="o">&gt;</span> <span class="n">ordering</span><span class="p">;</span>
  <span class="n">ordering</span><span class="p">(</span><span class="n">AtA</span><span class="p">,</span><span class="n">m_P</span><span class="p">);</span>
  <span class="n">m_Pinv</span>  <span class="o">=</span> <span class="n">m_P</span><span class="p">.</span><span class="n">inverse</span><span class="p">();</span> <span class="c1">// cache the inverse permutation</span>
<span class="cp">#else</span>
  <span class="c1">// If AMD is not available, (MPL2-only), then let&#39;s use the slower COLAMD routine.</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/LU/FullPivLU.h#L67">FullPivLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>63
64
65
66
67
68
69
70
71
72
73
74</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">typedef</span> <span class="n">_MatrixType</span> <span class="n">MatrixType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">SolverBase</span><span class="o">&lt;</span><span class="n">FullPivLU</span><span class="o">&gt;</span> <span class="n">Base</span><span class="p">;</span>

    <span class="n">EIGEN_GENERIC_PUBLIC_INTERFACE</span><span class="p">(</span><span class="n">FullPivLU</span><span class="p">)</span>
<span class="hll">    <span class="c1">// FIXME StorageIndex defined in EIGEN_GENERIC_PUBLIC_INTERFACE should be int</span>
</span>    <span class="k">enum</span> <span class="p">{</span>
      <span class="n">MaxRowsAtCompileTime</span> <span class="o">=</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">MaxRowsAtCompileTime</span><span class="p">,</span>
      <span class="n">MaxColsAtCompileTime</span> <span class="o">=</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">plain_row_type</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span> <span class="n">StorageIndex</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">IntRowVectorType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">plain_col_type</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span> <span class="n">StorageIndex</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">IntColVectorType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">PermutationMatrix</span><span class="o">&lt;</span><span class="n">ColsAtCompileTime</span><span class="p">,</span> <span class="n">MaxColsAtCompileTime</span><span class="o">&gt;</span> <span class="n">PermutationQType</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/LU/FullPivLU.h#L240">FullPivLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>236
237
238
239
240
241
242
243
244
245
246
247</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      * Output: \verbinclude FullPivLU_solve.out
      *
      * \sa TriangularView::solve(), kernel(), inverse()
      */
<span class="hll">    // FIXME this is a copy-paste of the base-class member to add the isInitialized assertion.
</span>    template&lt;typename Rhs&gt;
    inline const Solve&lt;FullPivLU, Rhs&gt;
    solve(const MatrixBase&lt;Rhs&gt;&amp; b) const
    {
      eigen_assert(m_isInitialized &amp;&amp; &quot;LU is not initialized.&quot;);
      return Solve&lt;FullPivLU, Rhs&gt;(*this, b.derived());
    }
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/LU/FullPivLU.h#L600">FullPivLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>596
597
598
599
600
601
602
603
604
605
606
607</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">eigen_assert</span><span class="p">(</span><span class="n">m_isInitialized</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;LU is not initialized.&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">Index</span> <span class="n">smalldim</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">)(</span><span class="n">m_lu</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span> <span class="n">m_lu</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
  <span class="c1">// LU</span>
  <span class="n">MatrixType</span> <span class="nf">res</span><span class="p">(</span><span class="n">m_lu</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="n">m_lu</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
<span class="hll">  <span class="c1">// FIXME the .toDenseMatrix() should not be needed...</span>
</span>  <span class="n">res</span> <span class="o">=</span> <span class="n">m_lu</span><span class="p">.</span><span class="n">leftCols</span><span class="p">(</span><span class="n">smalldim</span><span class="p">)</span>
            <span class="p">.</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">UnitLower</span><span class="o">&gt;</span><span class="p">().</span><span class="n">toDenseMatrix</span><span class="p">()</span>
      <span class="o">*</span> <span class="n">m_lu</span><span class="p">.</span><span class="n">topRows</span><span class="p">(</span><span class="n">smalldim</span><span class="p">)</span>
            <span class="p">.</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Upper</span><span class="o">&gt;</span><span class="p">().</span><span class="n">toDenseMatrix</span><span class="p">();</span>

  <span class="c1">// P^{-1}(LU)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">m_p</span><span class="p">.</span><span class="n">inverse</span><span class="p">()</span> <span class="o">*</span> <span class="n">res</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/LU/FullPivLU.h#L669">FullPivLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>665
666
667
668
669
670
671
672
673
674
675</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="c1">// we construct a temporaty trapezoid matrix m, by taking the U matrix and</span>
    <span class="c1">// permuting the rows and cols to bring the nonnegligible pivots to the top of</span>
    <span class="c1">// the main diagonal. We need that to be able to apply our triangular solvers.</span>
    <span class="c1">// FIXME when we get triangularView-for-rectangular-matrices, this can be simplified</span>
<span class="hll">    <span class="n">Matrix</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Options</span><span class="p">,</span>
</span>           <span class="n">MaxSmallDimAtCompileTime</span><span class="p">,</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span><span class="o">&gt;</span>
      <span class="n">m</span><span class="p">(</span><span class="n">dec</span><span class="p">().</span><span class="n">matrixLU</span><span class="p">().</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rank</span><span class="p">(),</span> <span class="n">cols</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="n">Index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">m</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">head</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">setZero</span><span class="p">();</span>
      <span class="n">m</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">cols</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">dec</span><span class="p">().</span><span class="n">matrixLU</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="n">pivots</span><span class="p">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">i</span><span class="p">)).</span><span class="n">tail</span><span class="p">(</span><span class="n">cols</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/LU/PartialPivLU.h#L83">PartialPivLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>79
80
81
82
83
84
85
86
87
88
89</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">typedef</span> <span class="n">_MatrixType</span> <span class="n">MatrixType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">SolverBase</span><span class="o">&lt;</span><span class="n">PartialPivLU</span><span class="o">&gt;</span> <span class="n">Base</span><span class="p">;</span>
    <span class="n">EIGEN_GENERIC_PUBLIC_INTERFACE</span><span class="p">(</span><span class="n">PartialPivLU</span><span class="p">)</span>
    <span class="c1">// FIXME StorageIndex defined in EIGEN_GENERIC_PUBLIC_INTERFACE should be int</span>
<span class="hll">    <span class="k">enum</span> <span class="p">{</span>
</span>      <span class="n">MaxRowsAtCompileTime</span> <span class="o">=</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">MaxRowsAtCompileTime</span><span class="p">,</span>
      <span class="n">MaxColsAtCompileTime</span> <span class="o">=</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="n">PermutationMatrix</span><span class="o">&lt;</span><span class="n">RowsAtCompileTime</span><span class="p">,</span> <span class="n">MaxRowsAtCompileTime</span><span class="o">&gt;</span> <span class="n">PermutationType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Transpositions</span><span class="o">&lt;</span><span class="n">RowsAtCompileTime</span><span class="p">,</span> <span class="n">MaxRowsAtCompileTime</span><span class="o">&gt;</span> <span class="n">TranspositionType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">PlainObject</span> <span class="n">PlainObject</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/LU/PartialPivLU.h#L172">PartialPivLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>168
169
170
171
172
173
174
175
176
177
178
179</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      * theoretically exists and is unique regardless of b.
      *
      * \sa TriangularView::solve(), inverse(), computeInverse()
      */
<span class="hll">    // FIXME this is a copy-paste of the base-class member to add the isInitialized assertion.
</span>    template&lt;typename Rhs&gt;
    inline const Solve&lt;PartialPivLU, Rhs&gt;
    solve(const MatrixBase&lt;Rhs&gt;&amp; b) const
    {
      eigen_assert(m_isInitialized &amp;&amp; &quot;PartialPivLU is not initialized.&quot;);
      return Solve&lt;PartialPivLU, Rhs&gt;(*this, b.derived());
    }
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/LU/PartialPivLU.h#L345">PartialPivLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>341
342
343
344
345
346
347
348
349
350
351
352</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/** \internal This is the blocked version of fullpivlu_unblocked() */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">int</span> <span class="n">StorageOrder</span><span class="p">,</span> <span class="k">typename</span> <span class="n">PivIndex</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">partial_lu_impl</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// FIXME add a stride to Map, so that the following mapping becomes easier,</span>
</span>  <span class="c1">// another option would be to create an expression being able to automatically</span>
  <span class="c1">// warp any Map, Matrix, and Block expressions as a unique type, but since that&#39;s exactly</span>
  <span class="c1">// a Map + stride, why not adding a stride to Map, and convenient ctors from a Matrix,</span>
  <span class="c1">// and Block.</span>
  <span class="k">typedef</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">StorageOrder</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">MapLU</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Block</span><span class="o">&lt;</span><span class="n">MapLU</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Dynamic</span><span class="o">&gt;</span> <span class="n">MatrixType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Block</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Dynamic</span><span class="o">&gt;</span> <span class="n">BlockType</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/LU/PartialPivLU.h#L394">PartialPivLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>390
391
392
393
394
395
396
397
398
399
400
401</pre></div></td><td class="code"><div class="highlight"><pre><span></span>          <span class="n">lu</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="n">lu</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">row_of_biggest_in_col</span><span class="p">));</span>
          <span class="o">++</span><span class="n">nb_transpositions</span><span class="p">;</span>
        <span class="p">}</span>

<span class="hll">        <span class="c1">// FIXME shall we introduce a safe quotient expression in cas 1/lu.coeff(k,k)</span>
</span>        <span class="c1">// overflow but not the actual quotient?</span>
        <span class="n">lu</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">rrows</span><span class="p">)</span> <span class="o">/=</span> <span class="n">lu</span><span class="p">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">first_zero_pivot</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="c1">// the pivot is exactly zero, we record the index of the first pivot which is exactly 0,</span>
        <span class="c1">// and continue the factorization such we still have A = PLU</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/MetisSupport/MetisSupport.h#L116">MetisSupport.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>112
113
114
115
116
117
118
119
120
121
122
123</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">output_error</span> <span class="o">=</span> <span class="n">METIS_NodeND</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">m_indexPtr</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">m_innerIndices</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">perm</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">iperm</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

    <span class="k">if</span><span class="p">(</span><span class="n">output_error</span> <span class="o">!=</span> <span class="n">METIS_OK</span><span class="p">)</span>
    <span class="p">{</span>
<span class="hll">      <span class="c1">//FIXME The ordering interface should define a class of possible errors</span>
</span>     <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ERROR WHILE CALLING THE METIS PACKAGE </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
     <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Get the fill-reducing permutation</span>
    <span class="c1">//NOTE:  If Ap is the permuted matrix then perm and iperm vectors are defined as follows</span>
    <span class="c1">// Row (column) i of Ap is the perm(i) row(column) of A, and row (column) i of A is the iperm(i) row(column) of Ap</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/OrderingMethods/Ordering.h#L24">Ordering.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/** \internal</span>
<span class="cm">  * \ingroup OrderingMethods_Module</span>
<span class="cm">  * \param[in] A the input non-symmetric matrix</span>
<span class="cm">  * \param[out] symmat the symmetric pattern A^T+A from the input matrix \a A.</span>
<span class="hll"><span class="cm">  * FIXME: The values should not be considered here</span>
</span><span class="cm">  */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ordering_helper_at_plus_a</span><span class="p">(</span><span class="k">const</span> <span class="n">MatrixType</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="n">MatrixType</span><span class="o">&amp;</span> <span class="n">symmat</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">MatrixType</span> <span class="n">C</span><span class="p">;</span>
  <span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">transpose</span><span class="p">();</span> <span class="c1">// NOTE: Could be  costly</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">C</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/QR/ColPivHouseholderQR.h#L61">ColPivHouseholderQR.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>57
58
59
60
61
62
63
64
65
66
67
68</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">MaxColsAtCompileTime</span> <span class="o">=</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">RealScalar</span> <span class="n">RealScalar</span><span class="p">;</span>
<span class="hll">    <span class="c1">// FIXME should be int</span>
</span>    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">StorageIndex</span> <span class="n">StorageIndex</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">plain_diag_type</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">HCoeffsType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">PermutationMatrix</span><span class="o">&lt;</span><span class="n">ColsAtCompileTime</span><span class="p">,</span> <span class="n">MaxColsAtCompileTime</span><span class="o">&gt;</span> <span class="n">PermutationType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">plain_row_type</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span> <span class="n">Index</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">IntRowVectorType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">plain_row_type</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">RowVectorType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">plain_row_type</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span> <span class="n">RealScalar</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">RealRowVectorType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">HouseholderSequence</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span><span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">remove_all</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">HCoeffsType</span><span class="o">::</span><span class="n">ConjugateReturnType</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">HouseholderSequenceType</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/QR/FullPivHouseholderQR.h#L70">FullPivHouseholderQR.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>66
67
68
69
70
71
72
73
74
75
76
77</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">MaxColsAtCompileTime</span> <span class="o">=</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">RealScalar</span> <span class="n">RealScalar</span><span class="p">;</span>
<span class="hll">    <span class="c1">// FIXME should be int</span>
</span>    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">StorageIndex</span> <span class="n">StorageIndex</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">FullPivHouseholderQRMatrixQReturnType</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;</span> <span class="n">MatrixQReturnType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">plain_diag_type</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">HCoeffsType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">StorageIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                   <span class="n">EIGEN_SIZE_MIN_PREFER_DYNAMIC</span><span class="p">(</span><span class="n">ColsAtCompileTime</span><span class="p">,</span><span class="n">RowsAtCompileTime</span><span class="p">),</span> <span class="n">RowMajor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                   <span class="n">EIGEN_SIZE_MIN_PREFER_FIXED</span><span class="p">(</span><span class="n">MaxColsAtCompileTime</span><span class="p">,</span><span class="n">MaxRowsAtCompileTime</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">IntDiagSizeVectorType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">PermutationMatrix</span><span class="o">&lt;</span><span class="n">ColsAtCompileTime</span><span class="p">,</span> <span class="n">MaxColsAtCompileTime</span><span class="o">&gt;</span> <span class="n">PermutationType</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/QR/FullPivHouseholderQR.h#L547">FullPivHouseholderQR.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>543
544
545
546
547
548
549
550
551
552
553</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="n">eigen_assert</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span> <span class="o">==</span> <span class="n">rows</span><span class="p">());</span>
  <span class="k">const</span> <span class="n">Index</span> <span class="n">l_rank</span> <span class="o">=</span> <span class="n">rank</span><span class="p">();</span>

<span class="hll">  <span class="c1">// FIXME introduce nonzeroPivots() and use it here. and more generally,</span>
</span>  <span class="c1">// make the same improvements in this dec as in FullPivLU.</span>
  <span class="k">if</span><span class="p">(</span><span class="n">l_rank</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">dst</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/QR/HouseholderQR.h#L57">HouseholderQR.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>53
54
55
56
57
58
59
60
61
62
63
64</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">MaxColsAtCompileTime</span> <span class="o">=</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">MaxColsAtCompileTime</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">RealScalar</span> <span class="n">RealScalar</span><span class="p">;</span>
<span class="hll">    <span class="c1">// FIXME should be int</span>
</span>    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">StorageIndex</span> <span class="n">StorageIndex</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">RowsAtCompileTime</span><span class="p">,</span> <span class="n">RowsAtCompileTime</span><span class="p">,</span> <span class="p">(</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">Flags</span><span class="o">&amp;</span><span class="n">RowMajorBit</span><span class="p">)</span> <span class="o">?</span> <span class="nl">RowMajor</span> <span class="p">:</span> <span class="n">ColMajor</span><span class="p">,</span> <span class="n">MaxRowsAtCompileTime</span><span class="p">,</span> <span class="n">MaxRowsAtCompileTime</span><span class="o">&gt;</span> <span class="n">MatrixQType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">plain_diag_type</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">HCoeffsType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">plain_row_type</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">RowVectorType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">HouseholderSequence</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span><span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">remove_all</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">HCoeffsType</span><span class="o">::</span><span class="n">ConjugateReturnType</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">HouseholderSequenceType</span><span class="p">;</span>

    <span class="cm">/**</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SVD/BDCSVD.h#L251">BDCSVD.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>247
248
249
250
251
252
253
254
255
256
257</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c1">//**** step -1 - If the problem is too small, directly falls back to JacobiSVD and return</span>
  <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">m_algoswap</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// FIXME this line involves temporaries</span>
<span class="hll">    <span class="n">JacobiSVD</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;</span> <span class="n">jsvd</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span><span class="n">computationOptions</span><span class="p">);</span>
</span>    <span class="k">if</span><span class="p">(</span><span class="n">computeU</span><span class="p">())</span> <span class="n">m_matrixU</span> <span class="o">=</span> <span class="n">jsvd</span><span class="p">.</span><span class="n">matrixU</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">computeV</span><span class="p">())</span> <span class="n">m_matrixV</span> <span class="o">=</span> <span class="n">jsvd</span><span class="p">.</span><span class="n">matrixV</span><span class="p">();</span>
    <span class="n">m_singularValues</span> <span class="o">=</span> <span class="n">jsvd</span><span class="p">.</span><span class="n">singularValues</span><span class="p">();</span>
    <span class="n">m_nonzeroSingularValues</span> <span class="o">=</span> <span class="n">jsvd</span><span class="p">.</span><span class="n">nonzeroSingularValues</span><span class="p">();</span>
    <span class="n">m_isInitialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SVD/BDCSVD.h#L269">BDCSVD.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>265
266
267
268
269
270
271
272
273
274
275
276</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">m_isTranspose</span><span class="p">)</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">adjoint</span><span class="p">()</span><span class="o">/</span><span class="n">scale</span><span class="p">;</span>
  <span class="k">else</span>               <span class="n">copy</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">/</span><span class="n">scale</span><span class="p">;</span>

  <span class="c1">//**** step 1 - Bidiagonalization</span>
<span class="hll">  <span class="c1">// FIXME this line involves temporaries</span>
</span>  <span class="n">internal</span><span class="o">::</span><span class="n">UpperBidiagonalization</span><span class="o">&lt;</span><span class="n">MatrixX</span><span class="o">&gt;</span> <span class="n">bid</span><span class="p">(</span><span class="n">copy</span><span class="p">);</span>

  <span class="c1">//**** step 2 - Divide &amp; Conquer</span>
  <span class="n">m_naiveU</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span>
  <span class="n">m_naiveV</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span>
  <span class="c1">// FIXME this line involves a temporary matrix</span>
  <span class="n">m_computed</span><span class="p">.</span><span class="n">topRows</span><span class="p">(</span><span class="n">m_diagSize</span><span class="p">)</span> <span class="o">=</span> <span class="n">bid</span><span class="p">.</span><span class="n">bidiagonal</span><span class="p">().</span><span class="n">toDenseMatrix</span><span class="p">().</span><span class="n">transpose</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SVD/BDCSVD.h#L275">BDCSVD.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>271
272
273
274
275
276
277
278
279
280
281</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c1">//**** step 2 - Divide &amp; Conquer</span>
  <span class="n">m_naiveU</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span>
  <span class="n">m_naiveV</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span>
  <span class="c1">// FIXME this line involves a temporary matrix</span>
<span class="hll">  <span class="n">m_computed</span><span class="p">.</span><span class="n">topRows</span><span class="p">(</span><span class="n">m_diagSize</span><span class="p">)</span> <span class="o">=</span> <span class="n">bid</span><span class="p">.</span><span class="n">bidiagonal</span><span class="p">().</span><span class="n">toDenseMatrix</span><span class="p">().</span><span class="n">transpose</span><span class="p">();</span>
</span>  <span class="n">m_computed</span><span class="p">.</span><span class="k">template</span> <span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">().</span><span class="n">setZero</span><span class="p">();</span>
  <span class="n">divide</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m_diagSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">//**** step 3 - Copy singular values and vectors</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m_diagSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SVD/BDCSVD.h#L409">BDCSVD.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>405
406
407
408
409
410
411
412
413
414
415
416</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c1">// We use the other algorithm which is more efficient for small</span>
  <span class="c1">// matrices.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">m_algoswap</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME this line involves temporaries</span>
</span>    <span class="n">JacobiSVD</span><span class="o">&lt;</span><span class="n">MatrixXr</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="n">m_computed</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="n">firstCol</span><span class="p">,</span> <span class="n">firstCol</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">ComputeFullU</span> <span class="o">|</span> <span class="p">(</span><span class="n">m_compV</span> <span class="o">?</span> <span class="nl">ComputeFullV</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_compU</span><span class="p">)</span>
      <span class="n">m_naiveU</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="n">firstCol</span><span class="p">,</span> <span class="n">firstCol</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="n">real</span><span class="p">()</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">matrixU</span><span class="p">();</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">m_naiveU</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">segment</span><span class="p">(</span><span class="n">firstCol</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="n">real</span><span class="p">()</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">matrixU</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">m_naiveU</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">segment</span><span class="p">(</span><span class="n">firstCol</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="n">real</span><span class="p">()</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">matrixU</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SVD/BDCSVD.h#L567">BDCSVD.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>563
564
565
566
567
568
569
570
571
572
573
574</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// the first column and on the diagonal and has undergone deflation, so diagonal is in increasing</span>
<span class="c1">// order except for possibly the (0,0) entry. The computed SVD is stored U, singVals and V, except</span>
<span class="c1">// that if m_compV is false, then V is not computed. Singular values are sorted in decreasing order.</span>
<span class="c1">//</span>
<span class="hll"><span class="c1">// TODO Opportunities for optimization: better root finding algo, better stopping criterion, better</span>
</span><span class="c1">// handling of round-off errors, be consistent in ordering</span>
<span class="c1">// For instance, to solve the secular equation using FMM, see http://www.stat.uchicago.edu/~lekheng/courses/302/classics/greengard-rokhlin.pdf</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">BDCSVD</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">computeSVDofM</span><span class="p">(</span><span class="n">Index</span> <span class="n">firstCol</span><span class="p">,</span> <span class="n">Index</span> <span class="n">n</span><span class="p">,</span> <span class="n">MatrixXr</span><span class="o">&amp;</span> <span class="n">U</span><span class="p">,</span> <span class="n">VectorType</span><span class="o">&amp;</span> <span class="n">singVals</span><span class="p">,</span> <span class="n">MatrixXr</span><span class="o">&amp;</span> <span class="n">V</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="n">RealScalar</span> <span class="n">considerZero</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">RealScalar</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">)();</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SVD/BDCSVD.h#L1017">BDCSVD.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1013
1014
1015
1016
1017
1018
1019
1020
1021
1022
1023</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// page 13</span>
<span class="c1">// i,j &gt;= 1, i!=j and |di - dj| &lt; epsilon * norm2(M)</span>
<span class="c1">// We apply two rotations to have zj = 0;</span>
<span class="c1">// TODO deflation44 is still broken and not properly tested</span>
<span class="hll"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">&gt;</span>
</span><span class="kt">void</span> <span class="n">BDCSVD</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">deflation44</span><span class="p">(</span><span class="n">Index</span> <span class="n">firstColu</span> <span class="p">,</span> <span class="n">Index</span> <span class="n">firstColm</span><span class="p">,</span> <span class="n">Index</span> <span class="n">firstRowW</span><span class="p">,</span> <span class="n">Index</span> <span class="n">firstColW</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">,</span> <span class="n">Index</span> <span class="n">j</span><span class="p">,</span> <span class="n">Index</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">conj</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/AmbiVector.h#L193">AmbiVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>189
190
191
192
193
194
195
196
197
198
199
200</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="n">m_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">ListEl</span><span class="o">*</span> <span class="n">EIGEN_RESTRICT</span> <span class="n">llElements</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">ListEl</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">m_buffer</span><span class="p">);</span>
<span class="hll">    <span class="c1">// TODO factorize the following code to reduce code generation</span>
</span>    <span class="n">eigen_assert</span><span class="p">(</span><span class="n">m_mode</span><span class="o">==</span><span class="n">IsSparse</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_llSize</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// this is the first element</span>
      <span class="n">m_llStart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">m_llCurrent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="o">++</span><span class="n">m_llSize</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h#L89">ConservativeSparseSparseProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>85
86
87
88
89
90
91
92
93
94
95
96</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="c1">// alternative ordered insertion code:</span>
      <span class="k">const</span> <span class="n">Index</span> <span class="n">t200</span> <span class="o">=</span> <span class="n">rows</span><span class="o">/</span><span class="mi">11</span><span class="p">;</span> <span class="c1">// 11 == (log2(200)*1.39)</span>
      <span class="k">const</span> <span class="n">Index</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="mi">139</span><span class="p">;</span>

<span class="hll">      <span class="c1">// FIXME reserve nnz non zeros</span>
</span>      <span class="c1">// FIXME implement faster sorting algorithms for very small nnz</span>
      <span class="c1">// if the result is sparse enough =&gt; use a quick sort</span>
      <span class="c1">// otherwise =&gt; loop through the entire vector</span>
      <span class="c1">// In order to avoid to perform an expensive log2 when the</span>
      <span class="c1">// result is clearly very sparse we use a linear bound up to 200.</span>
      <span class="k">if</span><span class="p">((</span><span class="n">nnz</span><span class="o">&lt;</span><span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="n">nnz</span><span class="o">&lt;</span><span class="n">t200</span><span class="p">)</span> <span class="o">||</span> <span class="n">nnz</span> <span class="o">*</span> <span class="n">numext</span><span class="o">::</span><span class="n">log2</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">nnz</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span>
      <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h#L90">ConservativeSparseSparseProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>86
87
88
89
90
91
92
93
94
95
96
97</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="k">const</span> <span class="n">Index</span> <span class="n">t200</span> <span class="o">=</span> <span class="n">rows</span><span class="o">/</span><span class="mi">11</span><span class="p">;</span> <span class="c1">// 11 == (log2(200)*1.39)</span>
      <span class="k">const</span> <span class="n">Index</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="mi">139</span><span class="p">;</span>

      <span class="c1">// FIXME reserve nnz non zeros</span>
<span class="hll">      <span class="c1">// FIXME implement faster sorting algorithms for very small nnz</span>
</span>      <span class="c1">// if the result is sparse enough =&gt; use a quick sort</span>
      <span class="c1">// otherwise =&gt; loop through the entire vector</span>
      <span class="c1">// In order to avoid to perform an expensive log2 when the</span>
      <span class="c1">// result is clearly very sparse we use a linear bound up to 200.</span>
      <span class="k">if</span><span class="p">((</span><span class="n">nnz</span><span class="o">&lt;</span><span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="n">nnz</span><span class="o">&lt;</span><span class="n">t200</span><span class="p">)</span> <span class="o">||</span> <span class="n">nnz</span> <span class="o">*</span> <span class="n">numext</span><span class="o">::</span><span class="n">log2</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">nnz</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">nnz</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="n">indices</span><span class="o">+</span><span class="n">nnz</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h#L147">ConservativeSparseSparseProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>143
144
145
146
147
148
149
150
151
152
153
154</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">sparse_eval</span><span class="o">&lt;</span><span class="n">ColMajorMatrixAux</span><span class="p">,</span><span class="n">ResultType</span><span class="o">::</span><span class="n">RowsAtCompileTime</span><span class="p">,</span><span class="n">ResultType</span><span class="o">::</span><span class="n">ColsAtCompileTime</span><span class="p">,</span><span class="n">ColMajorMatrixAux</span><span class="o">::</span><span class="n">Flags</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">ColMajorMatrix</span><span class="p">;</span>

    <span class="c1">// If the result is tall and thin (in the extreme case a column vector)</span>
    <span class="c1">// then it is faster to sort the coefficients inplace instead of transposing twice.</span>
<span class="hll">    <span class="c1">// FIXME, the following heuristic is probably not very good.</span>
</span>    <span class="k">if</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span><span class="o">&gt;</span><span class="n">rhs</span><span class="p">.</span><span class="n">cols</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">ColMajorMatrix</span> <span class="n">resCol</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="n">rhs</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
      <span class="c1">// perform sorted insertion</span>
      <span class="n">internal</span><span class="o">::</span><span class="n">conservative_sparse_sparse_product_impl</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span><span class="n">Rhs</span><span class="p">,</span><span class="n">ColMajorMatrix</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">resCol</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
      <span class="n">res</span> <span class="o">=</span> <span class="n">resCol</span><span class="p">.</span><span class="n">markAsRValue</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseAssign.h#L27">SparseAssign.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherDerived</span><span class="o">&gt;</span>
<span class="n">Derived</span><span class="o">&amp;</span> <span class="n">SparseMatrixBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ReturnByValue</span><span class="o">&lt;</span><span class="n">OtherDerived</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO use the evaluator mechanism</span>
</span>  <span class="n">other</span><span class="p">.</span><span class="n">evalTo</span><span class="p">(</span><span class="n">derived</span><span class="p">());</span>
  <span class="k">return</span> <span class="nf">derived</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherDerived</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">SparseMatrixBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseMatrixBase</span><span class="o">&lt;</span><span class="n">OtherDerived</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseCwiseBinaryOp.h#L32">SparseCwiseBinaryOp.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">//                         generic      sparse</span>
<span class="c1">//  4 - dense op dense     product      dense</span>
<span class="c1">//                         generic      dense</span>
<span class="c1">//</span>
<span class="hll"><span class="c1">// TODO to ease compiler job, we could specialize product/quotient with a scalar</span>
</span><span class="c1">//      and fallback to cwise-unary evaluator using bind1st_op and bind2nd_op.</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOp</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">CwiseBinaryOpImpl</span><span class="o">&lt;</span><span class="n">BinaryOp</span><span class="p">,</span> <span class="n">Lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="p">,</span> <span class="n">Sparse</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">SparseMatrixBase</span><span class="o">&lt;</span><span class="n">CwiseBinaryOp</span><span class="o">&lt;</span><span class="n">BinaryOp</span><span class="p">,</span> <span class="n">Lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseDenseProduct.h#L74">SparseDenseProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>70
71
72
73
74
75
76
77
78
79
80
81</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>

<span class="p">};</span>

<span class="hll"><span class="c1">// FIXME: what is the purpose of the following specialization? Is it for the BlockedSparse format?</span>
</span><span class="c1">// -&gt; let&#39;s disable it for now as it is conflicting with generic scalar*matrix and matrix*scalar operators</span>
<span class="c1">// template&lt;typename T1, typename T2/*, int _Options, typename _StrideType*/&gt;</span>
<span class="c1">// struct ScalarBinaryOpTraits&lt;T1, Ref&lt;T2/*, _Options, _StrideType*/&gt; &gt;</span>
<span class="c1">// {</span>
<span class="c1">//   enum {</span>
<span class="c1">//     Defined = 1</span>
<span class="c1">//   };</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseMatrix.h#L522">SparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>518
519
520
521
522
523
524
525
526
527
528
529</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      */
    template&lt;typename KeepFunc&gt;
    void prune(const KeepFunc&amp; keep = KeepFunc())
    {
<span class="hll">      // TODO optimize the uncompressed mode to avoid moving and allocating the data twice
</span>      makeCompressed();

      StorageIndex k = 0;
      for(Index j=0; j&lt;m_outerSize; ++j)
      {
        Index previousStart = m_outerIndex[j];
        m_outerIndex[j] = k;
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseMatrix.h#L1020">SparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1016
1017
1018
1019
1020
1021
1022
1023
1024
1025
1026
1027</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DupFunctor</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">_Options</span><span class="p">,</span><span class="n">_StorageIndex</span><span class="o">&gt;::</span><span class="n">collapseDuplicates</span><span class="p">(</span><span class="n">DupFunctor</span> <span class="n">dup_func</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">eigen_assert</span><span class="p">(</span><span class="o">!</span><span class="n">isCompressed</span><span class="p">());</span>
<span class="hll">  <span class="c1">// TODO, in practice we should be able to use m_innerNonZeros for that task</span>
</span>  <span class="n">IndexVector</span> <span class="nf">wi</span><span class="p">(</span><span class="n">innerSize</span><span class="p">());</span>
  <span class="n">wi</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">StorageIndex</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// for each inner-vector, wi[inner_index] will hold the position of first element into the index/value buffers</span>
  <span class="k">for</span><span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">outerSize</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">StorageIndex</span> <span class="n">start</span>   <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseMatrix.h#L1086">SparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1082
1083
1084
1085
1086
1087
1088
1089
1090
1091
1092
1093</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">SparseMatrix</span> <span class="nf">dest</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">IndexVector</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">dest</span><span class="p">.</span><span class="n">m_outerIndex</span><span class="p">,</span><span class="n">dest</span><span class="p">.</span><span class="n">outerSize</span><span class="p">()).</span><span class="n">setZero</span><span class="p">();</span>

    <span class="c1">// pass 1</span>
<span class="hll">    <span class="c1">// FIXME the above copy could be merged with that pass</span>
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">otherCopy</span><span class="p">.</span><span class="n">outerSize</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">typename</span> <span class="n">OtherCopyEval</span><span class="o">::</span><span class="n">InnerIterator</span> <span class="n">it</span><span class="p">(</span><span class="n">otherCopyEval</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="n">it</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="o">++</span><span class="n">dest</span><span class="p">.</span><span class="n">m_outerIndex</span><span class="p">[</span><span class="n">it</span><span class="p">.</span><span class="n">index</span><span class="p">()];</span>

    <span class="c1">// prefix sum</span>
    <span class="n">StorageIndex</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">IndexVector</span> <span class="nf">positions</span><span class="p">(</span><span class="n">dest</span><span class="p">.</span><span class="n">outerSize</span><span class="p">());</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseMatrix.h#L1307">SparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
1313
1314</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="kt">bool</span> <span class="n">isLastVec</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">previousOuter</span><span class="o">==-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">m_data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span><span class="p">))</span>
                <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">(</span><span class="n">m_outerIndex</span><span class="p">[</span><span class="n">outer</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">m_data</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">startId</span> <span class="o">=</span> <span class="n">m_outerIndex</span><span class="p">[</span><span class="n">outer</span><span class="p">];</span>
<span class="hll">  <span class="c1">// FIXME let&#39;s make sure sizeof(long int) == sizeof(std::size_t)</span>
</span>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">m_outerIndex</span><span class="p">[</span><span class="n">outer</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
  <span class="o">++</span><span class="n">m_outerIndex</span><span class="p">[</span><span class="n">outer</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

  <span class="kt">double</span> <span class="n">reallocRatio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m_data</span><span class="p">.</span><span class="n">allocatedSize</span><span class="p">()</span><span class="o">&lt;=</span><span class="n">m_data</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// if there is no preallocated memory, let&#39;s reserve a minimum of 32 elements</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseMatrixBase.h#L113">SparseMatrixBase.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>109
110
111
112
113
114
115
116
117
118
119
120</pre></div></td><td class="code"><div class="highlight"><pre><span></span>                     <span class="o">&gt;::</span><span class="n">type</span> <span class="n">AdjointReturnType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Transpose</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span> <span class="n">TransposeReturnType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">add_const</span><span class="o">&lt;</span><span class="n">Transpose</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Derived</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="n">ConstTransposeReturnType</span><span class="p">;</span>

<span class="hll">    <span class="c1">// FIXME storage order do not match evaluator storage order</span>
</span>    <span class="k">typedef</span> <span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Flags</span><span class="o">&amp;</span><span class="n">RowMajorBit</span> <span class="o">?</span> <span class="nl">RowMajor</span> <span class="p">:</span> <span class="n">ColMajor</span><span class="p">,</span> <span class="n">StorageIndex</span><span class="o">&gt;</span> <span class="n">PlainObject</span><span class="p">;</span>

<span class="cp">#ifndef EIGEN_PARSED_BY_DOXYGEN</span>
    <span class="cm">/** This is the &quot;real scalar&quot; type; if the \a Scalar type is already real numbers</span>
<span class="cm">      * (e.g. int, float or double) then \a RealScalar is just the same as \a Scalar. If</span>
<span class="cm">      * \a Scalar is \a std::complex&lt;T&gt; then RealScalar is \a T.</span>
<span class="cm">      *</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseMatrixBase.h#L192">SparseMatrixBase.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>188
189
190
191
192
193
194
195
196
197
198</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="kt">bool</span> <span class="nf">isRValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_isRValue</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">markAsRValue</span><span class="p">()</span> <span class="p">{</span> <span class="n">m_isRValue</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">SparseMatrixBase</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_isRValue</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* TODO check flags */</span> <span class="p">}</span>
<span class="hll">
</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherDerived</span><span class="o">&gt;</span>
    <span class="n">Derived</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ReturnByValue</span><span class="o">&lt;</span><span class="n">OtherDerived</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">);</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherDerived</span><span class="o">&gt;</span>
    <span class="kr">inline</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseMatrixBase</span><span class="o">&lt;</span><span class="n">OtherDerived</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparsePermutation.h#L91">SparsePermutation.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>87
88
89
90
91
92
93
94
95
96
97</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">ProductTag</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">product_promote_storage_type</span><span class="o">&lt;</span><span class="n">Sparse</span><span class="p">,</span>             <span class="n">PermutationStorage</span><span class="p">,</span> <span class="n">ProductTag</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">typedef</span> <span class="n">Sparse</span> <span class="n">ret</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">ProductTag</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">product_promote_storage_type</span><span class="o">&lt;</span><span class="n">PermutationStorage</span><span class="p">,</span> <span class="n">Sparse</span><span class="p">,</span>             <span class="n">ProductTag</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">typedef</span> <span class="n">Sparse</span> <span class="n">ret</span><span class="p">;</span> <span class="p">};</span>

<span class="c1">// TODO, the following two overloads are only needed to define the right temporary type through</span>
<span class="hll"><span class="c1">// typename traits&lt;permutation_sparse_matrix_product&lt;Rhs,Lhs,OnTheRight,false&gt; &gt;::ReturnType</span>
</span><span class="c1">// whereas it should be correctly handled by traits&lt;Product&lt;&gt; &gt;::PlainObject</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ProductTag</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">product_evaluator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="p">,</span> <span class="n">AliasFreeProduct</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ProductTag</span><span class="p">,</span> <span class="n">PermutationShape</span><span class="p">,</span> <span class="n">SparseShape</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">permutation_matrix_product</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="p">,</span><span class="n">OnTheLeft</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="n">SparseShape</span><span class="o">&gt;::</span><span class="n">ReturnType</span><span class="o">&gt;</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseRef.h#L351">SparseRef.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>347
348
349
350
351
352
353
354
355
356
357
358</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">};</span>

<span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

<span class="hll"><span class="c1">// FIXME shall we introduce a general evaluatior_ref that we can specialize for any sparse object once, and thus remove this copy-pasta thing...</span>
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatScalar</span><span class="p">,</span> <span class="kt">int</span> <span class="n">MatOptions</span><span class="p">,</span> <span class="k">typename</span> <span class="n">MatIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Options</span><span class="p">,</span> <span class="k">typename</span> <span class="n">StrideType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">Ref</span><span class="o">&lt;</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">MatScalar</span><span class="p">,</span><span class="n">MatOptions</span><span class="p">,</span><span class="n">MatIndex</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">StrideType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">SparseCompressedBase</span><span class="o">&lt;</span><span class="n">Ref</span><span class="o">&lt;</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">MatScalar</span><span class="p">,</span><span class="n">MatOptions</span><span class="p">,</span><span class="n">MatIndex</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">StrideType</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">SparseCompressedBase</span><span class="o">&lt;</span><span class="n">Ref</span><span class="o">&lt;</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">MatScalar</span><span class="p">,</span><span class="n">MatOptions</span><span class="p">,</span><span class="n">MatIndex</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">StrideType</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Base</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Ref</span><span class="o">&lt;</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">MatScalar</span><span class="p">,</span><span class="n">MatOptions</span><span class="p">,</span><span class="n">MatIndex</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">StrideType</span><span class="o">&gt;</span> <span class="n">XprType</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseSelfAdjointView.h#L126">SparseSelfAdjointView.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>122
123
124
125
126
127
128
129
130
131
132
133</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DerivedU</span><span class="o">&gt;</span>
    <span class="n">SparseSelfAdjointView</span><span class="o">&amp;</span> <span class="n">rankUpdate</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseMatrixBase</span><span class="o">&lt;</span><span class="n">DerivedU</span><span class="o">&gt;&amp;</span> <span class="n">u</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

    <span class="cm">/** \returns an expression of P H P^-1 */</span>
<span class="hll">    <span class="c1">// TODO implement twists in a more evaluator friendly fashion</span>
</span>    <span class="n">SparseSymmetricPermutationProduct</span><span class="o">&lt;</span><span class="n">_MatrixTypeNested</span><span class="p">,</span><span class="n">Mode</span><span class="o">&gt;</span> <span class="n">twistedBy</span><span class="p">(</span><span class="k">const</span> <span class="n">PermutationMatrix</span><span class="o">&lt;</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">StorageIndex</span><span class="o">&gt;&amp;</span> <span class="n">perm</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">SparseSymmetricPermutationProduct</span><span class="o">&lt;</span><span class="n">_MatrixTypeNested</span><span class="p">,</span><span class="n">Mode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_matrix</span><span class="p">,</span> <span class="n">perm</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SrcMatrixType</span><span class="p">,</span><span class="kt">int</span> <span class="n">SrcMode</span><span class="o">&gt;</span>
    <span class="n">SparseSelfAdjointView</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseSymmetricPermutationProduct</span><span class="o">&lt;</span><span class="n">SrcMatrixType</span><span class="p">,</span><span class="n">SrcMode</span><span class="o">&gt;&amp;</span> <span class="n">permutedMatrix</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseSelfAdjointView.h#L207">SparseSelfAdjointView.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>203
204
205
206
207
208
209
210
211
212
213
214</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span>

<span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

<span class="hll"><span class="c1">// TODO currently a selfadjoint expression has the form SelfAdjointView&lt;.,.&gt;</span>
</span><span class="c1">//      in the future selfadjoint-ness should be defined by the expression traits</span>
<span class="c1">//      such that Transpose&lt;SelfAdjointView&lt;.,.&gt; &gt; is valid. (currently TriangularBase::transpose() is overloaded to make it work)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Mode</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">evaluator_traits</span><span class="o">&lt;</span><span class="n">SparseSelfAdjointView</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span><span class="n">Mode</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">storage_kind_to_evaluator_kind</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">StorageKind</span><span class="o">&gt;::</span><span class="n">Kind</span> <span class="n">Kind</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">SparseSelfAdjointShape</span> <span class="n">Shape</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseSelfAdjointView.h#L234">SparseSelfAdjointView.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>230
231
232
233
234
235
236
237
238
239
240
241</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">{</span>
    <span class="n">internal</span><span class="o">::</span><span class="n">permute_symm_to_fullsymm</span><span class="o">&lt;</span><span class="n">SrcXprType</span><span class="o">::</span><span class="n">Mode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">matrix</span><span class="p">(),</span> <span class="n">dst</span><span class="p">);</span>
  <span class="p">}</span>

<span class="hll">  <span class="c1">// FIXME: the handling of += and -= in sparse matrices should be cleanup so that next two overloads could be reduced to:</span>
</span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DestScalar</span><span class="p">,</span><span class="kt">int</span> <span class="n">StorageOrder</span><span class="p">,</span><span class="k">typename</span> <span class="n">AssignFunc</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">DestScalar</span><span class="p">,</span><span class="n">StorageOrder</span><span class="p">,</span><span class="n">StorageIndex</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">SrcXprType</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">AssignFunc</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">DestScalar</span><span class="p">,</span><span class="n">StorageOrder</span><span class="p">,</span><span class="n">StorageIndex</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
    <span class="n">run</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">AssignOpType</span><span class="p">());</span>
    <span class="n">call_assignment_no_alias_no_transpose</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseSelfAdjointView.h#L264">SparseSelfAdjointView.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>260
261
262
263
264
265
266
267
268
269
270</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DestScalar</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="n">DynamicSparseMatrix</span><span class="o">&lt;</span><span class="n">DestScalar</span><span class="p">,</span><span class="n">ColMajor</span><span class="p">,</span><span class="n">StorageIndex</span><span class="o">&gt;&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">SrcXprType</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">AssignOpType</span><span class="o">&amp;</span><span class="cm">/*func*/</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// TODO directly evaluate into dst;</span>
<span class="hll">    <span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">DestScalar</span><span class="p">,</span><span class="n">ColMajor</span><span class="p">,</span><span class="n">StorageIndex</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="n">dst</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
</span>    <span class="n">internal</span><span class="o">::</span><span class="n">permute_symm_to_fullsymm</span><span class="o">&lt;</span><span class="n">SrcXprType</span><span class="o">::</span><span class="n">Mode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">matrix</span><span class="p">(),</span> <span class="n">tmp</span><span class="p">);</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace internal</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseSelfAdjointView.h#L377">SparseSelfAdjointView.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>373
374
375
376
377
378
379
380
381
382
383
384</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// NOTE: these two overloads are needed to evaluate the sparse selfadjoint view into a full sparse matrix</span>
<span class="hll"><span class="c1">// TODO: maybe the copy could be handled by generic_product_impl so that these overloads would not be needed anymore</span>
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">LhsView</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ProductTag</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">product_evaluator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&lt;</span><span class="n">LhsView</span><span class="p">,</span> <span class="n">Rhs</span><span class="p">,</span> <span class="n">DefaultProduct</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ProductTag</span><span class="p">,</span> <span class="n">SparseSelfAdjointShape</span><span class="p">,</span> <span class="n">SparseShape</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Product</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Rhs</span><span class="o">::</span><span class="n">PlainObject</span><span class="p">,</span> <span class="n">Rhs</span><span class="p">,</span> <span class="n">DefaultProduct</span><span class="o">&gt;::</span><span class="n">PlainObject</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Product</span><span class="o">&lt;</span><span class="n">LhsView</span><span class="p">,</span> <span class="n">Rhs</span><span class="p">,</span> <span class="n">DefaultProduct</span><span class="o">&gt;</span> <span class="n">XprType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">XprType</span><span class="o">::</span><span class="n">PlainObject</span> <span class="n">PlainObject</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseSelfAdjointView.h#L585">SparseSelfAdjointView.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>581
582
583
584
585
586
587
588
589
590
591</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span>

<span class="p">}</span>

<span class="hll"><span class="c1">// TODO implement twists in a more evaluator friendly fashion</span>
</span>
<span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Mode</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">SparseSymmetricPermutationProduct</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span><span class="n">Mode</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">:</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseSparseProductWithPruning.h#L58">SparseSparseProductWithPruning.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>54
55
56
57
58
59
60
61
62
63
64
65</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">res</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">estimated_nnz_prod</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">ratioColRes</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">estimated_nnz_prod</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">rows</span><span class="p">())</span><span class="o">*</span><span class="kt">double</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">cols</span><span class="p">()));</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME:</span>
</span>    <span class="c1">//double ratioColRes = (double(rhs.innerVector(j).nonZeros()) + double(lhs.nonZeros())/double(lhs.cols()))/double(lhs.rows());</span>
    <span class="c1">// let&#39;s do a more accurate determination of the nnz ratio for the current column j of res</span>
    <span class="n">tempVector</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">ratioColRes</span><span class="p">);</span>
    <span class="n">tempVector</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">typename</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;::</span><span class="n">InnerIterator</span> <span class="n">rhsIt</span><span class="p">(</span><span class="n">rhsEval</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="n">rhsIt</span><span class="p">;</span> <span class="o">++</span><span class="n">rhsIt</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// FIXME should be written like this: tmp += rhsIt.value() * lhs.col(rhsIt.index())</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseSparseProductWithPruning.h#L65">SparseSparseProductWithPruning.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>61
62
63
64
65
66
67
68
69
70
71
72</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">tempVector</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">ratioColRes</span><span class="p">);</span>
    <span class="n">tempVector</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">typename</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;::</span><span class="n">InnerIterator</span> <span class="n">rhsIt</span><span class="p">(</span><span class="n">rhsEval</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="n">rhsIt</span><span class="p">;</span> <span class="o">++</span><span class="n">rhsIt</span><span class="p">)</span>
    <span class="p">{</span>
<span class="hll">      <span class="c1">// FIXME should be written like this: tmp += rhsIt.value() * lhs.col(rhsIt.index())</span>
</span>      <span class="n">tempVector</span><span class="p">.</span><span class="n">restart</span><span class="p">();</span>
      <span class="n">RhsScalar</span> <span class="n">x</span> <span class="o">=</span> <span class="n">rhsIt</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">typename</span> <span class="n">evaluator</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;::</span><span class="n">InnerIterator</span> <span class="n">lhsIt</span><span class="p">(</span><span class="n">lhsEval</span><span class="p">,</span> <span class="n">rhsIt</span><span class="p">.</span><span class="n">index</span><span class="p">());</span> <span class="n">lhsIt</span><span class="p">;</span> <span class="o">++</span><span class="n">lhsIt</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">tempVector</span><span class="p">.</span><span class="n">coeffRef</span><span class="p">(</span><span class="n">lhsIt</span><span class="p">.</span><span class="n">index</span><span class="p">())</span> <span class="o">+=</span> <span class="n">lhsIt</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseUtil.h#L96">SparseUtil.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">SparseVector</span><span class="o">&lt;</span><span class="n">_Scalar</span><span class="p">,</span> <span class="n">ColMajor</span><span class="p">,</span> <span class="n">_StorageIndex</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="hll"><span class="c1">// TODO this seems almost identical to plain_matrix_type&lt;T, Sparse&gt;</span>
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span><span class="kt">int</span> <span class="n">Rows</span><span class="p">,</span><span class="kt">int</span> <span class="n">Cols</span><span class="p">,</span><span class="kt">int</span> <span class="n">Flags</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">sparse_eval</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Scalar</span> <span class="n">_Scalar</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">StorageIndex</span> <span class="n">_StorageIndex</span><span class="p">;</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">_Options</span> <span class="o">=</span> <span class="p">((</span><span class="n">Flags</span><span class="o">&amp;</span><span class="n">RowMajorBit</span><span class="p">)</span><span class="o">==</span><span class="n">RowMajorBit</span><span class="p">)</span> <span class="o">?</span> <span class="nl">RowMajor</span> <span class="p">:</span> <span class="n">ColMajor</span> <span class="p">};</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">_Scalar</span><span class="p">,</span> <span class="n">_Options</span><span class="p">,</span> <span class="n">_StorageIndex</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseVector.h#L188">SparseVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>184
185
186
187
188
189
190
191
192
193
194
195</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">eigen_assert</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m_size</span><span class="p">);</span>

      <span class="n">Index</span> <span class="n">startId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">Index</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">m_data</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="hll">      <span class="c1">// TODO smart realloc</span>
</span>      <span class="n">m_data</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

      <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">startId</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">m_data</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">m_data</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">m_data</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">m_data</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">m_data</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="o">--</span><span class="n">p</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/SparseView.h#L79">SparseView.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>75
76
77
78
79
80
81
82
83
84
85
86</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">};</span>

<span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

<span class="hll"><span class="c1">// TODO find a way to unify the two following variants</span>
</span><span class="c1">// This is tricky because implementing an inner iterator on top of an IndexBased evaluator is</span>
<span class="c1">// not easy because the evaluators do not expose the sizes of the underlying expression.</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ArgType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">unary_evaluator</span><span class="o">&lt;</span><span class="n">SparseView</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">IteratorBased</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">evaluator_base</span><span class="o">&lt;</span><span class="n">SparseView</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/TriangularSolver.h#L156">TriangularSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>152
153
154
155
156
157
158
159
160
161
162
163</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">!=</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="c1">// optimization when other is actually sparse</span>
        <span class="p">{</span>
          <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">Mode</span> <span class="o">&amp;</span> <span class="n">UnitDiag</span><span class="p">))</span>
          <span class="p">{</span>
<span class="hll">            <span class="c1">// TODO replace this by a binary search. make sure the binary search is safe for partially sorted elements</span>
</span>            <span class="n">LhsIterator</span> <span class="n">it</span><span class="p">(</span><span class="n">lhsEval</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="k">while</span><span class="p">(</span><span class="n">it</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="p">.</span><span class="n">index</span><span class="p">()</span><span class="o">!=</span><span class="n">i</span><span class="p">)</span>
              <span class="o">++</span><span class="n">it</span><span class="p">;</span>
            <span class="n">eigen_assert</span><span class="p">(</span><span class="n">it</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="p">.</span><span class="n">index</span><span class="p">()</span><span class="o">==</span><span class="n">i</span><span class="p">);</span>
            <span class="n">other</span><span class="p">.</span><span class="n">coeffRef</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="o">/=</span> <span class="n">it</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="n">LhsIterator</span> <span class="n">it</span><span class="p">(</span><span class="n">lhsEval</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/TriangularSolver.h#L227">TriangularSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>223
224
225
226
227
228
229
230
231
232
233
234</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">res</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">nonZeros</span><span class="p">());</span>

    <span class="k">for</span><span class="p">(</span><span class="n">Index</span> <span class="n">col</span><span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">col</span><span class="o">&lt;</span><span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span> <span class="p">;</span> <span class="o">++</span><span class="n">col</span><span class="p">)</span>
    <span class="p">{</span>
<span class="hll">      <span class="c1">// FIXME estimate number of non zeros</span>
</span>      <span class="n">tempVector</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="mf">.99</span><span class="cm">/*float(other.col(col).nonZeros())/float(other.rows())*/</span><span class="p">);</span>
      <span class="n">tempVector</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span>
      <span class="n">tempVector</span><span class="p">.</span><span class="n">restart</span><span class="p">();</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">typename</span> <span class="n">Rhs</span><span class="o">::</span><span class="n">InnerIterator</span> <span class="n">rhsIt</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span> <span class="n">rhsIt</span><span class="p">;</span> <span class="o">++</span><span class="n">rhsIt</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">tempVector</span><span class="p">.</span><span class="n">coeffRef</span><span class="p">(</span><span class="n">rhsIt</span><span class="p">.</span><span class="n">index</span><span class="p">())</span> <span class="o">=</span> <span class="n">rhsIt</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
      <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/TriangularSolver.h#L274">TriangularSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>270
271
272
273
274
275
276
277
278
279
280
281</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="p">}</span>


      <span class="n">Index</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="hll">      <span class="c1">// FIXME compute a reference value to filter zeros</span>
</span>      <span class="k">for</span> <span class="p">(</span><span class="k">typename</span> <span class="n">AmbiVector</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">StorageIndex</span><span class="o">&gt;::</span><span class="n">Iterator</span> <span class="n">it</span><span class="p">(</span><span class="n">tempVector</span><span class="cm">/*,1e-12*/</span><span class="p">);</span> <span class="n">it</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="o">++</span> <span class="n">count</span><span class="p">;</span>
<span class="c1">//         std::cerr &lt;&lt; &quot;fill &quot; &lt;&lt; it.index() &lt;&lt; &quot;, &quot; &lt;&lt; col &lt;&lt; &quot;\n&quot;;</span>
<span class="c1">//         std::cout &lt;&lt; it.value() &lt;&lt; &quot;  &quot;;</span>
        <span class="c1">// FIXME use insertBack</span>
        <span class="n">res</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">index</span><span class="p">(),</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseCore/TriangularSolver.h#L280">TriangularSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>276
277
278
279
280
281
282
283
284
285
286
287</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="p">{</span>
        <span class="o">++</span> <span class="n">count</span><span class="p">;</span>
<span class="c1">//         std::cerr &lt;&lt; &quot;fill &quot; &lt;&lt; it.index() &lt;&lt; &quot;, &quot; &lt;&lt; col &lt;&lt; &quot;\n&quot;;</span>
<span class="c1">//         std::cout &lt;&lt; it.value() &lt;&lt; &quot;  &quot;;</span>
<span class="hll">        <span class="c1">// FIXME use insertBack</span>
</span>        <span class="n">res</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">index</span><span class="p">(),</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
      <span class="p">}</span>
<span class="c1">//       std::cout &lt;&lt; &quot;tempVector.nonZeros() == &quot; &lt;&lt; int(count) &lt;&lt; &quot; / &quot; &lt;&lt; (other.rows()) &lt;&lt; &quot;\n&quot;;</span>
    <span class="p">}</span>
    <span class="n">res</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span>
    <span class="n">other</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">markAsRValue</span><span class="p">();</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseLU/SparseLU.h#L414">SparseLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>410
411
412
413
414
415
416
417
418
419
420
421</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">OrderingType</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">SparseLU</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="p">,</span> <span class="n">OrderingType</span><span class="o">&gt;::</span><span class="n">analyzePattern</span><span class="p">(</span><span class="k">const</span> <span class="n">MatrixType</span><span class="o">&amp;</span> <span class="n">mat</span><span class="p">)</span>
<span class="p">{</span>

<span class="hll">  <span class="c1">//TODO  It is possible as in SuperLU to compute row and columns scaling vectors to equilibrate the matrix mat.</span>
</span>
  <span class="c1">// Firstly, copy the whole input matrix.</span>
  <span class="n">m_mat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">;</span>

  <span class="c1">// Compute fill-in ordering</span>
  <span class="n">OrderingType</span> <span class="n">ord</span><span class="p">;</span>
  <span class="n">ord</span><span class="p">(</span><span class="n">m_mat</span><span class="p">,</span><span class="n">m_perm_c</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseLU/SparseLU.h#L670">SparseLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>666
667
668
669
670
671
672
673
674
675
676
677</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// Update the determinant of the row permutation matrix</span>
<span class="hll">      <span class="c1">// FIXME: the following test is not correct, we should probably take iperm_c into account and pivrow is not directly the row pivot.</span>
</span>      <span class="k">if</span> <span class="p">(</span><span class="n">pivrow</span> <span class="o">!=</span> <span class="n">jj</span><span class="p">)</span> <span class="n">m_detPermR</span> <span class="o">=</span> <span class="o">-</span><span class="n">m_detPermR</span><span class="p">;</span>

      <span class="c1">// Prune columns (0:jj-1) using column jj</span>
      <span class="n">Base</span><span class="o">::</span><span class="n">pruneL</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="n">m_perm_r</span><span class="p">.</span><span class="n">indices</span><span class="p">(),</span> <span class="n">pivrow</span><span class="p">,</span> <span class="n">nseg</span><span class="p">,</span> <span class="n">segrep</span><span class="p">,</span> <span class="n">repfnz_k</span><span class="p">,</span> <span class="n">xprune</span><span class="p">,</span> <span class="n">m_glu</span><span class="p">);</span>

      <span class="c1">// Reset repfnz for this column</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nseg</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h#L27">SparseLU_SupernodalMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span> *
 * NOTE : This class corresponds to the SCformat structure in SuperLU
 *
 */
<span class="hll">/* TODO
</span> * InnerIterator as for sparsematrix
 * SuperInnerIterator to iterate through all supernodes
 * Function for triangular solve
 */
template &lt;typename _Scalar, typename _StorageIndex&gt;
class MappedSuperNodalMatrix
{
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h#L58">SparseLU_SupernodalMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>54
55
56
57
58
59
60
61
62
63
64
65</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">}</span>
    <span class="cm">/**</span>
<span class="cm">     * Set appropriate pointers for the lower triangular supernodal matrix</span>
<span class="cm">     * These infos are available at the end of the numerical factorization</span>
<span class="hll"><span class="cm">     * FIXME This class will be modified such that it can be use in the course</span>
</span><span class="cm">     * of the factorization.</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="n">setInfos</span><span class="p">(</span><span class="n">Index</span> <span class="n">m</span><span class="p">,</span> <span class="n">Index</span> <span class="n">n</span><span class="p">,</span> <span class="n">ScalarVector</span><span class="o">&amp;</span> <span class="n">nzval</span><span class="p">,</span> <span class="n">IndexVector</span><span class="o">&amp;</span> <span class="n">nzval_colptr</span><span class="p">,</span> <span class="n">IndexVector</span><span class="o">&amp;</span> <span class="n">rowind</span><span class="p">,</span>
             <span class="n">IndexVector</span><span class="o">&amp;</span> <span class="n">rowind_colptr</span><span class="p">,</span> <span class="n">IndexVector</span><span class="o">&amp;</span> <span class="n">col_to_sup</span><span class="p">,</span> <span class="n">IndexVector</span><span class="o">&amp;</span> <span class="n">sup_to_col</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">m_row</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
      <span class="n">m_col</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseQR/SparseQR.h#L485">SparseQR.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>481
482
483
484
485
486
487
488
489
490
491</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">tdot</span> <span class="o">*=</span> <span class="n">m_hcoeffs</span><span class="p">(</span><span class="n">curIdx</span><span class="p">);</span>

      <span class="c1">// Then update tval = tval - q * tau</span>
      <span class="c1">// FIXME: tval -= tdot * m_Q.col(curIdx) should amount to the same (need to check/add support for efficient &quot;dense ?= sparse&quot;)</span>
<span class="hll">      <span class="k">for</span> <span class="p">(</span><span class="k">typename</span> <span class="n">QRMatrixType</span><span class="o">::</span><span class="n">InnerIterator</span> <span class="n">itq</span><span class="p">(</span><span class="n">m_Q</span><span class="p">,</span> <span class="n">curIdx</span><span class="p">);</span> <span class="n">itq</span><span class="p">;</span> <span class="o">++</span><span class="n">itq</span><span class="p">)</span>
</span>        <span class="n">tval</span><span class="p">(</span><span class="n">itq</span><span class="p">.</span><span class="n">row</span><span class="p">())</span> <span class="o">-=</span> <span class="n">itq</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">*</span> <span class="n">tdot</span><span class="p">;</span>

      <span class="c1">// Detect fill-in for the current column of Q</span>
      <span class="k">if</span><span class="p">(</span><span class="n">m_etree</span><span class="p">(</span><span class="n">Ridx</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="n">nonzeroCol</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">typename</span> <span class="n">QRMatrixType</span><span class="o">::</span><span class="n">InnerIterator</span> <span class="n">itq</span><span class="p">(</span><span class="n">m_Q</span><span class="p">,</span> <span class="n">curIdx</span><span class="p">);</span> <span class="n">itq</span><span class="p">;</span> <span class="o">++</span><span class="n">itq</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseQR/SparseQR.h#L510">SparseQR.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>506
507
508
509
510
511
512
513
514
515
516</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">if</span><span class="p">(</span><span class="n">nonzeroCol</span> <span class="o">&lt;</span> <span class="n">diagSize</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// Compute the Householder reflection that eliminate the current column</span>
      <span class="c1">// FIXME this step should call the Householder module.</span>
<span class="hll">      <span class="n">Scalar</span> <span class="n">c0</span> <span class="o">=</span> <span class="n">nzcolQ</span> <span class="o">?</span> <span class="n">tval</span><span class="p">(</span><span class="n">Qidx</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">:</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span>
      <span class="c1">// First, the squared norm of Q((col+1):m, col)</span>
      <span class="n">RealScalar</span> <span class="n">sqrNorm</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">itq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">itq</span> <span class="o">&lt;</span> <span class="n">nzcolQ</span><span class="p">;</span> <span class="o">++</span><span class="n">itq</span><span class="p">)</span> <span class="n">sqrNorm</span> <span class="o">+=</span> <span class="n">numext</span><span class="o">::</span><span class="n">abs2</span><span class="p">(</span><span class="n">tval</span><span class="p">(</span><span class="n">Qidx</span><span class="p">(</span><span class="n">itq</span><span class="p">)));</span>
      <span class="k">if</span><span class="p">(</span><span class="n">sqrNorm</span> <span class="o">==</span> <span class="n">RealScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">numext</span><span class="o">::</span><span class="n">imag</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span> <span class="o">==</span> <span class="n">RealScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
      <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SparseQR/SparseQR.h#L690">SparseQR.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>686
687
688
689
690
691
692
693
694
695
696
697</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>
  <span class="k">const</span> <span class="n">SparseQRType</span><span class="o">&amp;</span> <span class="n">m_qr</span><span class="p">;</span>
<span class="p">};</span>

<span class="hll"><span class="c1">// TODO this actually represents the adjoint of Q</span>
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SparseQRType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">SparseQRMatrixQTransposeReturnType</span>
<span class="p">{</span>
  <span class="k">explicit</span> <span class="n">SparseQRMatrixQTransposeReturnType</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseQRType</span><span class="o">&amp;</span> <span class="n">qr</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_qr</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="o">&gt;</span>
  <span class="n">SparseQR_QProduct</span><span class="o">&lt;</span><span class="n">SparseQRType</span><span class="p">,</span><span class="n">Derived</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">MatrixBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SuperLUSupport/SuperLUSupport.h#L219">SuperLUSupport.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>215
216
217
218
219
220
221
222
223
224
225</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">res</span><span class="p">.</span><span class="n">storage</span><span class="p">.</span><span class="n">outerInd</span>  <span class="o">=</span> <span class="n">mat</span><span class="p">.</span><span class="n">outerIndexPtr</span><span class="p">();</span>

    <span class="n">res</span><span class="p">.</span><span class="n">setScalarType</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">();</span>

<span class="hll">    <span class="c1">// FIXME the following is not very accurate</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">Upper</span><span class="p">)</span>
      <span class="n">res</span><span class="p">.</span><span class="n">Mtype</span> <span class="o">=</span> <span class="n">SLU_TRU</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">Lower</span><span class="p">)</span>
      <span class="n">res</span><span class="p">.</span><span class="n">Mtype</span> <span class="o">=</span> <span class="n">SLU_TRL</span><span class="p">;</span>

    <span class="n">eigen_assert</span><span class="p">(((</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">SelfAdjoint</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;SelfAdjoint matrix shape not supported by SuperLU&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SuperLUSupport/SuperLUSupport.h#L278">SuperLUSupport.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>274
275
276
277
278
279
280
281
282
283
284
285</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">res</span><span class="p">.</span><span class="n">storage</span><span class="p">.</span><span class="n">outerInd</span>  <span class="o">=</span> <span class="n">mat</span><span class="p">.</span><span class="n">outerIndexPtr</span><span class="p">();</span>

    <span class="n">res</span><span class="p">.</span><span class="n">setScalarType</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">();</span>

<span class="hll">    <span class="c1">// FIXME the following is not very accurate</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">Upper</span><span class="p">)</span>
      <span class="n">res</span><span class="p">.</span><span class="n">Mtype</span> <span class="o">=</span> <span class="n">SLU_TRU</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">Lower</span><span class="p">)</span>
      <span class="n">res</span><span class="p">.</span><span class="n">Mtype</span> <span class="o">=</span> <span class="n">SLU_TRL</span><span class="p">;</span>

    <span class="n">eigen_assert</span><span class="p">(((</span><span class="n">MatrixType</span><span class="o">::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">SelfAdjoint</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;SelfAdjoint matrix shape not supported by SuperLU&quot;</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SuperLUSupport/SuperLUSupport.h#L642">SuperLUSupport.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>638
639
640
641
642
643
644
645
646
647
648
649</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">StatFree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_sluStat</span><span class="p">);</span>

  <span class="n">m_extractedDataAreDirty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="hll">  <span class="c1">// FIXME how to better check for errors ???</span>
</span>  <span class="n">m_info</span> <span class="o">=</span> <span class="n">info</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">Success</span> <span class="p">:</span> <span class="n">NumericalIssue</span><span class="p">;</span>
  <span class="n">m_factorizationIsOk</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span><span class="k">typename</span> <span class="n">Dest</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">SuperLU</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">_solve_impl</span><span class="p">(</span><span class="k">const</span> <span class="n">MatrixBase</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">MatrixBase</span><span class="o">&lt;</span><span class="n">Dest</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/SuperLUSupport/SuperLUSupport.h#L965">SuperLUSupport.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>961
962
963
964
965
966
967
968
969
970
971
972</pre></div></td><td class="code"><div class="highlight"><pre><span></span>                <span class="o">&amp;</span><span class="n">recip_pivot_growth</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcond</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">m_sluStat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">());</span>
  <span class="n">StatFree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_sluStat</span><span class="p">);</span>

<span class="hll">  <span class="c1">// FIXME how to better check for errors ???</span>
</span>  <span class="n">m_info</span> <span class="o">=</span> <span class="n">info</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">Success</span> <span class="p">:</span> <span class="n">NumericalIssue</span><span class="p">;</span>
  <span class="n">m_factorizationIsOk</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef EIGEN_PARSED_BY_DOXYGEN</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span><span class="k">typename</span> <span class="n">Dest</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/UmfPackSupport/UmfPackSupport.h#L15">UmfPackSupport.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#define EIGEN_UMFPACKSUPPORT_H</span>

<span class="k">namespace</span> <span class="n">Eigen</span> <span class="p">{</span>

<span class="hll"><span class="cm">/* TODO extract L, extract U, compute det, etc... */</span>
</span>
<span class="c1">// generic double/complex&lt;double&gt; wrapper functions:</span>


<span class="kr">inline</span> <span class="kt">void</span> <span class="n">umfpack_defaults</span><span class="p">(</span><span class="kt">double</span> <span class="n">control</span><span class="p">[</span><span class="n">UMFPACK_CONTROL</span><span class="p">],</span> <span class="kt">double</span><span class="p">)</span>
<span class="p">{</span> <span class="n">umfpack_di_defaults</span><span class="p">(</span><span class="n">control</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/plugins/ArrayCwiseBinaryOps.h#L107">ArrayCwiseBinaryOps.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>103
104
105
106
107
108
109
110
111
112
113
114</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">CwiseBinaryOp</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">scalar_pow_op</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Derived</span><span class="p">,</span><span class="n">Constant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">pow</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">exponent</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="cp">#endif</span>


<span class="hll"><span class="c1">// TODO code generating macros could be moved to Macros.h and could include generation of documentation</span>
</span><span class="cp">#define EIGEN_MAKE_CWISE_COMP_OP(OP, COMPARATOR) \</span>
<span class="cp">template&lt;typename OtherDerived&gt; \</span>
<span class="cp">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CwiseBinaryOp&lt;internal::scalar_cmp_op&lt;Scalar, typename OtherDerived::Scalar, internal::cmp_ ## COMPARATOR&gt;, const Derived, const OtherDerived&gt; \</span>
<span class="cp">OP(const EIGEN_CURRENT_STORAGE_BASE_CLASS&lt;OtherDerived&gt; &amp;other) const \</span>
<span class="cp">{ \</span>
<span class="cp">  return CwiseBinaryOp&lt;internal::scalar_cmp_op&lt;Scalar, typename OtherDerived::Scalar, internal::cmp_ ## COMPARATOR&gt;, const Derived, const OtherDerived&gt;(derived(), other.derived()); \</span>
<span class="cp">}\</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/mpreal/mpreal.h#L744">mpreal.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>740
741
742
743
744
745
746
747
748
749
750
751</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">internal</span><span class="p">{</span>

    <span class="c1">// Use SFINAE to restrict arithmetic operations instantiation only for numeric types</span>
    <span class="c1">// This is needed for smooth integration with libraries based on expression templates, like Eigen.</span>
<span class="hll">    <span class="c1">// TODO: Do the same for boolean operators.</span>
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ArgumentType</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">result_type</span> <span class="p">{};</span>

    <span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">result_type</span><span class="o">&lt;</span><span class="n">mpreal</span><span class="o">&gt;</span>              <span class="p">{</span><span class="k">typedef</span> <span class="n">mpreal</span> <span class="n">type</span><span class="p">;};</span>
    <span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">result_type</span><span class="o">&lt;</span><span class="n">mpz_t</span><span class="o">&gt;</span>               <span class="p">{</span><span class="k">typedef</span> <span class="n">mpreal</span> <span class="n">type</span><span class="p">;};</span>
    <span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">result_type</span><span class="o">&lt;</span><span class="n">mpq_t</span><span class="o">&gt;</span>               <span class="p">{</span><span class="k">typedef</span> <span class="n">mpreal</span> <span class="n">type</span><span class="p">;};</span>
    <span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">result_type</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">double</span><span class="o">&gt;</span>         <span class="p">{</span><span class="k">typedef</span> <span class="n">mpreal</span> <span class="n">type</span><span class="p">;};</span>
    <span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">result_type</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>              <span class="p">{</span><span class="k">typedef</span> <span class="n">mpreal</span> <span class="n">type</span><span class="p">;};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/mpreal/mpreal.h#L1757">mpreal.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1753
1754
1755
1756
1757
1758
1759
1760
1761
1762
1763</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#endif</span>

<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mpreal</span><span class="o">::</span><span class="n">toString</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">mp_rnd_t</span> <span class="n">mode</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
<span class="hll">    <span class="c1">// TODO: Add extended format specification (f, e, rounding mode) as it done in output operator</span>
</span>    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">mode</span><span class="p">;</span>

<span class="cp">#if (MPFR_VERSION &gt;= MPFR_VERSION_NUM(2,4,0))</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">format</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/test/mpreal/mpreal.h#L1906">mpreal.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1902
1903
1904
1905
1906
1907
1908
1909
1910
1911
1912
1913</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span>

<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">mpreal</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">    <span class="c1">// TODO: use cout::hexfloat and other flags to setup base</span>
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">mpfr_set_str</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">mpfr_ptr</span><span class="p">(),</span> <span class="n">tmp</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="mi">10</span><span class="p">,</span> <span class="n">mpreal</span><span class="o">::</span><span class="n">get_default_rnd</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////////////////////////////////////</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/functors/AssignmentFunctors.h#L148">AssignmentFunctors.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>144
145
146
147
148
149
150
151
152
153
154
155</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">EIGEN_EMPTY_STRUCT_CTOR</span><span class="p">(</span><span class="n">swap_assign_op</span><span class="p">)</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">assignCoeff</span><span class="p">(</span><span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
<span class="cp">#ifdef __CUDACC__</span>
<span class="hll">    <span class="c1">// FIXME is there some kind of cuda::swap?</span>
</span>    <span class="n">Scalar</span> <span class="n">t</span><span class="o">=</span><span class="n">b</span><span class="p">;</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">=</span><span class="n">a</span><span class="p">;</span> <span class="n">a</span><span class="o">=</span><span class="n">t</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="cp">#endif</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/functors/BinaryFunctors.h#L55">BinaryFunctors.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>51
52
53
54
55
56
57
58
59
60
61
62</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">functor_traits</span><span class="o">&lt;</span><span class="n">scalar_sum_op</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span><span class="n">RhsScalar</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">Cost</span> <span class="o">=</span> <span class="p">(</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="o">&gt;::</span><span class="n">AddCost</span><span class="o">+</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="o">&gt;::</span><span class="n">AddCost</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="c1">// rough estimate!</span>
    <span class="n">PacketAccess</span> <span class="o">=</span> <span class="n">is_same</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span><span class="n">RhsScalar</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="o">&gt;::</span><span class="n">HasAdd</span> <span class="o">&amp;&amp;</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="o">&gt;::</span><span class="n">HasAdd</span>
<span class="hll">    <span class="c1">// TODO vectorize mixed sum</span>
</span>  <span class="p">};</span>
<span class="p">};</span>

<span class="cm">/** \internal</span>
<span class="cm">  * \brief Template specialization to deprecate the summation of boolean expressions.</span>
<span class="cm">  * This is required to solve Bug 426.</span>
<span class="cm">  * \sa DenseBase::count(), DenseBase::any(), ArrayBase::cast(), MatrixBase::cast()</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/functors/BinaryFunctors.h#L99">BinaryFunctors.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 95
 96
 97
 98
 99
100
101
102
103
104
105
106</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">functor_traits</span><span class="o">&lt;</span><span class="n">scalar_product_op</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span><span class="n">RhsScalar</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">Cost</span> <span class="o">=</span> <span class="p">(</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="o">&gt;::</span><span class="n">MulCost</span> <span class="o">+</span> <span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="o">&gt;::</span><span class="n">MulCost</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="c1">// rough estimate!</span>
    <span class="n">PacketAccess</span> <span class="o">=</span> <span class="n">is_same</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span><span class="n">RhsScalar</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="o">&gt;::</span><span class="n">HasMul</span> <span class="o">&amp;&amp;</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="o">&gt;::</span><span class="n">HasMul</span>
<span class="hll">    <span class="c1">// TODO vectorize mixed product</span>
</span>  <span class="p">};</span>
<span class="p">};</span>

<span class="cm">/** \internal</span>
<span class="cm">  * \brief Template functor to compute the conjugate product of two scalars</span>
<span class="cm">  *</span>
<span class="cm">  * This is a short cut for conj(x) * y which is needed for optimization purpose; in Eigen2 support mode, this becomes x * conj(y)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/functors/UnaryFunctors.h#L757">UnaryFunctors.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>753
754
755
756
757
758
759
760
761
762
763
764</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kr">inline</span> <span class="k">const</span> <span class="n">Scalar</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">Scalar</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="hll">  <span class="c1">//TODO</span>
</span>  <span class="c1">//template &lt;typename Packet&gt;</span>
  <span class="c1">//EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet&amp; a) const { return internal::psign(a); }</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">scalar_sign_op</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">EIGEN_EMPTY_STRUCT_CTOR</span><span class="p">(</span><span class="n">scalar_sign_op</span><span class="p">)</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kr">inline</span> <span class="k">const</span> <span class="n">Scalar</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/functors/UnaryFunctors.h#L773">UnaryFunctors.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>769
770
771
772
773
774
775
776
777
778
779
780</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="k">return</span> <span class="nf">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">aa</span> <span class="o">=</span> <span class="n">real_type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">aa</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">Scalar</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">aa</span><span class="p">,</span> <span class="n">imag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">aa</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="hll">  <span class="c1">//TODO</span>
</span>  <span class="c1">//template &lt;typename Packet&gt;</span>
  <span class="c1">//EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet&amp; a) const { return internal::psign(a); }</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">functor_traits</span><span class="o">&lt;</span><span class="n">scalar_sign_op</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">Cost</span> <span class="o">=</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralBlockPanelKernel.h#L192">GeneralBlockPanelKernel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>188
189
190
191
192
193
194
195
196
197
198
199</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">}</span>

    <span class="c1">// ---- 2nd level of blocking on max(L2,L3), yields nc ----</span>

<span class="hll">    <span class="c1">// TODO find a reliable way to get the actual amount of cache per core to use for 2nd level blocking, that is:</span>
</span>    <span class="c1">//      actual_l2 = max(l2, l3/nb_core_sharing_l3)</span>
    <span class="c1">// The number below is quite conservative: it is better to underestimate the cache size rather than overestimating it)</span>
    <span class="c1">// For instance, it corresponds to 6MB of L3 shared among 4 cores.</span>
    <span class="cp">#ifdef EIGEN_DEBUG_SMALL_PRODUCT_BLOCKS</span>
    <span class="k">const</span> <span class="n">Index</span> <span class="n">actual_l2</span> <span class="o">=</span> <span class="n">l3</span><span class="p">;</span>
    <span class="cp">#else</span>
    <span class="k">const</span> <span class="n">Index</span> <span class="n">actual_l2</span> <span class="o">=</span> <span class="mi">1572864</span><span class="p">;</span> <span class="c1">// == 1.5 MB</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralBlockPanelKernel.h#L236">GeneralBlockPanelKernel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>232
233
234
235
236
237
238
239
240
241
242
243</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">old_k</span><span class="o">==</span><span class="n">k</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// So far, no blocking at all, i.e., kc==k, and nc==n.</span>
      <span class="c1">// In this case, let&#39;s perform a blocking over the rows such that the packed lhs data is kept in cache L1/L2</span>
<span class="hll">      <span class="c1">// TODO: part of this blocking strategy is now implemented within the kernel itself, so the L1-based heuristic here should be obsolete.</span>
</span>      <span class="n">Index</span> <span class="n">problem_size</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LhsScalar</span><span class="p">);</span>
      <span class="n">Index</span> <span class="n">actual_lm</span> <span class="o">=</span> <span class="n">actual_l2</span><span class="p">;</span>
      <span class="n">Index</span> <span class="n">max_mc</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">problem_size</span><span class="o">&lt;=</span><span class="mi">1024</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="c1">// problem is small enough to keep in L1</span>
        <span class="c1">// Let&#39;s choose m such that lhs&#39;s block fit in 1/3 of L1</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralBlockPanelKernel.h#L314">GeneralBlockPanelKernel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>310
311
312
313
314
315
316
317
318
319
320
321</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#ifdef EIGEN_HAS_SINGLE_INSTRUCTION_CJMADD</span>
  <span class="cp">#define CJMADD(CJ,A,B,C,T)  C = CJ.pmadd(A,B,C);</span>
<span class="cp">#else</span>

<span class="hll">  <span class="c1">// FIXME (a bit overkill maybe ?)</span>
</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">CJ</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">gebp_madd_selector</span> <span class="p">{</span>
    <span class="n">EIGEN_ALWAYS_INLINE</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="k">const</span> <span class="n">CJ</span><span class="o">&amp;</span> <span class="n">cj</span><span class="p">,</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="cm">/*t*/</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmadd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralBlockPanelKernel.h#L617">GeneralBlockPanelKernel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>613
614
615
616
617
618
619
620
621
622
623</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">ResPacketSize</span>   <span class="o">=</span> <span class="n">Vectorizable</span> <span class="o">?</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">ResScalar</span><span class="o">&gt;::</span><span class="nl">size</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">LhsPacketSize</span> <span class="o">=</span> <span class="n">Vectorizable</span> <span class="o">?</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="o">&gt;::</span><span class="nl">size</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">RhsPacketSize</span> <span class="o">=</span> <span class="n">Vectorizable</span> <span class="o">?</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="o">&gt;::</span><span class="nl">size</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>

<span class="hll">    <span class="c1">// FIXME: should depend on NumberOfRegisters</span>
</span>    <span class="n">nr</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">mr</span> <span class="o">=</span> <span class="n">ResPacketSize</span><span class="p">,</span>

    <span class="n">LhsProgress</span> <span class="o">=</span> <span class="n">ResPacketSize</span><span class="p">,</span>
    <span class="n">RhsProgress</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralBlockPanelKernel.h#L667">GeneralBlockPanelKernel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>663
664
665
666
667
668
669
670
671
672
673
674</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>

  <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">broadcastRhs</span><span class="p">(</span><span class="k">const</span> <span class="n">RhsScalar</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">RhsPacket</span><span class="o">&amp;</span> <span class="n">b0</span><span class="p">,</span> <span class="n">RhsPacket</span><span class="o">&amp;</span> <span class="n">b1</span><span class="p">,</span> <span class="n">RhsPacket</span><span class="o">&amp;</span> <span class="n">b2</span><span class="p">,</span> <span class="n">RhsPacket</span><span class="o">&amp;</span> <span class="n">b3</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME not sure that&#39;s the best way to implement it!</span>
</span>    <span class="n">loadRhs</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="n">b0</span><span class="p">);</span>
    <span class="n">loadRhs</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b1</span><span class="p">);</span>
    <span class="n">loadRhs</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">b2</span><span class="p">);</span>
    <span class="n">loadRhs</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">b3</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Vectorized path</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralBlockPanelKernel.h#L677">GeneralBlockPanelKernel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>673
674
675
676
677
678
679
680
681
682
683</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c1">// Vectorized path</span>
  <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="nf">broadcastRhs</span><span class="p">(</span><span class="k">const</span> <span class="n">RhsScalar</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">DoublePacketType</span><span class="o">&amp;</span> <span class="n">b0</span><span class="p">,</span> <span class="n">DoublePacketType</span><span class="o">&amp;</span> <span class="n">b1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// FIXME not sure that&#39;s the best way to implement it!</span>
<span class="hll">    <span class="n">loadRhs</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="n">b0</span><span class="p">);</span>
</span>    <span class="n">loadRhs</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Scalar path</span>
  <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="nf">broadcastRhs</span><span class="p">(</span><span class="k">const</span> <span class="n">RhsScalar</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">RhsScalar</span><span class="o">&amp;</span> <span class="n">b0</span><span class="p">,</span> <span class="n">RhsScalar</span><span class="o">&amp;</span> <span class="n">b1</span><span class="p">)</span>
  <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralBlockPanelKernel.h#L685">GeneralBlockPanelKernel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>681
682
683
684
685
686
687
688
689
690
691</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c1">// Scalar path</span>
  <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="nf">broadcastRhs</span><span class="p">(</span><span class="k">const</span> <span class="n">RhsScalar</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">RhsScalar</span><span class="o">&amp;</span> <span class="n">b0</span><span class="p">,</span> <span class="n">RhsScalar</span><span class="o">&amp;</span> <span class="n">b1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// FIXME not sure that&#39;s the best way to implement it!</span>
<span class="hll">    <span class="n">loadRhs</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="n">b0</span><span class="p">);</span>
</span>    <span class="n">loadRhs</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// nothing special here</span>
  <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="nf">loadLhs</span><span class="p">(</span><span class="k">const</span> <span class="n">LhsScalar</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">LhsPacket</span><span class="o">&amp;</span> <span class="n">dest</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralBlockPanelKernel.h#L765">GeneralBlockPanelKernel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>761
762
763
764
765
766
767
768
769
770
771</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">RhsPacketSize</span> <span class="o">=</span> <span class="n">Vectorizable</span> <span class="o">?</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="o">&gt;::</span><span class="nl">size</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">ResPacketSize</span> <span class="o">=</span> <span class="n">Vectorizable</span> <span class="o">?</span> <span class="n">packet_traits</span><span class="o">&lt;</span><span class="n">ResScalar</span><span class="o">&gt;::</span><span class="nl">size</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>

    <span class="n">NumberOfRegisters</span> <span class="o">=</span> <span class="n">EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS</span><span class="p">,</span>
<span class="hll">    <span class="c1">// FIXME: should depend on NumberOfRegisters</span>
</span>    <span class="n">nr</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">mr</span> <span class="o">=</span> <span class="p">(</span><span class="n">EIGEN_PLAIN_ENUM_MIN</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="n">NumberOfRegisters</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">nr</span><span class="p">)</span><span class="o">*</span><span class="n">ResPacketSize</span><span class="p">,</span>

    <span class="n">LhsProgress</span> <span class="o">=</span> <span class="n">ResPacketSize</span><span class="p">,</span>
    <span class="n">RhsProgress</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h#L70">GeneralMatrixMatrixTriangular_BLAS.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>66
67
68
69
70
71
72
73
74
75
76
77</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">};</span>

<span class="n">EIGEN_BLAS_RANKUPDATE_SPECIALIZE</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span>
<span class="n">EIGEN_BLAS_RANKUPDATE_SPECIALIZE</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span>
<span class="hll"><span class="c1">// TODO handle complex cases</span>
</span><span class="c1">// EIGEN_BLAS_RANKUPDATE_SPECIALIZE(dcomplex)</span>
<span class="c1">// EIGEN_BLAS_RANKUPDATE_SPECIALIZE(scomplex)</span>

<span class="c1">// SYRK for float/double</span>
<span class="cp">#define EIGEN_BLAS_RANKUPDATE_R(EIGTYPE, BLASTYPE, BLASFUNC) \</span>
<span class="cp">template &lt;typename Index, int AStorageOrder, bool ConjugateA, int  UpLo&gt; \</span>
<span class="cp">struct general_matrix_matrix_rankupdate&lt;Index,EIGTYPE,AStorageOrder,ConjugateA,ColMajor,UpLo&gt; { \</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h#L136">GeneralMatrixMatrixTriangular_BLAS.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>132
133
134
135
136
137
138
139
140
141
142
143</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">EIGEN_BLAS_RANKUPDATE_R</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">dsyrk_</span><span class="p">)</span>
<span class="n">EIGEN_BLAS_RANKUPDATE_R</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span>  <span class="kt">float</span><span class="p">,</span>  <span class="n">ssyrk_</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="hll"><span class="c1">// TODO hanlde complex cases</span>
</span><span class="c1">// EIGEN_BLAS_RANKUPDATE_C(dcomplex, double, double, zherk_)</span>
<span class="c1">// EIGEN_BLAS_RANKUPDATE_C(scomplex, float,  float, cherk_)</span>


<span class="p">}</span> <span class="c1">// end namespace internal</span>

<span class="p">}</span> <span class="c1">// end namespace Eigen</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralMatrixVector.h#L151">GeneralMatrixVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>147
148
149
150
151
152
153
154
155
156
157</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">alignmentPattern</span> <span class="o">=</span> <span class="n">NoneAligned</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">LhsPacketSize</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO: extend the code to support aligned loads whenever possible when LhsPacketSize &gt; 4.</span>
</span>    <span class="c1">// Currently, it seems to be better to perform unaligned loads anyway</span>
    <span class="n">alignmentPattern</span> <span class="o">=</span> <span class="n">NoneAligned</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">LhsPacketSize</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="c1">//    eigen_internal_assert(size_t(firstLhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0 || size&lt;LhsPacketSize);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralMatrixVector.h#L426">GeneralMatrixVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>422
423
424
425
426
427
428
429
430
431
432
433</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">alignmentPattern</span> <span class="o">=</span> <span class="n">NoneAligned</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">LhsPacketSize</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO: extend the code to support aligned loads whenever possible when LhsPacketSize &gt; 4.</span>
</span>    <span class="n">alignmentPattern</span> <span class="o">=</span> <span class="n">NoneAligned</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">LhsPacketSize</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="c1">//    eigen_internal_assert(size_t(firstLhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0  || depth&lt;LhsPacketSize);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">skipRows</span><span class="o">&lt;</span><span class="n">LhsPacketSize</span> <span class="o">&amp;&amp;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralMatrixVector.h#L466">GeneralMatrixVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>462
463
464
465
466
467
468
469
470
471</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">Index</span> <span class="n">rowBound</span> <span class="o">=</span> <span class="p">((</span><span class="n">rows</span><span class="o">-</span><span class="n">skipRows</span><span class="p">)</span><span class="o">/</span><span class="n">rowsAtOnce</span><span class="p">)</span><span class="o">*</span><span class="n">rowsAtOnce</span> <span class="o">+</span> <span class="n">skipRows</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">i</span><span class="o">=</span><span class="n">skipRows</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">rowBound</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">rowsAtOnce</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// FIXME: what is the purpose of this EIGEN_ALIGN_DEFAULT ??</span>
<span class="hll">    <span class="n">EIGEN_ALIGN_MAX</span> <span class="n">ResScalar</span> <span class="n">tmp0</span> <span class="o">=</span> <span class="n">ResScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span>    <span class="n">ResScalar</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="n">ResScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="n">ResScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">tmp3</span> <span class="o">=</span> <span class="n">ResScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// this helps the compiler generating good binary code</span>
    <span class="k">const</span> <span class="n">LhsScalars</span> <span class="n">lhs0</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">getVectorMapper</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>    <span class="n">lhs1</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">getVectorMapper</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">offset1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                     <span class="n">lhs2</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">getVectorMapper</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>    <span class="n">lhs3</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">getVectorMapper</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">offset3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralMatrixVector.h#L481">GeneralMatrixVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>477
478
479
480
481
482
483
484
485
486
487</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">ResPacket</span> <span class="n">ptmp0</span> <span class="o">=</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">ResPacket</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ResScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">ptmp1</span> <span class="o">=</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">ResPacket</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ResScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
                <span class="n">ptmp2</span> <span class="o">=</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">ResPacket</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ResScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">ptmp3</span> <span class="o">=</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">ResPacket</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ResScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

      <span class="c1">// process initial unaligned coeffs</span>
<span class="hll">      <span class="c1">// FIXME this loop get vectorized by the compiler !</span>
</span>      <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">alignedStart</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">RhsScalar</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">tmp0</span> <span class="o">+=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmul</span><span class="p">(</span><span class="n">lhs0</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">b</span><span class="p">);</span> <span class="n">tmp1</span> <span class="o">+=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmul</span><span class="p">(</span><span class="n">lhs1</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">b</span><span class="p">);</span>
        <span class="n">tmp2</span> <span class="o">+=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmul</span><span class="p">(</span><span class="n">lhs2</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">b</span><span class="p">);</span> <span class="n">tmp3</span> <span class="o">+=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmul</span><span class="p">(</span><span class="n">lhs3</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">b</span><span class="p">);</span>
      <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralMatrixVector.h#L556">GeneralMatrixVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>552
553
554
555
556
557
558
559
560
561
562
563</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="p">}</span>
    <span class="p">}</span> <span class="c1">// end explicit vectorization</span>

    <span class="c1">// process remaining coeffs (or all if no explicit vectorization)</span>
<span class="hll">    <span class="c1">// FIXME this loop get vectorized by the compiler !</span>
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="n">alignedSize</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">depth</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">RhsScalar</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">tmp0</span> <span class="o">+=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmul</span><span class="p">(</span><span class="n">lhs0</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">b</span><span class="p">);</span> <span class="n">tmp1</span> <span class="o">+=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmul</span><span class="p">(</span><span class="n">lhs1</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">b</span><span class="p">);</span>
      <span class="n">tmp2</span> <span class="o">+=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmul</span><span class="p">(</span><span class="n">lhs2</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">b</span><span class="p">);</span> <span class="n">tmp3</span> <span class="o">+=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmul</span><span class="p">(</span><span class="n">lhs3</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">resIncr</span><span class="p">]</span>            <span class="o">+=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">tmp0</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralMatrixVector.h#L580">GeneralMatrixVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>576
577
578
579
580
581
582
583
584
585
586
587</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">EIGEN_ALIGN_MAX</span> <span class="n">ResScalar</span> <span class="n">tmp0</span> <span class="o">=</span> <span class="n">ResScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">ResPacket</span> <span class="n">ptmp0</span> <span class="o">=</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">ResPacket</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp0</span><span class="p">);</span>
      <span class="k">const</span> <span class="n">LhsScalars</span> <span class="n">lhs0</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">getVectorMapper</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="c1">// process first unaligned result&#39;s coeffs</span>
<span class="hll">      <span class="c1">// FIXME this loop get vectorized by the compiler !</span>
</span>      <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">alignedStart</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="n">tmp0</span> <span class="o">+=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmul</span><span class="p">(</span><span class="n">lhs0</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">alignedSize</span><span class="o">&gt;</span><span class="n">alignedStart</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="c1">// process aligned rhs coeffs</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lhs0</span><span class="p">.</span><span class="k">template</span> <span class="n">aligned</span><span class="o">&lt;</span><span class="n">LhsPacket</span><span class="o">&gt;</span><span class="p">(</span><span class="n">alignedStart</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/GeneralMatrixVector.h#L597">GeneralMatrixVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>593
594
595
596
597
598
599
600
601
602
603
604</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">tmp0</span> <span class="o">+=</span> <span class="n">predux</span><span class="p">(</span><span class="n">ptmp0</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// process remaining scalars</span>
<span class="hll">      <span class="c1">// FIXME this loop get vectorized by the compiler !</span>
</span>      <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="n">alignedSize</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">depth</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="n">tmp0</span> <span class="o">+=</span> <span class="n">cj</span><span class="p">.</span><span class="n">pmul</span><span class="p">(</span><span class="n">lhs0</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
      <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">resIncr</span><span class="p">]</span> <span class="o">+=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">tmp0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">skipRows</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/Parallelizer.h#L88">Parallelizer.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>84
85
86
87
88
89
90
91
92
93
94</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">Condition</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Functor</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parallelize_gemm</span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">Index</span> <span class="n">rows</span><span class="p">,</span> <span class="n">Index</span> <span class="n">cols</span><span class="p">,</span> <span class="n">Index</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO when EIGEN_USE_BLAS is defined,</span>
<span class="hll">  <span class="c1">// we should still enable OMP for other scalar types</span>
</span><span class="cp">#if !(defined (EIGEN_HAS_OPENMP)) || defined (EIGEN_USE_BLAS)</span>
  <span class="c1">// FIXME the transpose variable is only needed to properly split</span>
  <span class="c1">// the matrix product when multithreading is enabled. This is a temporary</span>
  <span class="c1">// fix to support row-major destination matrices. This whole</span>
  <span class="c1">// parallelizer mechanism has to be redisigned anyway.</span>
  <span class="n">EIGEN_UNUSED_VARIABLE</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/Parallelizer.h#L91">Parallelizer.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>87
88
89
90
91
92
93
94
95
96
97
98</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="c1">// TODO when EIGEN_USE_BLAS is defined,</span>
  <span class="c1">// we should still enable OMP for other scalar types</span>
<span class="cp">#if !(defined (EIGEN_HAS_OPENMP)) || defined (EIGEN_USE_BLAS)</span>
<span class="hll">  <span class="c1">// FIXME the transpose variable is only needed to properly split</span>
</span>  <span class="c1">// the matrix product when multithreading is enabled. This is a temporary</span>
  <span class="c1">// fix to support row-major destination matrices. This whole</span>
  <span class="c1">// parallelizer mechanism has to be redisigned anyway.</span>
  <span class="n">EIGEN_UNUSED_VARIABLE</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
  <span class="n">EIGEN_UNUSED_VARIABLE</span><span class="p">(</span><span class="n">transpose</span><span class="p">);</span>
  <span class="n">func</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="n">cols</span><span class="p">);</span>
<span class="cp">#else</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/Parallelizer.h#L122">Parallelizer.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>118
119
120
121
122
123
124
125
126
127
128
129</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">Index</span> <span class="n">threads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="o">&lt;</span><span class="n">Index</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nbThreads</span><span class="p">(),</span> <span class="n">pb_max_threads</span><span class="p">);</span>

  <span class="c1">// if multi-threading is explicitely disabled, not useful, or if we already are in a parallel session,</span>
  <span class="c1">// then abort multi-threading</span>
<span class="hll">  <span class="c1">// FIXME omp_get_num_threads()&gt;1 only works for openmp, what if the user does not use openmp?</span>
</span>  <span class="k">if</span><span class="p">((</span><span class="o">!</span><span class="n">Condition</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">threads</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">omp_get_num_threads</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="n">cols</span><span class="p">);</span>

  <span class="n">Eigen</span><span class="o">::</span><span class="n">initParallel</span><span class="p">();</span>
  <span class="n">func</span><span class="p">.</span><span class="n">initParallelSession</span><span class="p">(</span><span class="n">threads</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">transpose</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h#L112">TriangularMatrixMatrix_BLAS.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>108
109
110
111
112
113
114
115
116
117
118
119</pre></div></td><td class="code"><div class="highlight"><pre><span></span>\
<span class="cm">/* Non-square case - doesn&#39;t fit to BLAS ?TRMM. Fall to default triangular product or call BLAS ?GEMM*/</span> \
   <span class="k">if</span> <span class="p">(</span><span class="n">rows</span> <span class="o">!=</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span> \
\
<span class="hll">     <span class="cm">/* FIXME handle mkl_domain_get_max_threads */</span> \
</span>     <span class="cm">/*int nthr = mkl_domain_get_max_threads(EIGEN_BLAS_DOMAIN_BLAS);*/</span> <span class="kt">int</span> <span class="n">nthr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>\
\
     <span class="k">if</span> <span class="p">(((</span><span class="n">nthr</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(((</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">)(</span><span class="n">rows</span><span class="p">,</span><span class="n">depth</span><span class="p">)</span><span class="o">-</span><span class="n">diagSize</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">diagSize</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)))</span> <span class="p">{</span> \
     <span class="cm">/* Most likely no benefit to call TRMM or GEMM from BLAS */</span> \
       <span class="n">product_triangular_matrix_matrix</span><span class="o">&lt;</span><span class="n">EIGTYPE</span><span class="p">,</span><span class="n">Index</span><span class="p">,</span><span class="n">Mode</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span> \
       <span class="n">LhsStorageOrder</span><span class="p">,</span><span class="n">ConjugateLhs</span><span class="p">,</span> <span class="n">RhsStorageOrder</span><span class="p">,</span> <span class="n">ConjugateRhs</span><span class="p">,</span> <span class="n">ColMajor</span><span class="p">,</span> <span class="n">BuiltIn</span><span class="o">&gt;::</span><span class="n">run</span><span class="p">(</span> \
           <span class="n">_rows</span><span class="p">,</span> <span class="n">_cols</span><span class="p">,</span> <span class="n">_depth</span><span class="p">,</span> <span class="n">_lhs</span><span class="p">,</span> <span class="n">lhsStride</span><span class="p">,</span> <span class="n">_rhs</span><span class="p">,</span> <span class="n">rhsStride</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">resStride</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">blocking</span><span class="p">);</span> \
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/TriangularMatrixVector.h#L202">TriangularMatrixVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>198
199
200
201
202
203
204
205
206
207
208
209</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span> <span class="c1">// end namespace internal</span>

<span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

<span class="hll"><span class="c1">// TODO: find a way to factorize this piece of code with gemv_selector since the logic is exactly the same.</span>
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">Mode</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">trmv_selector</span><span class="o">&lt;</span><span class="n">Mode</span><span class="p">,</span><span class="n">ColMajor</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Dest</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="k">const</span> <span class="n">Lhs</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rhs</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">,</span> <span class="n">Dest</span><span class="o">&amp;</span> <span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="k">typename</span> <span class="n">Dest</span><span class="o">::</span><span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">alpha</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Lhs</span><span class="o">::</span><span class="n">Scalar</span>      <span class="n">LhsScalar</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/TriangularMatrixVector.h#L229">TriangularMatrixVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>225
226
227
228
229
230
231
232
233
234
235
236</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">RhsScalar</span> <span class="n">rhs_alpha</span> <span class="o">=</span> <span class="n">RhsBlasTraits</span><span class="o">::</span><span class="n">extractScalarFactor</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
    <span class="n">ResScalar</span> <span class="n">actualAlpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">lhs_alpha</span> <span class="o">*</span> <span class="n">rhs_alpha</span><span class="p">;</span>

    <span class="k">enum</span> <span class="p">{</span>
<span class="hll">      <span class="c1">// FIXME find a way to allow an inner stride on the result if packet_traits&lt;Scalar&gt;::size==1</span>
</span>      <span class="c1">// on, the other hand it is good for the cache to pack the vector anyways...</span>
      <span class="n">EvalToDestAtCompileTime</span> <span class="o">=</span> <span class="n">Dest</span><span class="o">::</span><span class="n">InnerStrideAtCompileTime</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">ComplexByReal</span> <span class="o">=</span> <span class="p">(</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="o">&gt;::</span><span class="n">IsComplex</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="o">&gt;::</span><span class="n">IsComplex</span><span class="p">),</span>
      <span class="n">MightCannotUseDest</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dest</span><span class="o">::</span><span class="n">InnerStrideAtCompileTime</span><span class="o">!=</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">ComplexByReal</span>
    <span class="p">};</span>

    <span class="n">gemv_static_vector_if</span><span class="o">&lt;</span><span class="n">ResScalar</span><span class="p">,</span><span class="n">Dest</span><span class="o">::</span><span class="n">SizeAtCompileTime</span><span class="p">,</span><span class="n">Dest</span><span class="o">::</span><span class="n">MaxSizeAtCompileTime</span><span class="p">,</span><span class="n">MightCannotUseDest</span><span class="o">&gt;</span> <span class="n">static_dest</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/products/TriangularSolverMatrix.h#L118">TriangularSolverMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>114
115
116
117
118
119
120
121
122
123
124
125</pre></div></td><td class="code"><div class="highlight"><pre><span></span>          <span class="n">Index</span> <span class="n">actualPanelWidth</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="o">&lt;</span><span class="n">Index</span><span class="o">&gt;</span><span class="p">(</span><span class="n">actual_kc</span><span class="o">-</span><span class="n">k1</span><span class="p">,</span> <span class="n">SmallPanelWidth</span><span class="p">);</span>
          <span class="c1">// tr solve</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">actualPanelWidth</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
          <span class="p">{</span>
<span class="hll">            <span class="c1">// TODO write a small kernel handling this (can be shared with trsv)</span>
</span>            <span class="n">Index</span> <span class="n">i</span>  <span class="o">=</span> <span class="n">IsLower</span> <span class="o">?</span> <span class="n">k2</span><span class="o">+</span><span class="n">k1</span><span class="o">+</span><span class="nl">k</span> <span class="p">:</span> <span class="n">k2</span><span class="o">-</span><span class="n">k1</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">Index</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">actualPanelWidth</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// remaining size</span>
            <span class="n">Index</span> <span class="n">s</span>  <span class="o">=</span> <span class="n">TriStorageOrder</span><span class="o">==</span><span class="n">RowMajor</span> <span class="o">?</span> <span class="p">(</span><span class="n">IsLower</span> <span class="o">?</span> <span class="n">k2</span><span class="o">+</span><span class="nl">k1</span> <span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                                 <span class="o">:</span>  <span class="n">IsLower</span> <span class="o">?</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">:</span> <span class="n">i</span><span class="o">-</span><span class="n">rs</span><span class="p">;</span>

            <span class="n">Scalar</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mode</span> <span class="o">&amp;</span> <span class="n">UnitDiag</span><span class="p">)</span> <span class="o">?</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">conj</span><span class="p">(</span><span class="n">tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">));</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="n">j2</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">j2</span><span class="o">+</span><span class="n">actual_cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/util/Constants.h#L255">Constants.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>251
252
253
254
255
256
257
258
259
260
261
262</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">};</span>

<span class="cm">/** \ingroup enums</span>
<span class="cm"> * Enum used by DenseBase::corner() in Eigen2 compatibility mode. */</span>
<span class="hll"><span class="c1">// FIXME after the corner() API change, this was not needed anymore, except by AlignedBox</span>
</span><span class="c1">// TODO: find out what to do with that. Adapt the AlignedBox API ?</span>
<span class="k">enum</span> <span class="n">CornerType</span> <span class="p">{</span> <span class="n">TopLeft</span><span class="p">,</span> <span class="n">TopRight</span><span class="p">,</span> <span class="n">BottomLeft</span><span class="p">,</span> <span class="n">BottomRight</span> <span class="p">};</span>

<span class="cm">/** \ingroup enums</span>
<span class="cm">  * Enum containing possible values for the \p Direction parameter of</span>
<span class="cm">  * Reverse, PartialReduxExpr and VectorwiseOp. */</span>
<span class="k">enum</span> <span class="n">DirectionType</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/util/Constants.h#L256">Constants.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>252
253
254
255
256
257
258
259
260
261
262</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/** \ingroup enums</span>
<span class="cm"> * Enum used by DenseBase::corner() in Eigen2 compatibility mode. */</span>
<span class="c1">// FIXME after the corner() API change, this was not needed anymore, except by AlignedBox</span>
<span class="c1">// TODO: find out what to do with that. Adapt the AlignedBox API ?</span>
<span class="hll"><span class="k">enum</span> <span class="n">CornerType</span> <span class="p">{</span> <span class="n">TopLeft</span><span class="p">,</span> <span class="n">TopRight</span><span class="p">,</span> <span class="n">BottomLeft</span><span class="p">,</span> <span class="n">BottomRight</span> <span class="p">};</span>
</span>
<span class="cm">/** \ingroup enums</span>
<span class="cm">  * Enum containing possible values for the \p Direction parameter of</span>
<span class="cm">  * Reverse, PartialReduxExpr and VectorwiseOp. */</span>
<span class="k">enum</span> <span class="n">DirectionType</span> <span class="p">{</span>
  <span class="cm">/** For Reverse, all columns are reversed;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/util/Macros.h#L137">Macros.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>133
134
135
136
137
138
139
140
141
142</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="cp">#define EIGEN_GNUC_AT_MOST(x,y)  0</span>
  <span class="cp">#define EIGEN_GNUC_AT(x,y)       0</span>
<span class="cp">#endif</span>

<span class="hll"><span class="c1">// FIXME: could probably be removed as we do not support gcc 3.x anymore</span>
</span><span class="cp">#if EIGEN_COMP_GNUC &amp;&amp; (__GNUC__ &lt;= 3)</span>
<span class="cp">#define EIGEN_GCC3_OR_OLDER 1</span>
<span class="cp">#else</span>
<span class="cp">#define EIGEN_GCC3_OR_OLDER 0</span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/util/Macros.h#L501">Macros.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>497
498
499
500
501
502
503
504
505
506
507</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// EIGEN_ALWAYS_INLINE is the stronget, it has the effect of making the function inline and adding every possible</span>
<span class="c1">// attribute to maximize inlining. This should only be used when really necessary: in particular,</span>
<span class="c1">// it uses __attribute__((always_inline)) on GCC, which most of the time is useless and can severely harm compile times.</span>
<span class="c1">// FIXME with the always_inline attribute,</span>
<span class="hll"><span class="c1">// gcc 3.4.x and 4.1 reports the following compilation error:</span>
</span><span class="c1">//   Eval.h:91: sorry, unimplemented: inlining failed in call to &#39;const Eigen::Eval&lt;Derived&gt; Eigen::MatrixBase&lt;Scalar, Derived&gt;::eval() const&#39;</span>
<span class="c1">//    : function body not available</span>
<span class="c1">//   See also bug 1367</span>
<span class="cp">#if EIGEN_GNUC_AT_LEAST(4,2)</span>
<span class="cp">#define EIGEN_ALWAYS_INLINE __attribute__((always_inline)) inline</span>
<span class="cp">#else</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/util/Macros.h#L656">Macros.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>652
653
654
655
656
657
658
659
660
661
662
663</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="cp">#define EIGEN_ALIGN_TO_BOUNDARY(n) __attribute__((aligned(n)))</span>
<span class="cp">#elif EIGEN_COMP_MSVC</span>
  <span class="cp">#define EIGEN_ALIGN_TO_BOUNDARY(n) __declspec(align(n))</span>
<span class="cp">#elif EIGEN_COMP_SUNCC</span>
<span class="hll">  <span class="c1">// FIXME not sure about this one:</span>
</span>  <span class="cp">#define EIGEN_ALIGN_TO_BOUNDARY(n) __attribute__((aligned(n)))</span>
<span class="cp">#else</span>
  <span class="cp">#error Please tell me what is the equivalent of __attribute__((aligned(n))) for your compiler</span>
<span class="cp">#endif</span>

<span class="c1">// If the user explicitly disable vectorization, then we also disable alignment</span>
<span class="cp">#if defined(EIGEN_DONT_VECTORIZE)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/util/Macros.h#L869">Macros.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>865
866
867
868
869
870
871
872
873
874
875
876</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">derived</span><span class="p">;</span> \
  <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">const_cast_derived</span><span class="p">;</span>


<span class="hll"><span class="c1">// FIXME Maybe the EIGEN_DENSE_PUBLIC_INTERFACE could be removed as importing PacketScalar is rarely needed</span>
</span><span class="cp">#define EIGEN_DENSE_PUBLIC_INTERFACE(Derived) \</span>
<span class="cp">  EIGEN_GENERIC_PUBLIC_INTERFACE(Derived) \</span>
<span class="cp">  typedef typename Base::PacketScalar PacketScalar;</span>


<span class="cp">#define EIGEN_PLAIN_ENUM_MIN(a,b) (((int)a &lt;= (int)b) ? (int)a : (int)b)</span>
<span class="cp">#define EIGEN_PLAIN_ENUM_MAX(a,b) (((int)a &gt;= (int)b) ? (int)a : (int)b)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/util/Meta.h#L458">Meta.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>454
455
456
457
458
459
460
461
462
463
464</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">Defined</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
<span class="p">};</span>

<span class="hll"><span class="c1">// FIXME quick workaround around current limitation of result_of</span>
</span><span class="c1">// template&lt;typename Scalar, typename ArgType0, typename ArgType1&gt;</span>
<span class="c1">// struct result_of&lt;scalar_product_op&lt;Scalar&gt;(ArgType0,ArgType1)&gt; {</span>
<span class="c1">// typedef typename scalar_product_traits&lt;typename remove_all&lt;ArgType0&gt;::type, typename remove_all&lt;ArgType1&gt;::type&gt;::ReturnType type;</span>
<span class="c1">// };</span>

<span class="p">}</span> <span class="c1">// end namespace internal</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/util/StaticAssert.h#L214">StaticAssert.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>210
211
212
213
214
215
216
217
218</pre></div></td><td class="code"><div class="highlight"><pre><span></span>                                            <span class="o">&gt;::</span><span class="n">value</span><span class="p">),</span> \
                          <span class="n">YOU_CANNOT_MIX_ARRAYS_AND_MATRICES</span><span class="p">)</span>

<span class="c1">// Check that a cost value is positive, and that is stay within a reasonable range</span>
<span class="hll"><span class="c1">// TODO this check could be enabled for internal debugging only</span>
</span><span class="cp">#define EIGEN_INTERNAL_CHECK_COST_VALUE(C) \</span>
<span class="cp">      EIGEN_STATIC_ASSERT((C)&gt;=0 &amp;&amp; (C)&lt;=HugeCost*HugeCost, EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT__INVALID_COST_VALUE);</span>

<span class="cp">#endif </span><span class="c1">// EIGEN_STATIC_ASSERT_H</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/util/XprHelper.h#L15">XprHelper.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#ifndef EIGEN_XPRHELPER_H</span>
<span class="cp">#define EIGEN_XPRHELPER_H</span>

<span class="c1">// just a workaround because GCC seems to not really like empty structs</span>
<span class="hll"><span class="c1">// FIXME: gcc 4.3 generates bad code when strict-aliasing is enabled</span>
</span><span class="c1">// so currently we simply disable this optimization for gcc 4.3</span>
<span class="cp">#if EIGEN_COMP_GNUC &amp;&amp; !EIGEN_GNUC_AT(4,3)</span>
  <span class="cp">#define EIGEN_EMPTY_STRUCT_CTOR(X) \</span>
<span class="cp">    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE X() {} \</span>
<span class="cp">    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE X(const X&amp; ) {}</span>
<span class="cp">#else</span>
  <span class="cp">#define EIGEN_EMPTY_STRUCT_CTOR(X)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/util/XprHelper.h#L255">XprHelper.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>251
252
253
254
255
256
257
258
259
260
261
262</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">compute_matrix_flags</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">row_major_bit</span> <span class="o">=</span> <span class="n">Options</span><span class="o">&amp;</span><span class="n">RowMajor</span> <span class="o">?</span> <span class="nl">RowMajorBit</span> <span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
  <span class="k">public</span><span class="o">:</span>
<span class="hll">    <span class="c1">// FIXME currently we still have to handle DirectAccessBit at the expression level to handle DenseCoeffsBase&lt;&gt;</span>
</span>    <span class="c1">// and then propagate this information to the evaluator&#39;s flags.</span>
    <span class="c1">// However, I (Gael) think that DirectAccessBit should only matter at the evaluation stage.</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">DirectAccessBit</span> <span class="o">|</span> <span class="n">LvalueBit</span> <span class="o">|</span> <span class="n">NestByRefBit</span> <span class="o">|</span> <span class="n">row_major_bit</span> <span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">_Rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_Cols</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">size_at_compile_time</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h#L63">AutoDiffVector.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>59
60
61
62
63
64
65
66
67
68
69</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">const</span> <span class="n">CoeffType</span> <span class="nf">coeffRef</span><span class="p">(</span><span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">CoeffType</span><span class="p">(</span><span class="n">m_values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m_jacobian</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">));</span> <span class="p">}</span>

    <span class="n">Index</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_values</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>

<span class="hll">    <span class="c1">// FIXME here we could return an expression of the sum</span>
</span>    <span class="n">Scalar</span> <span class="nf">sum</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="cm">/*std::cerr &lt;&lt; &quot;sum \n\n&quot;;*/</span> <span class="cm">/*std::cerr &lt;&lt; m_jacobian.rowwise().sum() &lt;&lt; &quot;\n\n&quot;;*/</span> <span class="k">return</span> <span class="n">Scalar</span><span class="p">(</span><span class="n">m_values</span><span class="p">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">m_jacobian</span><span class="p">.</span><span class="n">rowwise</span><span class="p">().</span><span class="n">sum</span><span class="p">());</span> <span class="p">}</span>


    <span class="kr">inline</span> <span class="nf">AutoDiffVector</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="k">const</span> <span class="n">JacobianType</span><span class="o">&amp;</span> <span class="n">jac</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">m_values</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">m_jacobian</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span>
    <span class="p">{}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/EulerAngles/EulerAngles.h#L298">EulerAngles.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>294
295
296
297
298
299
300
301
302
303
304
305</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="p">}</span>

      <span class="cm">/*EulerAngles&amp; fromQuaternion(const QuaternionType&amp; q)</span>
<span class="cm">      {</span>
<span class="hll"><span class="cm">        // TODO: Implement it in a faster way for quaternions</span>
</span><span class="cm">        // According to http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToEuler/</span>
<span class="cm">        //  we can compute only the needed matrix cells and then convert to euler angles. (see ZYX example below)</span>
<span class="cm">        // Currently we compute all matrix cells from quaternion.</span>

<span class="cm">        // Special case only for ZYX</span>
<span class="cm">        //Scalar y2 = q.y() * q.y();</span>
<span class="cm">        //m_angles[0] = std::atan2(2*(q.w()*q.z() + q.x()*q.y()), (1 - 2*(y2 + q.z()*q.z())));</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/EulerAngles/EulerAngles.h#L319">EulerAngles.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>315
316
317
318
319
320
321
322
323
324
325
326</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">System</span><span class="o">::</span><span class="n">CalcEulerAngles</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>

<span class="hll">      <span class="c1">// TODO: Assign and construct from another EulerAngles (with different system)</span>
</span>
      <span class="cm">/** Set \c *this from a rotation. */</span>
      <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="o">&gt;</span>
      <span class="n">EulerAngles</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">RotationBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">rot</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System</span><span class="o">::</span><span class="n">CalcEulerAngles</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">rot</span><span class="p">.</span><span class="n">toRotationMatrix</span><span class="p">());</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/EulerAngles/EulerAngles.h#L328">EulerAngles.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>324
325
326
327
328
329
330
331
332
333
334</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">System</span><span class="o">::</span><span class="n">CalcEulerAngles</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">rot</span><span class="p">.</span><span class="n">toRotationMatrix</span><span class="p">());</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>

<span class="hll">      <span class="c1">// TODO: Support isApprox function</span>
</span>
      <span class="cm">/** \returns an equivalent 3x3 rotation matrix. */</span>
      <span class="n">Matrix3</span> <span class="n">toRotationMatrix</span><span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QuaternionType</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">toRotationMatrix</span><span class="p">();</span>
      <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/EulerAngles/EulerSystem.h#L21">EulerSystem.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">EulerAngles</span><span class="p">;</span>

  <span class="k">namespace</span> <span class="n">internal</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO: Check if already exists on the rest API</span>
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">Num</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsPositive</span> <span class="o">=</span> <span class="p">(</span><span class="n">Num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">Abs</span>
    <span class="p">{</span>
      <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">Num</span> <span class="p">};</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">Num</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/EulerAngles/EulerSystem.h#L178">EulerSystem.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>174
175
176
177
178
179
180
181
182
183
184</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">J</span> <span class="o">=</span> <span class="p">(</span><span class="n">AlphaAxisAbs</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">IsOdd</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">,</span>
      <span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">AlphaAxisAbs</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">IsOdd</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span>
    <span class="p">};</span>

<span class="hll">    <span class="c1">// TODO: Get @mat parameter in form that avoids double evaluation.</span>
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">CalcEulerAngles_imp</span><span class="p">(</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;::</span><span class="n">Scalar</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">res</span><span class="p">,</span> <span class="k">const</span> <span class="n">MatrixBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;&amp;</span> <span class="n">mat</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">true_type</span> <span class="cm">/*isTaitBryan*/</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">atan2</span><span class="p">;</span>
      <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">;</span>
      <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/FFT/ei_kissfft_impl.h#L391">ei_kissfft_impl.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>387
388
389
390
391
392
393
394
395
396
397</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="kr">inline</span>
    <span class="n">PlanData</span> <span class="o">&amp;</span> <span class="n">get_plan</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfft</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">inverse</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// TODO look for PlanKey(nfft, ! inverse) and conjugate the twiddles</span>
<span class="hll">      <span class="n">PlanData</span> <span class="o">&amp;</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">m_plans</span><span class="p">[</span> <span class="n">PlanKey</span><span class="p">(</span><span class="n">nfft</span><span class="p">,</span><span class="n">inverse</span><span class="p">)</span> <span class="p">];</span>
</span>      <span class="k">if</span> <span class="p">(</span> <span class="n">pd</span><span class="p">.</span><span class="n">m_twiddles</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">pd</span><span class="p">.</span><span class="n">make_twiddles</span><span class="p">(</span><span class="n">nfft</span><span class="p">,</span><span class="n">inverse</span><span class="p">);</span>
        <span class="n">pd</span><span class="p">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">nfft</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">pd</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h#L52">ConstrainedConjGrad.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>48
49
50
51
52
53
54
55
56
57
58
59</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="c1">// optimisable : copie de la ligne, precalcul de C * trans(C).</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">CMatrix</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">CMatrix</span><span class="o">::</span><span class="n">Index</span> <span class="n">Index</span><span class="p">;</span>
<span class="hll">  <span class="c1">// FIXME use sparse vectors ?</span>
</span>  <span class="k">typedef</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Dynamic</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">TmpVec</span><span class="p">;</span>

  <span class="n">Index</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">cols</span><span class="p">();</span>

  <span class="n">TmpVec</span> <span class="nf">d</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="n">e</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="n">l</span><span class="p">(</span><span class="n">cols</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="n">q</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="n">r</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
  <span class="n">Scalar</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">;</span>
  <span class="n">d</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h#L86">ConstrainedConjGrad.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>82
83
84
85
86
87
88
89
90
91
92
93</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span><span class="o">/</span><span class="n">rho_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">e</span><span class="p">;</span> <span class="c1">// l is the i-th row of CINV</span>
<span class="hll">    <span class="c1">// FIXME add a generic &quot;prune/filter&quot; expression for both dense and sparse object to sparse</span>
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">l</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="mf">1e-15</span><span class="p">)</span>
    <span class="n">tripletList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">l</span><span class="p">(</span><span class="n">j</span><span class="p">)));</span>


    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h#L148">ConstrainedConjGrad.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>144
145
146
147
148
149
150
151
152
153
154</pre></div></td><td class="code"><div class="highlight"><pre><span></span>          <span class="n">transition</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Scalar</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">CINV</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">dot</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bb</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="hll">          <span class="c1">// FIXME: we should allow that: z += -bb * C.row(i);</span>
</span>          <span class="k">for</span> <span class="p">(</span><span class="k">typename</span> <span class="n">CMatrix</span><span class="o">::</span><span class="n">InnerIterator</span> <span class="n">it</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">i</span><span class="p">);</span> <span class="n">it</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
            <span class="n">z</span><span class="p">.</span><span class="n">coeffRef</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">index</span><span class="p">())</span> <span class="o">-=</span> <span class="n">bb</span><span class="o">*</span><span class="n">it</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">else</span>
        <span class="n">satured</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/IterativeSolvers/DGMRES.h#L36">DGMRES.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  * \param perm gives the sorted sequence on output. Must be initialized with 0..n-1
  * \param ncut Put  the ncut smallest elements at the end of the vector
  * WARNING This is an expensive sort, so should be used only
  * for small size vectors
<span class="hll">  * TODO Use modified QuickSplit or std::nth_element to get the smallest values
</span>  */
template &lt;typename VectorType, typename IndexType&gt;
void sortWithPermutation (VectorType&amp; vec, IndexType&amp; perm, typename IndexType::Scalar&amp; ncut)
{
  eigen_assert(vec.size() == perm.size());
  bool flag;
  for (Index k  = 0; k &lt; ncut; k++)
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/IterativeSolvers/DGMRES.h#L326">DGMRES.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>322
323
324
325
326
327
328
329
330
331
332
333</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">m_V</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">tv1</span><span class="o">/</span><span class="n">coef</span><span class="p">;</span>
    <span class="n">m_H</span><span class="p">(</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span> <span class="o">=</span> <span class="n">coef</span><span class="p">;</span>
<span class="c1">//     m_Hes(it+1,it) = coef;</span>

<span class="hll">    <span class="c1">// FIXME Check for happy breakdown</span>
</span>
    <span class="c1">// Update Hessenberg matrix with Givens rotations</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">it</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">m_H</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">it</span><span class="p">).</span><span class="n">applyOnTheLeft</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">gr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">adjoint</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="c1">// Compute the new plane rotation</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/IterativeSolvers/DGMRES.h#L354">DGMRES.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>350
351
352
353
354
355
356
357
358
359
360
361</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>

  <span class="c1">// Compute the new coefficients by solving the least square problem</span>
<span class="c1">//   it++;</span>
<span class="hll">  <span class="c1">//FIXME  Check first if the matrix is singular ... zero diagonal</span>
</span>  <span class="n">DenseVector</span> <span class="n">nrs</span><span class="p">(</span><span class="n">m_restart</span><span class="p">);</span>
  <span class="n">nrs</span> <span class="o">=</span> <span class="n">m_H</span><span class="p">.</span><span class="n">topLeftCorner</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="n">it</span><span class="p">).</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Upper</span><span class="o">&gt;</span><span class="p">().</span><span class="n">solve</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="n">it</span><span class="p">));</span>

  <span class="c1">// Form the new solution</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m_isDeflInitialized</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">tv1</span> <span class="o">=</span> <span class="n">m_V</span><span class="p">.</span><span class="n">leftCols</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="o">*</span> <span class="n">nrs</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/IterativeSolvers/DGMRES.h#L497">DGMRES.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>493
494
495
496
497
498
499
500
501
502
503</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c1">// Factorize m_T into m_luT</span>
  <span class="n">m_luT</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">m_T</span><span class="p">.</span><span class="n">topLeftCorner</span><span class="p">(</span><span class="n">m_r</span><span class="p">,</span> <span class="n">m_r</span><span class="p">));</span>

  <span class="c1">//FIXME CHeck if the factorization was correctly done (nonsingular matrix)</span>
<span class="hll">  <span class="n">m_isDeflInitialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_MatrixType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Preconditioner</span><span class="o">&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">RhsType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DestType</span><span class="o">&gt;</span>
<span class="n">Index</span> <span class="n">DGMRES</span><span class="o">&lt;</span><span class="n">_MatrixType</span><span class="p">,</span> <span class="n">_Preconditioner</span><span class="o">&gt;::</span><span class="n">dgmresApplyDeflation</span><span class="p">(</span><span class="k">const</span> <span class="n">RhsType</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">DestType</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/IterativeSolvers/GMRES.h#L110">GMRES.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>106
107
108
109
110
111
112
113
114
115
116</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">v</span> <span class="o">=</span> <span class="n">VectorType</span><span class="o">::</span><span class="n">Unit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// apply Householder reflections H_{1} ... H_{k-1} to v</span>
    <span class="c1">// TODO: use a HouseholderSequence</span>
<span class="hll">    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span>      <span class="n">v</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">i</span><span class="p">).</span><span class="n">applyHouseholderOnTheLeft</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">tau</span><span class="p">.</span><span class="n">coeffRef</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">workspace</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// apply matrix M to v:  v = mat * v;</span>
    <span class="n">t</span><span class="p">.</span><span class="n">noalias</span><span class="p">()</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">*</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">precond</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/IterativeSolvers/GMRES.h#L120">GMRES.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>116
117
118
119
120
121
122
123
124
125
126
127</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">t</span><span class="p">.</span><span class="n">noalias</span><span class="p">()</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">*</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">precond</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

    <span class="c1">// apply Householder reflections H_{k-1} ... H_{1} to v</span>
<span class="hll">    <span class="c1">// TODO: use a HouseholderSequence</span>
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">i</span><span class="p">).</span><span class="n">applyHouseholderOnTheLeft</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">tau</span><span class="p">.</span><span class="n">coeffRef</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">workspace</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">k</span><span class="p">).</span><span class="n">norm</span><span class="p">()</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">restart</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/IterativeSolvers/Scaling.h#L69">Scaling.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>65
66
67
68
69
70
71
72
73
74
75</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="cm">/**</span>
<span class="cm">     * Compute the left and right diagonal matrices to scale the input matrix @p mat</span>
<span class="cm">     *</span>
<span class="cm">     * FIXME This algorithm will be modified such that the diagonal elements are permuted on the diagonal.</span>
<span class="hll"><span class="cm">     *</span>
</span><span class="cm">     * \sa LeftScaling() RightScaling()</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">compute</span> <span class="p">(</span><span class="k">const</span> <span class="n">MatrixType</span><span class="o">&amp;</span> <span class="n">mat</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mat</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h#L167">KroneckerTensorProduct.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>163
164
165
166
167
168
169
170
171
172
173
174</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">InnerIterator</span><span class="o">&lt;</span><span class="n">Rhs1Cleaned</span><span class="o">&gt;</span> <span class="n">RhsInnerIterator</span><span class="p">;</span>

  <span class="c1">// compute number of non-zeros per innervectors of dst</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO VectorXi is not necessarily big enough!</span>
</span>    <span class="n">VectorXi</span> <span class="n">nnzA</span> <span class="o">=</span> <span class="n">VectorXi</span><span class="o">::</span><span class="n">Zero</span><span class="p">(</span><span class="n">Dest</span><span class="o">::</span><span class="n">IsRowMajor</span> <span class="o">?</span> <span class="n">m_A</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_A</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">kA</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">kA</span> <span class="o">&lt;</span> <span class="n">m_A</span><span class="p">.</span><span class="n">outerSize</span><span class="p">();</span> <span class="o">++</span><span class="n">kA</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">LhsInnerIterator</span> <span class="n">itA</span><span class="p">(</span><span class="n">lhs1</span><span class="p">,</span><span class="n">kA</span><span class="p">);</span> <span class="n">itA</span><span class="p">;</span> <span class="o">++</span><span class="n">itA</span><span class="p">)</span>
        <span class="n">nnzA</span><span class="p">(</span><span class="n">Dest</span><span class="o">::</span><span class="n">IsRowMajor</span> <span class="o">?</span> <span class="n">itA</span><span class="p">.</span><span class="n">row</span><span class="p">()</span> <span class="o">:</span> <span class="n">itA</span><span class="p">.</span><span class="n">col</span><span class="p">())</span><span class="o">++</span><span class="p">;</span>

    <span class="n">VectorXi</span> <span class="n">nnzB</span> <span class="o">=</span> <span class="n">VectorXi</span><span class="o">::</span><span class="n">Zero</span><span class="p">(</span><span class="n">Dest</span><span class="o">::</span><span class="n">IsRowMajor</span> <span class="o">?</span> <span class="n">m_B</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_B</span><span class="p">.</span><span class="n">cols</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="n">kB</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">kB</span> <span class="o">&lt;</span> <span class="n">m_B</span><span class="p">.</span><span class="n">outerSize</span><span class="p">();</span> <span class="o">++</span><span class="n">kB</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/LevenbergMarquardt/LMpar.h#L64">LMpar.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>60
61
62
63
64
65
66
67
68
69
70
71</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="c1">//    const Index rank = qr.nonzeroPivots(); // exactly double(0.)</span>
    <span class="k">const</span> <span class="n">Index</span> <span class="n">rank</span> <span class="o">=</span> <span class="n">qr</span><span class="p">.</span><span class="n">rank</span><span class="p">();</span> <span class="c1">// use a threshold</span>
    <span class="n">wa1</span> <span class="o">=</span> <span class="n">qtb</span><span class="p">;</span>
    <span class="n">wa1</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">rank</span><span class="p">).</span><span class="n">setZero</span><span class="p">();</span>
<span class="hll">    <span class="c1">//FIXME There is no solve in place for sparse triangularView</span>
</span>    <span class="n">wa1</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">topLeftCorner</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span><span class="n">rank</span><span class="p">).</span><span class="k">template</span> <span class="n">triangularView</span><span class="o">&lt;</span><span class="n">Upper</span><span class="o">&gt;</span><span class="p">().</span><span class="n">solve</span><span class="p">(</span><span class="n">qtb</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="n">rank</span><span class="p">));</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">qr</span><span class="p">.</span><span class="n">colsPermutation</span><span class="p">()</span><span class="o">*</span><span class="n">wa1</span><span class="p">;</span>

    <span class="cm">/* initialize the iteration counter. */</span>
    <span class="cm">/* evaluate the function at the origin, and test */</span>
    <span class="cm">/* for acceptance of the gauss-newton direction. */</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h#L302">LevenbergMarquardt.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>298
299
300
301
302
303
304
305
306
307</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">m_wa1</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="n">m_wa2</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="n">m_wa3</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">m_wa4</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="n">m_fvec</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="c1">//FIXME Sparse Case : Allocate space for the jacobian</span>
<span class="hll">    <span class="n">m_fjac</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span><span class="c1">//     m_fjac.reserve(VectorXi::Constant(n,5)); // FIXME Find a better alternative</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_useExternalScaling</span><span class="p">)</span>
        <span class="n">m_diag</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">eigen_assert</span><span class="p">(</span> <span class="p">(</span><span class="o">!</span><span class="n">m_useExternalScaling</span> <span class="o">||</span> <span class="n">m_diag</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;When m_useExternalScaling is set, the caller must provide a valid &#39;m_diag&#39;&quot;</span><span class="p">);</span>
    <span class="n">m_qtf</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h#L66">MatrixFunction.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>62
63
64
65
66
67
68
69
70
71
72</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="o">&gt;</span>
<span class="n">MatrixType</span> <span class="n">MatrixFunctionAtomic</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">compute</span><span class="p">(</span><span class="k">const</span> <span class="n">MatrixType</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO: Use that A is upper triangular</span>
<span class="hll">  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">Real</span> <span class="n">RealScalar</span><span class="p">;</span>
</span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Index</span> <span class="n">Index</span><span class="p">;</span>
  <span class="n">Index</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span>
  <span class="n">Scalar</span> <span class="n">avgEival</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> <span class="n">Scalar</span><span class="p">(</span><span class="n">RealScalar</span><span class="p">(</span><span class="n">rows</span><span class="p">));</span>
  <span class="n">MatrixType</span> <span class="n">Ashifted</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">avgEival</span> <span class="o">*</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Identity</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">rows</span><span class="p">);</span>
  <span class="n">RealScalar</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">matrix_function_compute_mu</span><span class="p">(</span><span class="n">Ashifted</span><span class="p">);</span>
  <span class="n">MatrixType</span> <span class="n">F</span> <span class="o">=</span> <span class="n">m_f</span><span class="p">(</span><span class="n">avgEival</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Identity</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">rows</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/MatrixFunctions/MatrixPower.h#L30">MatrixPower.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span></span> * should not be changed in the meantime). It is the return type of
 * MatrixPower::operator() and related functions and most of the
 * time this is the only way it is used.
 */
<span class="hll">/* TODO This class is only used by MatrixPower, so it should be nested
</span> * into MatrixPower, like MatrixPower::ReturnValue. However, my
 * compiler complained about unused template parameter in the
 * following declaration in namespace internal.
 *
 * template&lt;typename MatrixType&gt;
 * struct traits&lt;MatrixPower&lt;MatrixType&gt;::ReturnValue&gt;;
 */
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h#L22">MatrixSquareRoot.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// post: sqrtT.block(i,i,2,2) is square root of T.block(i,i,2,2)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">MatrixType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ResultType</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">matrix_sqrt_quasi_triangular_2x2_diagonal_block</span><span class="p">(</span><span class="k">const</span> <span class="n">MatrixType</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">Index</span> <span class="n">i</span><span class="p">,</span> <span class="n">ResultType</span><span class="o">&amp;</span> <span class="n">sqrtT</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO: This case (2-by-2 blocks with complex conjugate eigenvalues) is probably hidden somewhere</span>
</span>  <span class="c1">//       in EigenSolver. If we expose it, we could call it directly from here.</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">MatrixType</span><span class="o">&gt;::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
  <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">block</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="k">template</span> <span class="n">block</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
  <span class="n">EigenSolver</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">es</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
  <span class="n">sqrtT</span><span class="p">.</span><span class="k">template</span> <span class="n">block</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
    <span class="o">=</span> <span class="p">(</span><span class="n">es</span><span class="p">.</span><span class="n">eigenvectors</span><span class="p">()</span> <span class="o">*</span> <span class="n">es</span><span class="p">.</span><span class="n">eigenvalues</span><span class="p">().</span><span class="n">cwiseSqrt</span><span class="p">().</span><span class="n">asDiagonal</span><span class="p">()</span> <span class="o">*</span> <span class="n">es</span><span class="p">.</span><span class="n">eigenvectors</span><span class="p">().</span><span class="n">inverse</span><span class="p">()).</span><span class="n">real</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h#L68">HybridNonLinearSolver.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>64
65
66
67
68
69
70
71
72
73
74</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">Scalar</span> <span class="n">epsfcn</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">FVectorType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Dynamic</span> <span class="o">&gt;</span> <span class="n">JacobianType</span><span class="p">;</span>
<span class="hll">    <span class="cm">/* TODO: if eigen provides a triangular storage, use it here */</span>
</span>    <span class="k">typedef</span> <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Dynamic</span> <span class="o">&gt;</span> <span class="n">UpperTriangularType</span><span class="p">;</span>

    <span class="n">HybridNonLinearSolverSpace</span><span class="o">::</span><span class="n">Status</span> <span class="n">hybrj1</span><span class="p">(</span>
            <span class="n">FVectorType</span>  <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">Scalar</span> <span class="n">tol</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">epsilon</span><span class="p">())</span>
            <span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h#L469">LevenbergMarquardt.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>465
466
467
468
469
470
471
472
473
474
475
476</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">}</span>
    <span class="n">permutation</span><span class="p">.</span><span class="n">setIdentity</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sing</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">wa2</span> <span class="o">=</span> <span class="n">fjac</span><span class="p">.</span><span class="n">colwise</span><span class="p">().</span><span class="n">blueNorm</span><span class="p">();</span>
<span class="hll">        <span class="c1">// TODO We have no unit test covering this code path, do not modify</span>
</span>        <span class="c1">// until it is carefully tested</span>
        <span class="n">ColPivHouseholderQR</span><span class="o">&lt;</span><span class="n">JacobianType</span><span class="o">&gt;</span> <span class="n">qrfac</span><span class="p">(</span><span class="n">fjac</span><span class="p">);</span>
        <span class="n">fjac</span> <span class="o">=</span> <span class="n">qrfac</span><span class="p">.</span><span class="n">matrixQR</span><span class="p">();</span>
        <span class="n">wa1</span> <span class="o">=</span> <span class="n">fjac</span><span class="p">.</span><span class="n">diagonal</span><span class="p">();</span>
        <span class="n">fjac</span><span class="p">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">=</span> <span class="n">qrfac</span><span class="p">.</span><span class="n">hCoeffs</span><span class="p">();</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="n">qrfac</span><span class="p">.</span><span class="n">colsPermutation</span><span class="p">();</span>
        <span class="c1">// TODO : avoid this:</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h#L476">LevenbergMarquardt.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>472
473
474
475
476
477
478
479
480
481
482
483</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">fjac</span> <span class="o">=</span> <span class="n">qrfac</span><span class="p">.</span><span class="n">matrixQR</span><span class="p">();</span>
        <span class="n">wa1</span> <span class="o">=</span> <span class="n">fjac</span><span class="p">.</span><span class="n">diagonal</span><span class="p">();</span>
        <span class="n">fjac</span><span class="p">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">=</span> <span class="n">qrfac</span><span class="p">.</span><span class="n">hCoeffs</span><span class="p">();</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="n">qrfac</span><span class="p">.</span><span class="n">colsPermutation</span><span class="p">();</span>
<span class="hll">        <span class="c1">// TODO : avoid this:</span>
</span>        <span class="k">for</span><span class="p">(</span><span class="n">Index</span> <span class="n">ii</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">ii</span><span class="o">&lt;</span> <span class="n">fjac</span><span class="p">.</span><span class="n">cols</span><span class="p">();</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="n">fjac</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">ii</span><span class="p">).</span><span class="n">segment</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">fjac</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span><span class="o">-</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*=</span> <span class="n">fjac</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span><span class="n">ii</span><span class="p">);</span> <span class="c1">// rescale vectors</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fjac</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">sum</span> <span class="o">+=</span> <span class="n">fjac</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">qtf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/NonLinearOptimization/dogleg.h#L51">dogleg.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>47
48
49
50
51
52
53
54
55
56
57
58</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">qnorm</span> <span class="o">=</span> <span class="n">diag</span><span class="p">.</span><span class="n">cwiseProduct</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">stableNorm</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">qnorm</span> <span class="o">&lt;=</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

<span class="hll">    <span class="c1">// TODO : this path is not tested by Eigen unit tests</span>
</span>
    <span class="cm">/* the gauss-newton direction is not acceptable. */</span>
    <span class="cm">/* next, calculate the scaled gradient direction. */</span>

    <span class="n">wa1</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">wa1</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">j</span><span class="p">)</span> <span class="o">+=</span> <span class="n">qrfac</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">).</span><span class="n">tail</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">qtb</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/NonLinearOptimization/dogleg.h#L73">dogleg.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>69
70
71
72
73
74
75
76
77
78
79</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="cm">/* calculate the point along the scaled gradient */</span>
    <span class="cm">/* at which the quadratic is minimized. */</span>
    <span class="n">wa1</span><span class="p">.</span><span class="n">array</span><span class="p">()</span> <span class="o">/=</span> <span class="p">(</span><span class="n">diag</span><span class="o">*</span><span class="n">gnorm</span><span class="p">).</span><span class="n">array</span><span class="p">();</span>
    <span class="c1">// TODO : once unit tests cover this part,:</span>
<span class="hll">    <span class="c1">// wa2 = qrfac.template triangularView&lt;Upper&gt;() * wa1;</span>
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">qrfac</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">wa1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">wa2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/NonLinearOptimization/qrsolv.h#L5">qrsolv.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

<span class="c1">// TODO : once qrsolv2 is removed, use ColPivHouseholderQR or PermutationMatrix instead of ipvt</span>
<span class="hll"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span>
</span><span class="kt">void</span> <span class="n">qrsolv</span><span class="p">(</span>
        <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Dynamic</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span>
        <span class="c1">// TODO : use a PermutationMatrix once lmpar is no more:</span>
        <span class="k">const</span> <span class="n">VectorXi</span> <span class="o">&amp;</span><span class="n">ipvt</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">diag</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">qtb</span><span class="p">,</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/NonLinearOptimization/qrsolv.h#L9">qrsolv.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// TODO : once qrsolv2 is removed, use ColPivHouseholderQR or PermutationMatrix instead of ipvt</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">qrsolv</span><span class="p">(</span>
        <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Dynamic</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span>
<span class="hll">        <span class="c1">// TODO : use a PermutationMatrix once lmpar is no more:</span>
</span>        <span class="k">const</span> <span class="n">VectorXi</span> <span class="o">&amp;</span><span class="n">ipvt</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">diag</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">qtb</span><span class="p">,</span>
        <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span>
        <span class="n">Matrix</span><span class="o">&lt;</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">sdiag</span><span class="p">)</span>

<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/NonLinearOptimization/r1mpyq.h#L5">r1mpyq.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>

<span class="c1">// TODO : move this to GivensQR once there&#39;s such a thing in Eigen</span>
<span class="hll">
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">r1mpyq</span><span class="p">(</span><span class="n">DenseIndex</span> <span class="n">m</span><span class="p">,</span> <span class="n">DenseIndex</span> <span class="n">n</span><span class="p">,</span> <span class="n">Scalar</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JacobiRotation</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v_givens</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JacobiRotation</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">w_givens</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">DenseIndex</span> <span class="n">Index</span><span class="p">;</span>

    <span class="cm">/*     apply the first set of givens rotations to a. */</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h#L75">NumericalDiff.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>71
72
73
74
75
76
77
78
79
80
81
82</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="k">const</span> <span class="k">typename</span> <span class="n">InputType</span><span class="o">::</span><span class="n">Index</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_x</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">const</span> <span class="n">Scalar</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(((</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">)(</span><span class="n">epsfcn</span><span class="p">,</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">epsilon</span><span class="p">()</span> <span class="p">)));</span>
        <span class="n">ValueType</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">;</span>
        <span class="n">InputType</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_x</span><span class="p">;</span>
<span class="hll">        <span class="c1">// TODO : we should do this only if the size is not already known</span>
</span>        <span class="n">val1</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">Functor</span><span class="o">::</span><span class="n">values</span><span class="p">());</span>
        <span class="n">val2</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">Functor</span><span class="o">::</span><span class="n">values</span><span class="p">());</span>

        <span class="c1">// initialization</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nl">Forward</span><span class="p">:</span>
                <span class="c1">// compute f(x)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h#L339">SkylineInplaceLU.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>335
336
337
338
339
340
341
342
343</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="k">while</span> <span class="p">(</span><span class="n">uIt</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span><span class="o">-&gt;</span><span class="n">coeffRef</span><span class="p">(</span><span class="n">uIt</span><span class="p">.</span><span class="n">row</span><span class="p">())</span> <span class="o">-=</span> <span class="n">x_col</span> <span class="o">*</span> <span class="n">uIt</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
            <span class="c1">//TODO : introduce --operator</span>
            <span class="n">uIt</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="hll">        <span class="p">}</span>
</span>

    <span class="p">}</span>
    <span class="n">x</span><span class="o">-&gt;</span><span class="n">coeffRef</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">coeff</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">m_lu</span><span class="p">.</span><span class="n">coeffDiag</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/Skyline/SkylineMatrix.h#L583">SkylineMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>579
580
581
582
583
584
585
586
587
588
589
590</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">m_data</span><span class="p">.</span><span class="n">squeeze</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">prune</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">reference</span><span class="p">,</span> <span class="n">RealScalar</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">dummy_precision</span><span class="o">&lt;</span><span class="n">RealScalar</span> <span class="o">&gt;</span> <span class="p">())</span> <span class="p">{</span>
<span class="hll">        <span class="c1">//TODO</span>
</span>    <span class="p">}</span>

    <span class="cm">/** Resizes the matrix to a \a rows x \a cols matrix and initializes it to zero</span>
<span class="cm">     * \sa resizeNonZeros(Index), reserve(), setZero()</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="n">resize</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">Index</span> <span class="n">diagSize</span> <span class="o">=</span> <span class="n">rows</span> <span class="o">&gt;</span> <span class="n">cols</span> <span class="o">?</span> <span class="nl">cols</span> <span class="p">:</span> <span class="n">rows</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/Skyline/SkylineMatrix.h#L677">SkylineMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>673
674
675
676
677
678
679
680
681
682
683</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherDerived</span><span class="o">&gt;</span>
            <span class="kr">inline</span> <span class="n">SkylineMatrix</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SkylineMatrixBase</span><span class="o">&lt;</span><span class="n">OtherDerived</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">bool</span> <span class="n">needToTranspose</span> <span class="o">=</span> <span class="p">(</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">RowMajorBit</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">OtherDerived</span><span class="o">::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">RowMajorBit</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">needToTranspose</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">            <span class="c1">//         TODO</span>
</span>            <span class="c1">//            return *this;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// there is no special optimization</span>
            <span class="k">return</span> <span class="n">SkylineMatrixBase</span><span class="o">&lt;</span><span class="n">SkylineMatrix</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">derived</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h#L148">SkylineMatrixBase.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>144
145
146
147
148
149
150
151
152
153
154</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="k">return</span> <span class="nf">derived</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">SkylineMatrixBase</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_isRValue</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="cm">/* TODO check flags */</span>
</span>    <span class="p">}</span>

    <span class="kr">inline</span> <span class="n">Derived</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="k">operator</span><span class="o">=&lt;</span><span class="n">Derived</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">other</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">derived</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h#L169">SkylineMatrixBase.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>165
166
167
168
169
170
171
172
173
174
175
176</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherDerived</span><span class="o">&gt;</span>
            <span class="kr">inline</span> <span class="n">Derived</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SkylineMatrixBase</span><span class="o">&lt;</span><span class="n">OtherDerived</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="c1">//TODO</span>
</span>    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lhs</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rhs</span><span class="o">&gt;</span>
            <span class="kr">inline</span> <span class="n">Derived</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SkylineProduct</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="p">,</span> <span class="n">Rhs</span><span class="p">,</span> <span class="n">SkylineTimeSkylineProduct</span><span class="o">&gt;&amp;</span> <span class="n">product</span><span class="p">);</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">SkylineMatrixBase</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">derived</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/Skyline/SkylineStorage.h#L198">SkylineStorage.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>194
195
196
197
198
199
200
201
202
203
204
205</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">memset</span><span class="p">(</span><span class="n">m_lowerProfile</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m_diagSize</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">Index</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">prune</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">reference</span><span class="p">,</span> <span class="n">RealScalar</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">dummy_precision</span><span class="o">&lt;</span><span class="n">RealScalar</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
<span class="hll">        <span class="c1">//TODO</span>
</span>    <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>

    <span class="kr">inline</span> <span class="kt">void</span> <span class="n">reallocate</span><span class="p">(</span><span class="n">Index</span> <span class="n">diagSize</span><span class="p">,</span> <span class="n">Index</span> <span class="n">upperProfileSize</span><span class="p">,</span> <span class="n">Index</span> <span class="n">lowerProfileSize</span><span class="p">,</span> <span class="n">Index</span> <span class="n">upperSize</span><span class="p">,</span> <span class="n">Index</span> <span class="n">lowerSize</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">Scalar</span><span class="o">*</span> <span class="n">diag</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scalar</span><span class="p">[</span><span class="n">diagSize</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h#L512">BlockSparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>508
509
510
511
512
513
514
515
516
517
518
519</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="p">{</span>
        <span class="c1">//Browse each outer block</span>

        <span class="c1">//First, copy and save the indices of nonzero blocks</span>
<span class="hll">        <span class="c1">//FIXME : find a way to avoid this ...</span>
</span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nzBlockIdx</span><span class="p">;</span>
        <span class="k">typename</span> <span class="n">MatrixType</span><span class="o">::</span><span class="n">InnerIterator</span> <span class="n">it</span><span class="p">(</span><span class="n">blockPattern</span><span class="p">,</span> <span class="n">bj</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">it</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">nzBlockIdx</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">index</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">nzBlockIdx</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nzBlockIdx</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h#L601">BlockSparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>597
598
599
600
601
602
603
604
605
606
607
608</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">{</span>
      <span class="n">eigen_assert</span><span class="p">((</span><span class="n">m_innerBSize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m_outerBSize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
          <span class="s">&quot;TRYING TO RESERVE ZERO-SIZE MATRICES, CALL resize() first&quot;</span><span class="p">);</span>

<span class="hll">      <span class="c1">//FIXME Should free if already allocated</span>
</span>      <span class="n">m_outerIndex</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StorageIndex</span><span class="p">[</span><span class="n">m_outerBSize</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

      <span class="n">m_nonzerosblocks</span> <span class="o">=</span> <span class="n">nonzerosblocks</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">m_blockSize</span> <span class="o">!=</span> <span class="n">Dynamic</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">m_nonzeros</span> <span class="o">=</span> <span class="n">nonzerosblocks</span> <span class="o">*</span> <span class="p">(</span><span class="n">m_blockSize</span> <span class="o">*</span> <span class="n">m_blockSize</span><span class="p">);</span>
        <span class="n">m_blockPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h#L628">BlockSparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>624
625
626
627
628
629
630
631
632
633
634
635</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      * The InputIterator class should provide the functions row(), col() and value()
      *
      * \note For fixed-size blocks, call setBlockSize() before this function.
      *
<span class="hll">      * FIXME Do not accept duplicates
</span>      */
    template&lt;typename InputIterator&gt;
    void setFromTriplets(const InputIterator&amp; begin, const InputIterator&amp; end)
    {
      eigen_assert((m_innerBSize!=0 &amp;&amp; m_outerBSize !=0) &amp;&amp; &quot;ZERO BLOCKS, PLEASE CALL resize() before&quot;);

      /* First, sort the triplet list
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h#L636">BlockSparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>632
633
634
635
636
637
638
639
640
641
642
643</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="p">{</span>
      <span class="n">eigen_assert</span><span class="p">((</span><span class="n">m_innerBSize</span><span class="o">!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m_outerBSize</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;ZERO BLOCKS, PLEASE CALL resize() before&quot;</span><span class="p">);</span>

      <span class="cm">/* First, sort the triplet list</span>
<span class="hll"><span class="cm">        * FIXME This can be unnecessarily expensive since only the inner indices have to be sorted</span>
</span><span class="cm">        * The best approach is like in SparseMatrix::setFromTriplets()</span>
<span class="cm">        */</span>
      <span class="n">internal</span><span class="o">::</span><span class="n">TripletComp</span><span class="o">&lt;</span><span class="n">InputIterator</span><span class="p">,</span> <span class="n">IsColMajor</span><span class="o">&gt;</span> <span class="n">tripletcomp</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">tripletcomp</span><span class="p">);</span>

      <span class="cm">/* Count the number of rows and column blocks,</span>
<span class="cm">       * and the number of nonzero blocks per outer dimension</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h#L824">BlockSparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>820
821
822
823
824
825
826
827
828
829
830
831</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="k">return</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">BlockScalar</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">m_values</span><span class="p">[</span><span class="n">blockPtr</span><span class="p">(</span><span class="n">offset</span><span class="p">)]),</span> <span class="n">rsize</span><span class="p">,</span> <span class="n">csize</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span>
<span class="hll">        <span class="c1">//FIXME the block does not exist, Insert it !!!!!!!!!</span>
</span>        <span class="n">eigen_assert</span><span class="p">(</span><span class="s">&quot;DYNAMIC INSERTION IS NOT YET SUPPORTED&quot;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">      * \returns the value of the (i,j) block as an Eigen Dense Matrix</span>
<span class="cm">      */</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h#L1006">BlockSparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1002
1003
1004
1005
1006
1007
1008
1009
1010
1011
1012
1013</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="c1">// block row index</span>
    <span class="kr">inline</span> <span class="n">Index</span> <span class="nf">row</span><span class="p">()</span> <span class="k">const</span>  <span class="p">{</span><span class="k">return</span> <span class="n">index</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// block column index</span>
    <span class="kr">inline</span> <span class="n">Index</span> <span class="nf">col</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">outer</span><span class="p">();</span> <span class="p">}</span>
<span class="hll">    <span class="c1">// FIXME Number of rows in the current block</span>
</span>    <span class="kr">inline</span> <span class="n">Index</span> <span class="nf">rows</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">m_mat</span><span class="p">.</span><span class="n">m_blockSize</span><span class="o">==</span><span class="n">Dynamic</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">m_mat</span><span class="p">.</span><span class="n">m_innerOffset</span><span class="p">[</span><span class="n">index</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m_mat</span><span class="p">.</span><span class="n">m_innerOffset</span><span class="p">[</span><span class="n">index</span><span class="p">()])</span> <span class="o">:</span> <span class="n">m_mat</span><span class="p">.</span><span class="n">m_blockSize</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// Number of columns in the current block ...</span>
    <span class="kr">inline</span> <span class="n">Index</span> <span class="nf">cols</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">m_mat</span><span class="p">.</span><span class="n">m_blockSize</span><span class="o">==</span><span class="n">Dynamic</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">m_mat</span><span class="p">.</span><span class="n">m_outerOffset</span><span class="p">[</span><span class="n">m_outer</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">m_mat</span><span class="p">.</span><span class="n">m_outerOffset</span><span class="p">[</span><span class="n">m_outer</span><span class="p">])</span> <span class="o">:</span> <span class="n">m_mat</span><span class="p">.</span><span class="n">m_blockSize</span><span class="p">;}</span>
    <span class="kr">inline</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">m_id</span> <span class="o">&lt;</span> <span class="n">m_end</span><span class="p">);</span> <span class="p">}</span>

  <span class="k">protected</span><span class="o">:</span>
    <span class="k">const</span> <span class="n">BlockSparseMatrix</span><span class="o">&lt;</span><span class="n">_Scalar</span><span class="p">,</span> <span class="n">_BlockAtCompileTime</span><span class="p">,</span> <span class="n">_Options</span><span class="p">,</span> <span class="n">StorageIndex</span><span class="o">&gt;&amp;</span> <span class="n">m_mat</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h#L63">DynamicSparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>59
60
61
62
63
64
65
66
67
68
69
70</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">typedef</span> <span class="n">SparseMatrixBase</span><span class="o">&lt;</span><span class="n">DynamicSparseMatrix</span><span class="o">&gt;</span> <span class="n">Base</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">convert_index</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">EIGEN_SPARSE_PUBLIC_INTERFACE</span><span class="p">(</span><span class="n">DynamicSparseMatrix</span><span class="p">)</span>
<span class="hll">    <span class="c1">// FIXME: why are these operator already alvailable ???</span>
</span>    <span class="c1">// EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR(DynamicSparseMatrix, +=)</span>
    <span class="c1">// EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR(DynamicSparseMatrix, -=)</span>
    <span class="k">typedef</span> <span class="n">MappedSparseMatrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">Flags</span><span class="o">&gt;</span> <span class="n">Map</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">IsRowMajor</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">;</span>
    <span class="k">enum</span> <span class="p">{</span>
      <span class="n">Options</span> <span class="o">=</span> <span class="n">_Options</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h#L217">DynamicSparseMatrix.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>213
214
215
216
217
218
219
220
221
222
223
224</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="k">const</span> <span class="n">Index</span> <span class="n">innerSize</span> <span class="o">=</span> <span class="n">IsRowMajor</span> <span class="o">?</span> <span class="nl">cols</span> <span class="p">:</span> <span class="n">rows</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">m_innerSize</span><span class="o">&gt;</span><span class="n">innerSize</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="c1">// remove all coefficients with innerCoord&gt;=innerSize</span>
<span class="hll">        <span class="c1">// TODO</span>
</span>        <span class="c1">//std::cerr &lt;&lt; &quot;not implemented yet\n&quot;;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">m_data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">outerSize</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">m_data</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">outerSize</span><span class="p">);</span>
      <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h#L1390">SpecialFunctionsImpl.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1386
1387
1388
1389
1390
1391
1392
1393
1394
1395
1396
1397</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">s</span> <span class="o">+=</span> <span class="n">t1</span><span class="p">;</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">ai</span><span class="p">;</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">numext</span><span class="o">::</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="hll">    <span class="c1">// TODO: gamma() is not directly implemented in Eigen.</span>
</span>    <span class="cm">/*</span>
<span class="cm">    if ((a + b) &lt; maxgam &amp;&amp; numext::abs(u) &lt; maxlog) {</span>
<span class="cm">      t = gamma(a + b) / (gamma(a) * gamma(b));</span>
<span class="cm">      s = s * t * pow(x, a);</span>
<span class="cm">    } else {</span>
<span class="cm">    */</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">lgamma_impl</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">run</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">lgamma_impl</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">run</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h#L1469">SpecialFunctionsImpl.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1465
1466
1467
1468
1469
1470
1471
1472
1473
1474
1475
1476</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        x  (1-x)   | (a+b) / ( a | (a) | (b) ) .   */

    y = a * numext::log(x);
    t = b * numext::log(xc);
<span class="hll">    // TODO: gamma is not directly implemented in Eigen.
</span>    /*
    if ((a + b) &lt; maxgam &amp;&amp; numext::abs(y) &lt; maxlog &amp;&amp; numext::abs(t) &lt; maxlog)
    {
      t = pow(xc, b);
      t *= pow(x, a);
      t /= a;
      t *= w;
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AVX/Complex.h#L86">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>82
83
84
85
86
87
88
89
90
91
92
93</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4cf</span> <span class="n">ploaddup</span><span class="o">&lt;</span><span class="n">Packet4cf</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;*</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// FIXME The following might be optimized using _mm256_movedup_pd</span>
</span>  <span class="n">Packet2cf</span> <span class="n">a</span> <span class="o">=</span> <span class="n">ploaddup</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="o">&gt;</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
  <span class="n">Packet2cf</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ploaddup</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="o">&gt;</span><span class="p">(</span><span class="n">from</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span>  <span class="nf">Packet4cf</span><span class="p">(</span><span class="n">_mm256_insertf128_ps</span><span class="p">(</span><span class="n">_mm256_castps128_ps256</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">v</span><span class="p">),</span> <span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">pstore</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;*</span> <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet4cf</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="n">EIGEN_DEBUG_ALIGNED_STORE</span> <span class="n">pstore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numext</span><span class="o">::</span><span class="n">real_ref</span><span class="p">(</span><span class="o">*</span><span class="n">to</span><span class="p">),</span> <span class="n">from</span><span class="p">.</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">pstoreu</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;*</span> <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet4cf</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="n">EIGEN_DEBUG_UNALIGNED_STORE</span> <span class="n">pstoreu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numext</span><span class="o">::</span><span class="n">real_ref</span><span class="p">(</span><span class="o">*</span><span class="n">to</span><span class="p">),</span> <span class="n">from</span><span class="p">.</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AVX/MathFunctions.h#L117">MathFunctions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>113
114
115
116
117
118
119
120
121
122
123
124</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// Natural logarithm</span>
<span class="c1">// Computes log(x) as log(2^e * m) = C*e + log(m), where the constant C =log(2)</span>
<span class="c1">// and m is in the range [sqrt(1/2),sqrt(2)). In this range, the logarithm can</span>
<span class="c1">// be easily approximated by a polynomial centered on m=1 for stability.</span>
<span class="hll"><span class="c1">// TODO(gonnet): Further reduce the interval allowing for lower-degree</span>
</span><span class="c1">//               polynomial interpolants -&gt; ... -&gt; profit!</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="n">EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS</span> <span class="n">EIGEN_UNUSED</span> <span class="n">Packet8f</span>
<span class="n">plog</span><span class="o">&lt;</span><span class="n">Packet8f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet8f</span><span class="o">&amp;</span> <span class="n">_x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Packet8f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_x</span><span class="p">;</span>
  <span class="n">_EIGEN_DECLARE_CONST_Packet8f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
  <span class="n">_EIGEN_DECLARE_CONST_Packet8f</span><span class="p">(</span><span class="n">half</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AVX/MathFunctions.h#L249">MathFunctions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>245
246
247
248
249
250
251
252
253
254
255
256</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#endif</span>

  <span class="n">Packet8f</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">pmul</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

<span class="hll">  <span class="c1">// TODO(gonnet): Split into odd/even polynomials and try to exploit</span>
</span>  <span class="c1">//               instruction-level parallelism.</span>
  <span class="n">Packet8f</span> <span class="n">y</span> <span class="o">=</span> <span class="n">p8f_cephes_exp_p0</span><span class="p">;</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p8f_cephes_exp_p1</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p8f_cephes_exp_p2</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p8f_cephes_exp_p3</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p8f_cephes_exp_p4</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p8f_cephes_exp_p5</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AVX/MathFunctions.h#L335">MathFunctions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>331
332
333
334
335
336
337
338
339
340
341
342</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">qx</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">p4d_cephes_exp_q2</span><span class="p">);</span>
  <span class="n">qx</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">p4d_cephes_exp_q3</span><span class="p">);</span>

  <span class="c1">// I don&#39;t really get this bit, copied from the SSE2 routines, so...</span>
<span class="hll">  <span class="c1">// TODO(gonnet): Figure out what is going on here, perhaps find a better</span>
</span>  <span class="c1">// rational interpolant?</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_div_pd</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">psub</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">px</span><span class="p">));</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">p4d_2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p4d_1</span><span class="p">);</span>

  <span class="c1">// Build e=2^n by constructing the exponents in a 128-bit vector and</span>
  <span class="c1">// shifting them to where they belong in double-precision values.</span>
  <span class="kr">__m128i</span> <span class="n">emm0</span> <span class="o">=</span> <span class="n">_mm256_cvtpd_epi32</span><span class="p">(</span><span class="n">fx</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AVX/PacketMath.h#L224">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>220
221
222
223
224
225
226
227
228
229
230</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// Loads 4 floats from memory a returns the packet {a0, a0  a1, a1, a2, a2, a3, a3}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet8f</span> <span class="n">ploaddup</span><span class="o">&lt;</span><span class="n">Packet8f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO try to find a way to avoid the need of a temporary register</span>
<span class="hll"><span class="c1">//   Packet8f tmp  = _mm256_castps128_ps256(_mm_loadu_ps(from));</span>
</span><span class="c1">//   tmp = _mm256_insertf128_ps(tmp, _mm_movehl_ps(_mm256_castps256_ps128(tmp),_mm256_castps256_ps128(tmp)), 1);</span>
<span class="c1">//   return _mm256_unpacklo_ps(tmp,tmp);</span>

  <span class="c1">// _mm256_insertf128_ps is very slow on Haswell, thus:</span>
  <span class="n">Packet8f</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">_mm256_broadcast_ps</span><span class="p">((</span><span class="k">const</span> <span class="kr">__m128</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">);</span>
  <span class="c1">// mimic an &quot;inplace&quot; permutation of the lower 128bits using a blend</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AVX/PacketMath.h#L357">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>353
354
355
356
357
358
359
360
361
362
363</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">return</span> <span class="nf">_mm256_and_pd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// preduxp should be ok</span>
<span class="hll"><span class="c1">// FIXME: why is this ok? why isn&#39;t the simply implementation working as expected?</span>
</span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet8f</span> <span class="n">preduxp</span><span class="o">&lt;</span><span class="n">Packet8f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet8f</span><span class="o">*</span> <span class="n">vecs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__m256</span> <span class="n">hsum1</span> <span class="o">=</span> <span class="n">_mm256_hadd_ps</span><span class="p">(</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">__m256</span> <span class="n">hsum2</span> <span class="o">=</span> <span class="n">_mm256_hadd_ps</span><span class="p">(</span><span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vecs</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
    <span class="n">__m256</span> <span class="n">hsum3</span> <span class="o">=</span> <span class="n">_mm256_hadd_ps</span><span class="p">(</span><span class="n">vecs</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">vecs</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
    <span class="n">__m256</span> <span class="n">hsum4</span> <span class="o">=</span> <span class="n">_mm256_hadd_ps</span><span class="p">(</span><span class="n">vecs</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">vecs</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AVX512/MathFunctions.h#L163">MathFunctions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>159
160
161
162
163
164
165
166
167
168
169
170</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">_EIGEN_DECLARE_CONST_Packet16f</span><span class="p">(</span><span class="n">nln2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6931471805599453f</span><span class="p">);</span>
  <span class="n">Packet16f</span> <span class="n">r</span> <span class="o">=</span> <span class="n">_mm512_fmadd_ps</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p16f_nln2</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">Packet16f</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">pmul</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

<span class="hll">  <span class="c1">// TODO(gonnet): Split into odd/even polynomials and try to exploit</span>
</span>  <span class="c1">//               instruction-level parallelism.</span>
  <span class="n">Packet16f</span> <span class="n">y</span> <span class="o">=</span> <span class="n">p16f_cephes_exp_p0</span><span class="p">;</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p16f_cephes_exp_p1</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p16f_cephes_exp_p2</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p16f_cephes_exp_p3</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p16f_cephes_exp_p4</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p16f_cephes_exp_p5</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AVX512/MathFunctions.h#L237">MathFunctions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>233
234
235
236
237
238
239
240
241
242
243
244</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">qx</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">p8d_cephes_exp_q2</span><span class="p">);</span>
  <span class="n">qx</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">p8d_cephes_exp_q3</span><span class="p">);</span>

  <span class="c1">// I don&#39;t really get this bit, copied from the SSE2 routines, so...</span>
<span class="hll">  <span class="c1">// TODO(gonnet): Figure out what is going on here, perhaps find a better</span>
</span>  <span class="c1">// rational interpolant?</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">_mm512_div_pd</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">psub</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">px</span><span class="p">));</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">pmadd</span><span class="p">(</span><span class="n">p8d_2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p8d_1</span><span class="p">);</span>

  <span class="c1">// Build e=2^n.</span>
  <span class="k">const</span> <span class="n">Packet8d</span> <span class="n">e</span> <span class="o">=</span> <span class="n">_mm512_castsi512_pd</span><span class="p">(</span><span class="n">_mm512_slli_epi64</span><span class="p">(</span>
      <span class="n">_mm512_add_epi64</span><span class="p">(</span><span class="n">_mm512_cvtpd_epi64</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">_mm512_set1_epi64</span><span class="p">(</span><span class="mi">1023</span><span class="p">)),</span> <span class="mi">52</span><span class="p">));</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AVX512/PacketMath.h#L85">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>81
82
83
84
85
86
87
88
89
90
91
92</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">HasDiv</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="hll"><span class="cm">/* TODO Implement AVX512 for integers</span>
</span><span class="cm">template&lt;&gt; struct packet_traits&lt;int&gt;    : default_packet_traits</span>
<span class="cm">{</span>
<span class="cm">  typedef Packet16i type;</span>
<span class="cm">  enum {</span>
<span class="cm">    Vectorizable = 1,</span>
<span class="cm">    AlignedOnScalar = 1,</span>
<span class="cm">    size=8</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AltiVec/Complex.h#L231">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>227
228
229
230
231
232
233
234
235
236
237
238</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">EIGEN_MAKE_CONJ_HELPER_CPLX_REAL</span><span class="p">(</span><span class="n">Packet2cf</span><span class="p">,</span><span class="n">Packet4f</span><span class="p">)</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2cf</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO optimize it for AltiVec</span>
</span>  <span class="n">Packet2cf</span> <span class="n">res</span> <span class="o">=</span> <span class="n">conj_helper</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="p">,</span><span class="n">Packet2cf</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">Packet4f</span> <span class="n">s</span> <span class="o">=</span> <span class="n">pmul</span><span class="o">&lt;</span><span class="n">Packet4f</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">Packet2cf</span><span class="p">(</span><span class="n">pdiv</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">padd</span><span class="o">&lt;</span><span class="n">Packet4f</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">vec_perm</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p16uc_COMPLEX32_REV</span><span class="p">))));</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2cf</span> <span class="n">pcplxflip</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AltiVec/Complex.h#L366">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>362
363
364
365
366
367
368
369
370
371
372
373</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">palign_impl</span><span class="o">&lt;</span><span class="n">Offset</span><span class="p">,</span><span class="n">Packet1cd</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="cm">/*first*/</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="cm">/*second*/</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME is it sure we never have to align a Packet1cd?</span>
</span>    <span class="c1">// Even though a std::complex&lt;double&gt; has 16 bytes, it is not necessarily aligned on a 16 bytes boundary...</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">conj_helper</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="p">,</span> <span class="n">Packet1cd</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pmadd</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/AltiVec/Complex.h#L408">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>404
405
406
407
408
409
410
411
412
413
414
415</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">EIGEN_MAKE_CONJ_HELPER_CPLX_REAL</span><span class="p">(</span><span class="n">Packet1cd</span><span class="p">,</span><span class="n">Packet2d</span><span class="p">)</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO optimize it for AltiVec</span>
</span>  <span class="n">Packet1cd</span> <span class="n">res</span> <span class="o">=</span> <span class="n">conj_helper</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="p">,</span><span class="n">Packet1cd</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
  <span class="n">Packet2d</span> <span class="n">s</span> <span class="o">=</span> <span class="n">pmul</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">Packet1cd</span><span class="p">(</span><span class="n">pdiv</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">padd</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">vec_perm</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p16uc_REVERSE64</span><span class="p">))));</span>
<span class="p">}</span>

<span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pcplxflip</span><span class="cm">/*&lt;Packet1cd&gt;*/</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/NEON/Complex.h#L272">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>268
269
270
271
272
273
274
275
276
277
278</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">EIGEN_MAKE_CONJ_HELPER_CPLX_REAL</span><span class="p">(</span><span class="n">Packet2cf</span><span class="p">,</span><span class="n">Packet4f</span><span class="p">)</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2cf</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO optimize it for NEON</span>
</span>  <span class="n">Packet2cf</span> <span class="n">res</span> <span class="o">=</span> <span class="n">conj_helper</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="p">,</span><span class="n">Packet2cf</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
  <span class="n">Packet4f</span> <span class="n">s</span><span class="p">,</span> <span class="n">rev_s</span><span class="p">;</span>

  <span class="c1">// this computes the norm</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">vmulq_f32</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
  <span class="n">rev_s</span> <span class="o">=</span> <span class="n">vrev64q_f32</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/NEON/Complex.h#L423">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>419
420
421
422
423
424
425
426
427
428
429
430</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">palign_impl</span><span class="o">&lt;</span><span class="n">Offset</span><span class="p">,</span><span class="n">Packet1cd</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="cm">/*first*/</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="cm">/*second*/</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME is it sure we never have to align a Packet1cd?</span>
</span>    <span class="c1">// Even though a std::complex&lt;double&gt; has 16 bytes, it is not necessarily aligned on a 16 bytes boundary...</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">conj_helper</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="p">,</span> <span class="n">Packet1cd</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pmadd</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/NEON/Complex.h#L465">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>461
462
463
464
465
466
467
468
469
470
471</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">EIGEN_MAKE_CONJ_HELPER_CPLX_REAL</span><span class="p">(</span><span class="n">Packet1cd</span><span class="p">,</span><span class="n">Packet2d</span><span class="p">)</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO optimize it for NEON</span>
</span>  <span class="n">Packet1cd</span> <span class="n">res</span> <span class="o">=</span> <span class="n">conj_helper</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="p">,</span><span class="n">Packet1cd</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
  <span class="n">Packet2d</span> <span class="n">s</span> <span class="o">=</span> <span class="n">pmul</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
  <span class="n">Packet2d</span> <span class="n">rev_s</span> <span class="o">=</span> <span class="n">preverse</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

  <span class="k">return</span> <span class="nf">Packet1cd</span><span class="p">(</span><span class="n">pdiv</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">padd</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">rev_s</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/NEON/PacketMath.h#L112">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>108
109
110
111
112
113
114
115
116
117
118
119</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">HasHalfPacket</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="c1">// Packet2f intrinsics not implemented yet</span>

    <span class="n">HasDiv</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="hll">    <span class="c1">// FIXME check the Has*</span>
</span>    <span class="n">HasSin</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">HasCos</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">HasLog</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">HasExp</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">HasSqrt</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/NEON/PacketMath.h#L129">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>125
126
127
128
129
130
131
132
133
134
135
136</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">Vectorizable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">AlignedOnScalar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">HasHalfPacket</span><span class="o">=</span><span class="mi">0</span> <span class="c1">// Packet2i intrinsics not implemented yet</span>
<span class="hll">    <span class="c1">// FIXME check the Has*</span>
</span>  <span class="p">};</span>
<span class="p">};</span>

<span class="cp">#if EIGEN_GNUC_AT_MOST(4,4) &amp;&amp; !EIGEN_COMP_LLVM</span>
<span class="c1">// workaround gcc 4.2, 4.3 and 4.4 compilatin issue</span>
<span class="n">EIGEN_STRONG_INLINE</span> <span class="n">float32x4_t</span> <span class="nf">vld1q_f32</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">::</span><span class="n">vld1q_f32</span><span class="p">((</span><span class="k">const</span> <span class="n">float32_t</span><span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
<span class="n">EIGEN_STRONG_INLINE</span> <span class="n">float32x2_t</span> <span class="nf">vld1_f32</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">::</span><span class="n">vld1_f32</span> <span class="p">((</span><span class="k">const</span> <span class="n">float32_t</span><span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/NEON/PacketMath.h#L341">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>337
338
339
340
341
342
343
344
345
346</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">prefetch</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span>  <span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">*</span>    <span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="n">EIGEN_ARM_PREFETCH</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">prefetch</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">int32_t</span><span class="o">*</span>  <span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="n">EIGEN_ARM_PREFETCH</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// FIXME only store the 2 first elements ?</span>
<span class="hll"><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">float</span>   <span class="n">pfirst</span><span class="o">&lt;</span><span class="n">Packet4f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="kt">float</span>   <span class="n">EIGEN_ALIGN16</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="n">vst1q_f32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>
</span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">int32_t</span> <span class="n">pfirst</span><span class="o">&lt;</span><span class="n">Packet4i</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="kt">int32_t</span> <span class="n">EIGEN_ALIGN16</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="n">vst1q_s32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4f</span> <span class="n">preverse</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">float32x2_t</span> <span class="n">a_lo</span><span class="p">,</span> <span class="n">a_hi</span><span class="p">;</span>
  <span class="n">Packet4f</span> <span class="n">a_r64</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/NEON/PacketMath.h#L600">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>596
597
598
599
600
601
602
603
604
605
606
607</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">HasHalfPacket</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

    <span class="n">HasDiv</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="hll">    <span class="c1">// FIXME check the Has*</span>
</span>    <span class="n">HasSin</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">HasCos</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">HasLog</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">HasExp</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">HasSqrt</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/NEON/PacketMath.h#L689">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>685
686
687
688
689
690
691
692
693
694
695
696</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">to</span><span class="p">[</span><span class="n">stride</span><span class="o">*</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vgetq_lane_f64</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">prefetch</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="n">EIGEN_ARM_PREFETCH</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span> <span class="p">}</span>

<span class="hll"><span class="c1">// FIXME only store the 2 first elements ?</span>
</span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">double</span> <span class="n">pfirst</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet2d</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vgetq_lane_f64</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2d</span> <span class="n">preverse</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet2d</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vcombine_f64</span><span class="p">(</span><span class="n">vget_high_f64</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">vget_low_f64</span><span class="p">(</span><span class="n">a</span><span class="p">));</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2d</span> <span class="n">pabs</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet2d</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vabsq_f64</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>

<span class="cp">#if EIGEN_COMP_CLANG &amp;&amp; defined(__apple_build_version__)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/SSE/Complex.h#L236">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>232
233
234
235
236
237
238
239
240
241
242
243</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">EIGEN_MAKE_CONJ_HELPER_CPLX_REAL</span><span class="p">(</span><span class="n">Packet2cf</span><span class="p">,</span><span class="n">Packet4f</span><span class="p">)</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2cf</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO optimize it for SSE3 and 4</span>
</span>  <span class="n">Packet2cf</span> <span class="n">res</span> <span class="o">=</span> <span class="n">conj_helper</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="p">,</span><span class="n">Packet2cf</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
  <span class="kr">__m128</span> <span class="n">s</span> <span class="o">=</span> <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">,</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">Packet2cf</span><span class="p">(</span><span class="n">_mm_div_ps</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">v</span><span class="p">,</span><span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">_mm_castsi128_ps</span><span class="p">(</span><span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">_mm_castps_si128</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mh">0xb1</span><span class="p">)))));</span>
<span class="p">}</span>

<span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2cf</span> <span class="n">pcplxflip</span><span class="cm">/* &lt;Packet2cf&gt; */</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/SSE/Complex.h#L313">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>309
310
311
312
313
314
315
316
317
318
319</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">por</span>    <span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Packet1cd</span><span class="p">(</span><span class="n">_mm_or_pd</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">v</span><span class="p">,</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">));</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pxor</span>   <span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Packet1cd</span><span class="p">(</span><span class="n">_mm_xor_pd</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">v</span><span class="p">,</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">));</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pandnot</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Packet1cd</span><span class="p">(</span><span class="n">_mm_andnot_pd</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">v</span><span class="p">,</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">));</span> <span class="p">}</span>

<span class="hll"><span class="c1">// FIXME force unaligned load, this is a temporary fix</span>
</span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pload</span> <span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span> <span class="n">EIGEN_DEBUG_ALIGNED_LOAD</span> <span class="k">return</span> <span class="n">Packet1cd</span><span class="p">(</span><span class="n">pload</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">((</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">));</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">ploadu</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span> <span class="n">EIGEN_DEBUG_UNALIGNED_LOAD</span> <span class="k">return</span> <span class="n">Packet1cd</span><span class="p">(</span><span class="n">ploadu</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">((</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">));</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span>  <span class="n">from</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* here we really have to use unaligned loads :( */</span> <span class="k">return</span> <span class="n">ploadu</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/SSE/Complex.h#L323">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>319
320
321
322
323
324
325
326
327
328
329
330</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="cm">/* here we really have to use unaligned loads :( */</span> <span class="k">return</span> <span class="n">ploadu</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">ploaddup</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>

<span class="hll"><span class="c1">// FIXME force unaligned store, this is a temporary fix</span>
</span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">pstore</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span>   <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="n">EIGEN_DEBUG_ALIGNED_STORE</span> <span class="n">pstore</span><span class="p">((</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">to</span><span class="p">,</span> <span class="n">Packet2d</span><span class="p">(</span><span class="n">from</span><span class="p">.</span><span class="n">v</span><span class="p">));</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">pstoreu</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span>   <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="n">EIGEN_DEBUG_UNALIGNED_STORE</span> <span class="n">pstoreu</span><span class="p">((</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">to</span><span class="p">,</span> <span class="n">Packet2d</span><span class="p">(</span><span class="n">from</span><span class="p">.</span><span class="n">v</span><span class="p">));</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">prefetch</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span>   <span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="n">_mm_prefetch</span><span class="p">((</span><span class="n">SsePrefetchPtrType</span><span class="p">)(</span><span class="n">addr</span><span class="p">),</span> <span class="n">_MM_HINT_T0</span><span class="p">);</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>  <span class="n">pfirst</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/SSE/Complex.h#L358">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>354
355
356
357
358
359
360
361
362
363
364
365</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">palign_impl</span><span class="o">&lt;</span><span class="n">Offset</span><span class="p">,</span><span class="n">Packet1cd</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="cm">/*first*/</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="cm">/*second*/</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME is it sure we never have to align a Packet1cd?</span>
</span>    <span class="c1">// Even though a std::complex&lt;double&gt; has 16 bytes, it is not necessarily aligned on a 16 bytes boundary...</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">conj_helper</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="p">,</span> <span class="n">Packet1cd</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pmadd</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/SSE/Complex.h#L421">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>417
418
419
420
421
422
423
424
425
426
427
428</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">EIGEN_MAKE_CONJ_HELPER_CPLX_REAL</span><span class="p">(</span><span class="n">Packet1cd</span><span class="p">,</span><span class="n">Packet2d</span><span class="p">)</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO optimize it for SSE3 and 4</span>
</span>  <span class="n">Packet1cd</span> <span class="n">res</span> <span class="o">=</span> <span class="n">conj_helper</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="p">,</span><span class="n">Packet1cd</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
  <span class="kr">__m128d</span> <span class="n">s</span> <span class="o">=</span> <span class="n">_mm_mul_pd</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">,</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">Packet1cd</span><span class="p">(</span><span class="n">_mm_div_pd</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">_mm_add_pd</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">_mm_shuffle_pd</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">))));</span>
<span class="p">}</span>

<span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pcplxflip</span><span class="cm">/* &lt;Packet1cd&gt; */</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/SSE/PacketMath.h#L172">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>168
169
170
171
172
173
174
175
176
177
178
179</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#endif</span>

<span class="cp">#if EIGEN_COMP_MSVC==1500</span>
<span class="c1">// Workaround MSVC 9 internal compiler error.</span>
<span class="hll"><span class="c1">// TODO: It has been detected with win64 builds (amd64), so let&#39;s check whether it also happens in 32bits+SSE mode</span>
</span><span class="c1">// TODO: let&#39;s check whether there does not exist a better fix, like adding a pset0() function. (it crashed on pset1(0)).</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4f</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet4f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span>  <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set_ps</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2d</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set_pd</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4i</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet4i</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span>    <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set_epi32</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
<span class="cp">#else</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4f</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet4f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span>  <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set_ps1</span><span class="p">(</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2d</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set1_pd</span><span class="p">(</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/SSE/PacketMath.h#L173">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>169
170
171
172
173
174
175
176
177
178
179</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#if EIGEN_COMP_MSVC==1500</span>
<span class="c1">// Workaround MSVC 9 internal compiler error.</span>
<span class="c1">// TODO: It has been detected with win64 builds (amd64), so let&#39;s check whether it also happens in 32bits+SSE mode</span>
<span class="c1">// TODO: let&#39;s check whether there does not exist a better fix, like adding a pset0() function. (it crashed on pset1(0)).</span>
<span class="hll"><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4f</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet4f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span>  <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set_ps</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
</span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2d</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set_pd</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4i</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet4i</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span>    <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set_epi32</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">,</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
<span class="cp">#else</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4f</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet4f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span>  <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set_ps1</span><span class="p">(</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2d</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set1_pd</span><span class="p">(</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4i</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet4i</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span>    <span class="n">from</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_mm_set1_epi32</span><span class="p">(</span><span class="n">from</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/SSE/PacketMath.h#L611">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>607
608
609
610
611
612
613
614
615
616
617
618</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">int</span> <span class="n">predux_mul</span><span class="o">&lt;</span><span class="n">Packet4i</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// after some experiments, it is seems this is the fastest way to implement it</span>
  <span class="c1">// for GCC (eg., reusing pmul is very slow !)</span>
<span class="hll">  <span class="c1">// TODO try to call _mm_mul_epu32 directly</span>
</span>  <span class="n">EIGEN_ALIGN16</span> <span class="kt">int</span> <span class="n">aux</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="n">pstore</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="k">return</span>  <span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">aux</span><span class="p">[</span><span class="mi">3</span><span class="p">]);;</span>
<span class="p">}</span>

<span class="c1">// min</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">float</span> <span class="n">predux_min</span><span class="o">&lt;</span><span class="n">Packet4f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/ZVector/Complex.h#L256">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>252
253
254
255
256
257
258
259
260
261
262
263</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">palign_impl</span><span class="o">&lt;</span><span class="n">Offset</span><span class="p">,</span><span class="n">Packet1cd</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="cm">/*first*/</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="cm">/*second*/</span><span class="p">)</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME is it sure we never have to align a Packet1cd?</span>
</span>    <span class="c1">// Even though a std::complex&lt;double&gt; has 16 bytes, it is not necessarily aligned on a 16 bytes boundary...</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">Offset</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">palign_impl</span><span class="o">&lt;</span><span class="n">Offset</span><span class="p">,</span><span class="n">Packet2cf</span><span class="o">&gt;</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/ZVector/Complex.h#L344">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>340
341
342
343
344
345
346
347
348
349
350
351</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">EIGEN_MAKE_CONJ_HELPER_CPLX_REAL</span><span class="p">(</span><span class="n">Packet1cd</span><span class="p">,</span><span class="n">Packet2d</span><span class="p">)</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO optimize it for AltiVec</span>
</span>  <span class="n">Packet1cd</span> <span class="n">res</span> <span class="o">=</span> <span class="n">conj_helper</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="p">,</span><span class="n">Packet1cd</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
  <span class="n">Packet2d</span> <span class="n">s</span> <span class="o">=</span> <span class="n">vec_madd</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">p2d_ZERO_</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">Packet1cd</span><span class="p">(</span><span class="n">pdiv</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">vec_perm</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p16uc_REVERSE64</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2cf</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/ZVector/Complex.h#L352">Complex.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>348
349
350
351
352
353
354
355
356
357
358
359</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2cf</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet2cf</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet2cf</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO optimize it for AltiVec</span>
</span>  <span class="n">Packet2cf</span> <span class="n">res</span><span class="p">;</span>
  <span class="n">res</span><span class="p">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">res</span><span class="p">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdiv</span><span class="o">&lt;</span><span class="n">Packet1cd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet1cd</span> <span class="n">pcplxflip</span><span class="cm">/*&lt;Packet1cd&gt;*/</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet1cd</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/ZVector/PacketMath.h#L340">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>336
337
338
339
340
341
342
343
344
345
346
347</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4i</span> <span class="n">pload</span><span class="o">&lt;</span><span class="n">Packet4i</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span>     <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// FIXME: No intrinsic yet</span>
</span>  <span class="n">EIGEN_DEBUG_ALIGNED_LOAD</span>
  <span class="n">Packet</span> <span class="o">*</span><span class="n">vfrom</span><span class="p">;</span>
  <span class="n">vfrom</span> <span class="o">=</span> <span class="p">(</span><span class="n">Packet</span> <span class="o">*</span><span class="p">)</span> <span class="n">from</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">vfrom</span><span class="o">-&gt;</span><span class="n">v4i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4f</span> <span class="n">pload</span><span class="o">&lt;</span><span class="n">Packet4f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">*</span>   <span class="n">from</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/ZVector/PacketMath.h#L349">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>345
346
347
348
349
350
351
352
353
354
355</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4f</span> <span class="n">pload</span><span class="o">&lt;</span><span class="n">Packet4f</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">*</span>   <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// FIXME: No intrinsic yet</span>
</span>  <span class="n">EIGEN_DEBUG_ALIGNED_LOAD</span>
  <span class="n">Packet4f</span> <span class="n">vfrom</span><span class="p">;</span>
  <span class="n">vfrom</span><span class="p">.</span><span class="n">v4f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_ld2f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">from</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">vfrom</span><span class="p">.</span><span class="n">v4f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_ld2f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">from</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="k">return</span> <span class="n">vfrom</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/ZVector/PacketMath.h#L359">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>355
356
357
358
359
360
361
362
363
364
365
366</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet2d</span> <span class="n">pload</span><span class="o">&lt;</span><span class="n">Packet2d</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// FIXME: No intrinsic yet</span>
</span>  <span class="n">EIGEN_DEBUG_ALIGNED_LOAD</span>
  <span class="n">Packet</span> <span class="o">*</span><span class="n">vfrom</span><span class="p">;</span>
  <span class="n">vfrom</span> <span class="o">=</span> <span class="p">(</span><span class="n">Packet</span> <span class="o">*</span><span class="p">)</span> <span class="n">from</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">vfrom</span><span class="o">-&gt;</span><span class="n">v2d</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">pstore</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span>       <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet4i</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/ZVector/PacketMath.h#L368">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>364
365
366
367
368
369
370
371
372
373
374
375</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">pstore</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span>       <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet4i</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// FIXME: No intrinsic yet</span>
</span>  <span class="n">EIGEN_DEBUG_ALIGNED_STORE</span>
  <span class="n">Packet</span> <span class="o">*</span><span class="n">vto</span><span class="p">;</span>
  <span class="n">vto</span> <span class="o">=</span> <span class="p">(</span><span class="n">Packet</span> <span class="o">*</span><span class="p">)</span> <span class="n">to</span><span class="p">;</span>
  <span class="n">vto</span><span class="o">-&gt;</span><span class="n">v4i</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">pstore</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span>   <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet4f</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/ZVector/PacketMath.h#L377">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>373
374
375
376
377
378
379
380
381
382
383
384</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">pstore</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span>   <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet4f</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// FIXME: No intrinsic yet</span>
</span>  <span class="n">EIGEN_DEBUG_ALIGNED_STORE</span>
  <span class="n">vec_st2f</span><span class="p">(</span><span class="n">from</span><span class="p">.</span><span class="n">v4f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">vec_st2f</span><span class="p">(</span><span class="n">from</span><span class="p">.</span><span class="n">v4f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>


<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">pstore</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span>   <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet2d</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/Eigen/src/Core/arch/ZVector/PacketMath.h#L386">PacketMath.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>382
383
384
385
386
387
388
389
390
391</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span> <span class="n">pstore</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span>   <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">Packet2d</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// FIXME: No intrinsic yet</span>
  <span class="n">EIGEN_DEBUG_ALIGNED_STORE</span>
<span class="hll">  <span class="n">Packet</span> <span class="o">*</span><span class="n">vto</span><span class="p">;</span>
</span>  <span class="n">vto</span> <span class="o">=</span> <span class="p">(</span><span class="n">Packet</span> <span class="o">*</span><span class="p">)</span> <span class="n">to</span><span class="p">;</span>
  <span class="n">vto</span><span class="o">-&gt;</span><span class="n">v2d</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">Packet4i</span> <span class="n">pset1</span><span class="o">&lt;</span><span class="n">Packet4i</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span>    <span class="n">from</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h#L117">TensorAssign.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>113
114
115
116
117
118
119
120
121
122
123
124</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="k">const</span> <span class="n">Dimensions</span><span class="o">&amp;</span> <span class="n">dimensions</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="c1">// The dimensions of the lhs and the rhs tensors should be equal to prevent</span>
    <span class="c1">// overflows and ensure the result is fully initialized.</span>
<span class="hll">    <span class="c1">// TODO: use left impl instead if right impl dimensions are known at compile time.</span>
</span>    <span class="k">return</span> <span class="n">m_rightImpl</span><span class="p">.</span><span class="n">dimensions</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">bool</span> <span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="n">Scalar</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eigen_assert</span><span class="p">(</span><span class="n">dimensions_match</span><span class="p">(</span><span class="n">m_leftImpl</span><span class="p">.</span><span class="n">dimensions</span><span class="p">(),</span> <span class="n">m_rightImpl</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()));</span>
    <span class="n">m_leftImpl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">// If the lhs provides raw access to its storage area (i.e. if m_leftImpl.data() returns a non</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h#L170">TensorBroadcasting.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>166
167
168
169
170
171
172
173
174
175
176
177</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="k">return</span> <span class="nf">coeffRowMajor</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="hll">  <span class="c1">// TODO: attempt to speed this up. The integer divisions and modulo are slow</span>
</span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">CoeffReturnType</span> <span class="n">coeffColMajor</span><span class="p">(</span><span class="n">Index</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="n">Index</span> <span class="n">inputIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">NumDims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Index</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">index</span> <span class="o">/</span> <span class="n">m_outputStrides</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">index_statically_eq</span><span class="o">&lt;</span><span class="n">Broadcast</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">eigen_assert</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">m_impl</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()[</span><span class="n">i</span><span class="p">]);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h#L284">TensorBroadcasting.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>280
281
282
283
284
285
286
287
288
289
290
291</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">inputIndex</span> <span class="o">+=</span> <span class="n">innermostLoc</span><span class="p">;</span>

<span class="hll">    <span class="c1">// Todo: this could be extended to the second dimension if we&#39;re not</span>
</span>    <span class="c1">// broadcasting alongside the first dimension, and so on.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">innermostLoc</span> <span class="o">+</span> <span class="n">PacketSize</span> <span class="o">&lt;=</span> <span class="n">m_impl</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">m_impl</span><span class="p">.</span><span class="k">template</span> <span class="n">packet</span><span class="o">&lt;</span><span class="n">Unaligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputIndex</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">EIGEN_ALIGN_MAX</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">remove_const</span><span class="o">&lt;</span><span class="n">CoeffReturnType</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">values</span><span class="p">[</span><span class="n">PacketSize</span><span class="p">];</span>
      <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_impl</span><span class="p">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">inputIndex</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PacketSize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h#L336">TensorBroadcasting.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>332
333
334
335
336
337
338
339
340
341
342
343</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">inputIndex</span> <span class="o">+=</span> <span class="n">innermostLoc</span><span class="p">;</span>

<span class="hll">    <span class="c1">// Todo: this could be extended to the second dimension if we&#39;re not</span>
</span>    <span class="c1">// broadcasting alongside the first dimension, and so on.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">innermostLoc</span> <span class="o">+</span> <span class="n">PacketSize</span> <span class="o">&lt;=</span> <span class="n">m_impl</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()[</span><span class="n">NumDims</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">m_impl</span><span class="p">.</span><span class="k">template</span> <span class="n">packet</span><span class="o">&lt;</span><span class="n">Unaligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputIndex</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">EIGEN_ALIGN_MAX</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">remove_const</span><span class="o">&lt;</span><span class="n">CoeffReturnType</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">values</span><span class="p">[</span><span class="n">PacketSize</span><span class="p">];</span>
      <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_impl</span><span class="p">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">inputIndex</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PacketSize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h#L179">TensorConcatenation.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>175
176
177
178
179
180
181
182
183
184
185</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="k">const</span> <span class="n">Dimensions</span><span class="o">&amp;</span> <span class="n">dimensions</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_dimensions</span><span class="p">;</span> <span class="p">}</span>

<span class="hll">  <span class="c1">// TODO(phli): Add short-circuit memcpy evaluation if underlying data are linear?</span>
</span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">bool</span> <span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="n">Scalar</span><span class="o">*</span> <span class="cm">/*data*/</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">m_leftImpl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">m_rightImpl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h#L193">TensorConcatenation.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>189
190
191
192
193
194
195
196
197
198
199
200</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">m_leftImpl</span><span class="p">.</span><span class="n">cleanup</span><span class="p">();</span>
    <span class="n">m_rightImpl</span><span class="p">.</span><span class="n">cleanup</span><span class="p">();</span>
  <span class="p">}</span>

<span class="hll">  <span class="c1">// TODO(phli): attempt to speed this up. The integer divisions and modulo are slow.</span>
</span>  <span class="c1">// See CL/76180724 comments for more ideas.</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">CoeffReturnType</span> <span class="n">coeff</span><span class="p">(</span><span class="n">Index</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="c1">// Collect dimension-wise indices (subs).</span>
    <span class="n">array</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span> <span class="n">NumDims</span><span class="o">&gt;</span> <span class="n">subs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Layout</span><span class="p">)</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ColMajor</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">NumDims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h#L247">TensorConcatenation.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>243
244
245
246
247
248
249
250
251
252
253</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="k">return</span> <span class="n">m_rightImpl</span><span class="p">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">right_index</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="hll">  <span class="c1">// TODO(phli): Add a real vectorization.</span>
</span>  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">LoadMode</span><span class="o">&gt;</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">PacketReturnType</span> <span class="n">packet</span><span class="p">(</span><span class="n">Index</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">packetSize</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">unpacket_traits</span><span class="o">&lt;</span><span class="n">PacketReturnType</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">;</span>
    <span class="n">EIGEN_STATIC_ASSERT</span><span class="p">((</span><span class="n">packetSize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span> <span class="n">YOU_MADE_A_PROGRAMMING_MISTAKE</span><span class="p">)</span>
    <span class="n">eigen_assert</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">packetSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">dimensions</span><span class="p">().</span><span class="n">TotalSize</span><span class="p">());</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h#L433">TensorContractionCuda.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>429
430
431
432
433
434
435
436
437
438
439</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c1">//     each do 8 writes into global memory. We can just overwrite the shared</span>
  <span class="c1">//     memory from the problem we just solved.</span>
  <span class="c1">// (2) is slightly faster than (1) due to less branching and more ILP</span>

<span class="hll">  <span class="c1">// TODO: won&#39;t yield much gain, but could just use currently unused shared mem</span>
</span>  <span class="c1">//       and then we won&#39;t have to sync</span>
  <span class="c1">// wait for shared mem to be out of use</span>
  <span class="n">__syncthreads</span><span class="p">();</span>

<span class="cp">#define writeResultShmem(i, j)                                          \</span>
<span class="cp">  lhs_shmem[i + 8 * threadIdx.y + 64 * threadIdx.z + 512 * j] = res(i, j); \</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h#L469">TensorContractionCuda.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>465
466
467
468
469
470
471
472
473
474
475
476</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">const</span> <span class="kt">int</span> <span class="n">max_j_write</span> <span class="o">=</span> <span class="n">numext</span><span class="o">::</span><span class="n">mini</span><span class="p">((</span><span class="kt">int</span><span class="p">)((</span><span class="n">n_size</span> <span class="o">-</span> <span class="n">base_n</span> <span class="o">-</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">max_i_write</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">max_j_write</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">      <span class="c1">// TODO: can i trade bank conflicts for coalesced writes?</span>
</span>      <span class="n">Scalar</span> <span class="n">val0</span> <span class="o">=</span> <span class="n">lhs_shmem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">0</span><span class="p">];</span>
      <span class="n">Scalar</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">lhs_shmem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">1</span><span class="p">];</span>
      <span class="n">Scalar</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">lhs_shmem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
      <span class="n">Scalar</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">lhs_shmem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">3</span><span class="p">];</span>
      <span class="n">Scalar</span> <span class="n">val4</span> <span class="o">=</span> <span class="n">lhs_shmem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">4</span><span class="p">];</span>
      <span class="n">Scalar</span> <span class="n">val5</span> <span class="o">=</span> <span class="n">lhs_shmem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">5</span><span class="p">];</span>
      <span class="n">Scalar</span> <span class="n">val6</span> <span class="o">=</span> <span class="n">lhs_shmem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">6</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h#L348">TensorContractionMapper.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>344
345
346
347
348
349
350
351
352
353
354
355</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">typedef</span> <span class="n">Self</span> <span class="n">LinearMapper</span><span class="p">;</span>

  <span class="k">enum</span> <span class="p">{</span>
    <span class="c1">// We can use direct offsets iff the parent mapper supports then and we can compute the strides.</span>
<span class="hll">    <span class="c1">// TODO: we should also enable direct offsets for the Rhs case.</span>
</span>    <span class="n">UseDirectOffsets</span> <span class="o">=</span> <span class="n">ParentMapper</span><span class="o">::</span><span class="n">DirectOffsets</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">side</span> <span class="o">==</span> <span class="n">Lhs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inner_dim_contiguous</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">array_size</span><span class="o">&lt;</span><span class="n">contract_t</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">};</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="nf">TensorContractionSubMapper</span><span class="p">(</span><span class="k">const</span> <span class="n">ParentMapper</span><span class="o">&amp;</span> <span class="n">base_mapper</span><span class="p">,</span> <span class="n">Index</span> <span class="n">vert_offset</span><span class="p">,</span> <span class="n">Index</span> <span class="n">horiz_offset</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">m_base_mapper</span><span class="p">(</span><span class="n">base_mapper</span><span class="p">),</span> <span class="n">m_vert_offset</span><span class="p">(</span><span class="n">vert_offset</span><span class="p">),</span> <span class="n">m_horiz_offset</span><span class="p">(</span><span class="n">horiz_offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Bake the offsets into the buffer used by the base mapper whenever possible. This avoids the need to recompute</span>
    <span class="c1">// this offset every time we attempt to access a coefficient.</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h#L208">TensorContractionThreadPool.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>204
205
206
207
208
209
210
211
212
213
214
215</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">contractionCost</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">bm</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">bk</span><span class="p">,</span> <span class="n">shard_by_col</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="n">TensorCostModel</span><span class="o">&lt;</span><span class="n">ThreadPoolDevice</span><span class="o">&gt;::</span><span class="n">numThreads</span><span class="p">(</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_device</span><span class="p">.</span><span class="n">numThreads</span><span class="p">());</span>

<span class="hll">    <span class="c1">// TODO(dvyukov): this is a stop-gap to prevent regressions while the cost</span>
</span>    <span class="c1">// model is not tuned. Remove this when the cost model is tuned.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">num_threads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// The single-threaded algorithm should be faster in this case.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="k">template</span> <span class="n">evalGemv</span><span class="o">&lt;</span><span class="n">lhs_inner_dim_contiguous</span><span class="p">,</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h#L390">TensorContractionThreadPool.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>386
387
388
389
390
391
392
393
394
395
396
397</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="kt">void</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// Kick off packing of the first slice.</span>
      <span class="n">signal_switch</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="c1">// Wait for overall completion.</span>
<span class="hll">      <span class="c1">// TODO(dvyukov): this wait can lead to deadlock.</span>
</span>      <span class="c1">// If nthreads contractions are concurrently submitted from worker</span>
      <span class="c1">// threads, this wait will block all worker threads and the system will</span>
      <span class="c1">// deadlock.</span>
      <span class="n">done_</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
    <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h#L774">TensorContractionThreadPool.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>770
771
772
773
774
775
776
777
778
779
780
781</pre></div></td><td class="code"><div class="highlight"><pre><span></span>                                                   <span class="n">rhs_inner_dim_reordered</span><span class="p">,</span> <span class="n">Unaligned</span><span class="o">&gt;</span> <span class="n">RhsMapper</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">blas_data_mapper</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">ColMajor</span><span class="o">&gt;</span> <span class="n">OutputMapper</span><span class="p">;</span>

<span class="hll">    <span class="c1">// TODO: packing could be faster sometimes if we supported row major tensor mappers</span>
</span>    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">gemm_pack_lhs</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="k">typename</span> <span class="n">LhsMapper</span><span class="o">::</span><span class="n">SubMapper</span><span class="p">,</span> <span class="n">Traits</span><span class="o">::</span><span class="n">mr</span><span class="p">,</span>
                                    <span class="n">Traits</span><span class="o">::</span><span class="n">LhsProgress</span><span class="p">,</span> <span class="n">ColMajor</span><span class="o">&gt;</span> <span class="n">LhsPacker</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">gemm_pack_rhs</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="k">typename</span> <span class="n">RhsMapper</span><span class="o">::</span><span class="n">SubMapper</span><span class="p">,</span> <span class="n">Traits</span><span class="o">::</span><span class="n">nr</span><span class="p">,</span> <span class="n">ColMajor</span><span class="o">&gt;</span> <span class="n">RhsPacker</span><span class="p">;</span>

    <span class="c1">// TODO: replace false, false with conjugate values?</span>
    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">gebp_kernel</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span> <span class="n">RhsScalar</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">OutputMapper</span><span class="p">,</span>
                                  <span class="n">Traits</span><span class="o">::</span><span class="n">mr</span><span class="p">,</span> <span class="n">Traits</span><span class="o">::</span><span class="n">nr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="n">GebpKernel</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h#L779">TensorContractionThreadPool.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>775
776
777
778
779
780
781
782
783
784
785
786</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">gemm_pack_lhs</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="k">typename</span> <span class="n">LhsMapper</span><span class="o">::</span><span class="n">SubMapper</span><span class="p">,</span> <span class="n">Traits</span><span class="o">::</span><span class="n">mr</span><span class="p">,</span>
                                    <span class="n">Traits</span><span class="o">::</span><span class="n">LhsProgress</span><span class="p">,</span> <span class="n">ColMajor</span><span class="o">&gt;</span> <span class="n">LhsPacker</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">gemm_pack_rhs</span><span class="o">&lt;</span><span class="n">RhsScalar</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="k">typename</span> <span class="n">RhsMapper</span><span class="o">::</span><span class="n">SubMapper</span><span class="p">,</span> <span class="n">Traits</span><span class="o">::</span><span class="n">nr</span><span class="p">,</span> <span class="n">ColMajor</span><span class="o">&gt;</span> <span class="n">RhsPacker</span><span class="p">;</span>

<span class="hll">    <span class="c1">// TODO: replace false, false with conjugate values?</span>
</span>    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">gebp_kernel</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span> <span class="n">RhsScalar</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">OutputMapper</span><span class="p">,</span>
                                  <span class="n">Traits</span><span class="o">::</span><span class="n">mr</span><span class="p">,</span> <span class="n">Traits</span><span class="o">::</span><span class="n">nr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="n">GebpKernel</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">packLhsArg</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span> <span class="n">LhsMapper</span><span class="p">,</span> <span class="n">Index</span><span class="o">&gt;</span> <span class="n">packLArg</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">internal</span><span class="o">::</span><span class="n">packRhsAndKernelArg</span><span class="o">&lt;</span><span class="n">LhsScalar</span><span class="p">,</span> <span class="n">RhsScalar</span><span class="p">,</span> <span class="n">RhsMapper</span><span class="p">,</span> <span class="n">OutputMapper</span><span class="p">,</span> <span class="n">Index</span><span class="o">&gt;</span> <span class="n">packRKArg</span><span class="p">;</span>

    <span class="c1">// initialize data mappers</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h#L830">TensorContractionThreadPool.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>826
827
828
829
830
831
832
833
834
835
836</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="n">blockAs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">LhsScalar</span> <span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_device</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">sizeA</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LhsScalar</span><span class="p">))));</span>
    <span class="p">}</span>

    <span class="c1">// To circumvent alignment issues, I&#39;m just going to separately allocate the memory for each thread</span>
<span class="hll">    <span class="c1">// TODO: is this too much memory to allocate? This simplifies coding a lot, but is wasteful.</span>
</span>    <span class="c1">//       Other options: (1) reuse memory when a thread finishes. con: tricky</span>
    <span class="c1">//                      (2) allocate block B memory in each thread. con: overhead</span>
    <span class="n">MaxSizeVector</span><span class="o">&lt;</span><span class="n">RhsScalar</span> <span class="o">*&gt;</span> <span class="n">blockBs</span><span class="p">(</span><span class="n">n_blocks</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">blockBs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">RhsScalar</span> <span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_device</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">sizeB</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RhsScalar</span><span class="p">))));</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h#L1067">TensorConvolution.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">TensorOpCost</span>
  <span class="n">costPerCoeff</span><span class="p">(</span><span class="kt">bool</span> <span class="n">vectorized</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO(rmlarsen): FIXME: For now, this is just a copy of the CPU cost</span>
</span>    <span class="c1">// model.</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">m_kernelImpl</span><span class="p">.</span><span class="n">dimensions</span><span class="p">().</span><span class="n">TotalSize</span><span class="p">();</span>
    <span class="c1">// We ignore the use of fused multiply-add.</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">convolve_compute_cost</span> <span class="o">=</span>
        <span class="n">TensorOpCost</span><span class="o">::</span><span class="n">AddCost</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+</span> <span class="n">TensorOpCost</span><span class="o">::</span><span class="n">MulCost</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">firstIndex_compute_cost</span> <span class="o">=</span>
        <span class="n">NumDims</span> <span class="o">*</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h#L27">TensorCostModel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// Class storing the cost of evaluating a tensor expression in terms of the</span>
<span class="c1">// estimated number of operand bytes loads, bytes stored, and compute cycles.</span>
<span class="k">class</span> <span class="nc">TensorOpCost</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
<span class="hll">  <span class="c1">// TODO(rmlarsen): Fix the scalar op costs in Eigen proper. Even a simple</span>
</span>  <span class="c1">// model based on minimal reciprocal throughput numbers from Intel or</span>
  <span class="c1">// Agner Fog&#39;s tables would be better than what is there now.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ArgType</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">int</span> <span class="n">MulCost</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">internal</span><span class="o">::</span><span class="n">functor_traits</span><span class="o">&lt;</span>
        <span class="n">internal</span><span class="o">::</span><span class="n">scalar_product_op</span><span class="o">&lt;</span><span class="n">ArgType</span><span class="p">,</span> <span class="n">ArgType</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">Cost</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h#L96">TensorCostModel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">bytes_loaded_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">bytes_stored_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

<span class="hll">  <span class="c1">// TODO(rmlarsen): Define min in terms of total cost, not elementwise.</span>
</span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">TensorOpCost</span> <span class="n">cwiseMin</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">TensorOpCost</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">bytes_loaded</span> <span class="o">=</span> <span class="n">numext</span><span class="o">::</span><span class="n">mini</span><span class="p">(</span><span class="n">bytes_loaded_</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">bytes_loaded</span><span class="p">());</span>
    <span class="kt">double</span> <span class="n">bytes_stored</span> <span class="o">=</span> <span class="n">numext</span><span class="o">::</span><span class="n">mini</span><span class="p">(</span><span class="n">bytes_stored_</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">bytes_stored</span><span class="p">());</span>
    <span class="kt">double</span> <span class="n">compute_cycles</span> <span class="o">=</span> <span class="n">numext</span><span class="o">::</span><span class="n">mini</span><span class="p">(</span><span class="n">compute_cycles_</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">compute_cycles</span><span class="p">());</span>
    <span class="k">return</span> <span class="nf">TensorOpCost</span><span class="p">(</span><span class="n">bytes_loaded</span><span class="p">,</span> <span class="n">bytes_stored</span><span class="p">,</span> <span class="n">compute_cycles</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h#L105">TensorCostModel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>101
102
103
104
105
106
107
108
109
110
111
112</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="kt">double</span> <span class="n">compute_cycles</span> <span class="o">=</span> <span class="n">numext</span><span class="o">::</span><span class="n">mini</span><span class="p">(</span><span class="n">compute_cycles_</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">compute_cycles</span><span class="p">());</span>
    <span class="k">return</span> <span class="nf">TensorOpCost</span><span class="p">(</span><span class="n">bytes_loaded</span><span class="p">,</span> <span class="n">bytes_stored</span><span class="p">,</span> <span class="n">compute_cycles</span><span class="p">);</span>
  <span class="p">}</span>

<span class="hll">  <span class="c1">// TODO(rmlarsen): Define max in terms of total cost, not elementwise.</span>
</span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">TensorOpCost</span> <span class="n">cwiseMax</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">TensorOpCost</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">bytes_loaded</span> <span class="o">=</span> <span class="n">numext</span><span class="o">::</span><span class="n">maxi</span><span class="p">(</span><span class="n">bytes_loaded_</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">bytes_loaded</span><span class="p">());</span>
    <span class="kt">double</span> <span class="n">bytes_stored</span> <span class="o">=</span> <span class="n">numext</span><span class="o">::</span><span class="n">maxi</span><span class="p">(</span><span class="n">bytes_stored_</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">bytes_stored</span><span class="p">());</span>
    <span class="kt">double</span> <span class="n">compute_cycles</span> <span class="o">=</span> <span class="n">numext</span><span class="o">::</span><span class="n">maxi</span><span class="p">(</span><span class="n">compute_cycles_</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">compute_cycles</span><span class="p">());</span>
    <span class="k">return</span> <span class="nf">TensorOpCost</span><span class="p">(</span><span class="n">bytes_loaded</span><span class="p">,</span> <span class="n">bytes_stored</span><span class="p">,</span> <span class="n">compute_cycles</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h#L157">TensorCostModel.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>153
154
155
156
157
158
159
160
161
162
163
164</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="kt">double</span> <span class="n">bytes_stored_</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">compute_cycles_</span><span class="p">;</span>
<span class="p">};</span>

<span class="hll"><span class="c1">// TODO(rmlarsen): Implement a policy that chooses an &quot;optimal&quot; number of theads</span>
</span><span class="c1">// in [1:max_threads] instead of just switching multi-threading off for small</span>
<span class="c1">// work units.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Device</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TensorCostModel</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Scaling from Eigen compute cost to device cycles.</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kDeviceCyclesPerComputeCycle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h#L137">TensorCustomOp.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>133
134
135
136
137
138
139
140
141
142
143
144</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="n">internal</span><span class="o">::</span><span class="n">ploadt</span><span class="o">&lt;</span><span class="n">PacketReturnType</span><span class="p">,</span> <span class="n">LoadMode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_result</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">TensorOpCost</span> <span class="n">costPerCoeff</span><span class="p">(</span><span class="kt">bool</span> <span class="n">vectorized</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO(rmlarsen): Extend CustomOp API to return its cost estimate.</span>
</span>    <span class="k">return</span> <span class="n">TensorOpCost</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">CoeffReturnType</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">,</span> <span class="n">PacketSize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">CoeffReturnType</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_result</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">protected</span><span class="o">:</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kt">void</span> <span class="n">evalTo</span><span class="p">(</span><span class="n">Scalar</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h#L292">TensorCustomOp.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>288
289
290
291
292
293
294
295
296
297
298
299</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="n">internal</span><span class="o">::</span><span class="n">ploadt</span><span class="o">&lt;</span><span class="n">PacketReturnType</span><span class="p">,</span> <span class="n">LoadMode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_result</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">TensorOpCost</span> <span class="n">costPerCoeff</span><span class="p">(</span><span class="kt">bool</span> <span class="n">vectorized</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO(rmlarsen): Extend CustomOp API to return its cost estimate.</span>
</span>    <span class="k">return</span> <span class="n">TensorOpCost</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">CoeffReturnType</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">,</span> <span class="n">PacketSize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">CoeffReturnType</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_result</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">protected</span><span class="o">:</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kt">void</span> <span class="n">evalTo</span><span class="p">(</span><span class="n">Scalar</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h#L24">TensorDevice.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  *
  * Example:
  *    C.device(EIGEN_GPU) = A + B;
  *
<span class="hll">  * Todo: operator *= and /=.
</span>  */

template &lt;typename ExpressionType, typename DeviceType&gt; class TensorDevice {
  public:
    TensorDevice(const DeviceType&amp; device, ExpressionType&amp; expression) : m_device(device), m_expression(expression) {}

    template&lt;typename OtherDerived&gt;
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h#L192">TensorDeviceCuda.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>188
189
190
191
192
193
194
195
196
197
198
199</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>
  <span class="k">explicit</span> <span class="n">GpuDevice</span><span class="p">(</span><span class="k">const</span> <span class="n">StreamInterface</span><span class="o">*</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_blocks</span><span class="p">)</span> <span class="o">:</span> <span class="n">stream_</span><span class="p">(</span><span class="n">stream</span><span class="p">),</span> <span class="n">max_blocks_</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eigen_assert</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
  <span class="p">}</span>
<span class="hll">  <span class="c1">// TODO(bsteiner): This is an internal API, we should not expose it.</span>
</span>  <span class="n">EIGEN_STRONG_INLINE</span> <span class="k">const</span> <span class="n">cudaStream_t</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">stream_</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">void</span><span class="o">*</span> <span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num_bytes</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">stream_</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h#L249">TensorDeviceCuda.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>245
246
247
248
249
250
251
252
253
254
255
256</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#endif</span>
  <span class="p">}</span>

  <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">size_t</span> <span class="n">numThreads</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME</span>
</span>    <span class="k">return</span> <span class="mi">32</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">size_t</span> <span class="n">firstLevelCacheSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// FIXME</span>
    <span class="k">return</span> <span class="mi">48</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h#L254">TensorDeviceCuda.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>250
251
252
253
254
255
256
257
258
259
260
261</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="mi">32</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">size_t</span> <span class="n">firstLevelCacheSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
<span class="hll">    <span class="c1">// FIXME</span>
</span>    <span class="k">return</span> <span class="mi">48</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">size_t</span> <span class="n">lastLevelCacheSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// We won&#39;t try to take advantage of the l2 cache for the time being, and</span>
    <span class="c1">// there is no l3 cache on cuda devices.</span>
    <span class="k">return</span> <span class="n">firstLevelCacheSize</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h#L322">TensorDeviceCuda.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>318
319
320
321
322
323
324
325
326
327
328
329</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="o">&lt;&lt;&lt;</span> <span class="p">(</span><span class="n">gridsize</span><span class="p">),</span> <span class="p">(</span><span class="n">blocksize</span><span class="p">),</span> <span class="p">(</span><span class="n">sharedmem</span><span class="p">),</span> <span class="p">(</span><span class="n">device</span><span class="p">).</span><span class="n">stream</span><span class="p">()</span> <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">__VA_ARGS__</span><span class="p">);</span>   \
  <span class="n">assert</span><span class="p">(</span><span class="n">cudaGetLastError</span><span class="p">()</span> <span class="o">==</span> <span class="n">cudaSuccess</span><span class="p">);</span>


<span class="hll"><span class="c1">// FIXME: Should be device and kernel specific.</span>
</span><span class="cp">#ifdef __CUDACC__</span>
<span class="k">static</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setCudaSharedMemConfig</span><span class="p">(</span><span class="n">cudaSharedMemConfig</span> <span class="n">config</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef __CUDA_ARCH__</span>
  <span class="n">cudaError_t</span> <span class="n">status</span> <span class="o">=</span> <span class="n">cudaDeviceSetSharedMemConfig</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
  <span class="n">EIGEN_UNUSED_VARIABLE</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">cudaSuccess</span><span class="p">);</span>
<span class="cp">#else</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h#L108">TensorDimensions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>104
105
106
107
108
109
110
111
112
113
114</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="nf">Sizes</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">DenseIndex</span><span class="o">&gt;</span>
  <span class="k">explicit</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">Sizes</span><span class="p">(</span><span class="k">const</span> <span class="n">array</span><span class="o">&lt;</span><span class="n">DenseIndex</span><span class="p">,</span> <span class="n">Base</span><span class="o">::</span><span class="n">count</span><span class="o">&gt;&amp;</span> <span class="cm">/*indices*/</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// todo: add assertion</span>
<span class="hll">  <span class="p">}</span>
</span><span class="cp">#if EIGEN_HAS_VARIADIC_TEMPLATES</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">DenseIndex</span><span class="o">&gt;</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">Sizes</span><span class="p">(</span><span class="n">DenseIndex</span><span class="p">...)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">explicit</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">Sizes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="o">&gt;</span> <span class="cm">/*l*/</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// todo: add assertion</span>
  <span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h#L113">TensorDimensions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>109
110
111
112
113
114
115
116
117
118
119
120</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>
<span class="cp">#if EIGEN_HAS_VARIADIC_TEMPLATES</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">DenseIndex</span><span class="o">&gt;</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">Sizes</span><span class="p">(</span><span class="n">DenseIndex</span><span class="p">...)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">explicit</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">Sizes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="o">&gt;</span> <span class="cm">/*l*/</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="c1">// todo: add assertion</span>
</span>  <span class="p">}</span>
<span class="cp">#endif</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Sizes</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="cm">/*other*/</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// add assertion failure if the size of other is different</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h#L170">TensorDimensions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>166
167
168
169
170
171
172
173
174
175
176</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">Sizes</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">DenseIndex</span><span class="o">&gt;</span>
  <span class="k">explicit</span> <span class="n">Sizes</span><span class="p">(</span><span class="k">const</span> <span class="n">array</span><span class="o">&lt;</span><span class="n">DenseIndex</span><span class="p">,</span> <span class="n">Base</span><span class="o">::</span><span class="n">count</span><span class="o">&gt;&amp;</span> <span class="cm">/*indices*/</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// todo: add assertion</span>
<span class="hll">  <span class="p">}</span>
</span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Sizes</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="cm">/*other*/</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// add assertion failure if the size of other is different</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

<span class="cp">#if EIGEN_HAS_VARIADIC_TEMPLATES</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h#L180">TensorDimensions.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>176
177
178
179
180
181
182
183
184
185
186</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#if EIGEN_HAS_VARIADIC_TEMPLATES</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">DenseIndex</span><span class="o">&gt;</span> <span class="n">Sizes</span><span class="p">(</span><span class="n">DenseIndex</span><span class="p">...</span> <span class="cm">/*indices*/</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">explicit</span> <span class="n">Sizes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// todo: add assertion</span>
<span class="hll">  <span class="p">}</span>
</span><span class="cp">#else</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="k">explicit</span> <span class="n">Sizes</span><span class="p">(</span><span class="k">const</span> <span class="n">DenseIndex</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">Sizes</span><span class="p">(</span><span class="k">const</span> <span class="n">DenseIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">DenseIndex</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">Sizes</span><span class="p">(</span><span class="k">const</span> <span class="n">DenseIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">DenseIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">DenseIndex</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h#L22">TensorEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  * \brief The tensor evaluator classes.
  *
  * These classes are responsible for the evaluation of the tensor expression.
  *
<span class="hll">  * TODO: add support for more types of expressions, in particular expressions
</span>  * leading to lvalues (slicing, reshaping, etc...)
  */

// Generic evaluator
template&lt;typename Derived, typename Device&gt;
struct TensorEvaluator
{
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h#L392">TensorEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>388
389
390
391
392
393
394
395
396
397
398
399</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TensorEvaluator</span><span class="o">&lt;</span><span class="n">LeftArgType</span><span class="p">,</span> <span class="n">Device</span><span class="o">&gt;::</span><span class="n">Dimensions</span> <span class="n">Dimensions</span><span class="p">;</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="k">const</span> <span class="n">Dimensions</span><span class="o">&amp;</span> <span class="n">dimensions</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO: use right impl instead if right impl dimensions are known at compile time.</span>
</span>    <span class="k">return</span> <span class="n">m_leftImpl</span><span class="p">.</span><span class="n">dimensions</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">bool</span> <span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="n">CoeffReturnType</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_leftImpl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">m_rightImpl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h#L487">TensorEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>483
484
485
486
487
488
489
490
491
492
493
494</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TensorEvaluator</span><span class="o">&lt;</span><span class="n">Arg1Type</span><span class="p">,</span> <span class="n">Device</span><span class="o">&gt;::</span><span class="n">Dimensions</span> <span class="n">Dimensions</span><span class="p">;</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="k">const</span> <span class="n">Dimensions</span><span class="o">&amp;</span> <span class="n">dimensions</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO: use arg2 or arg3 dimensions if they are known at compile time.</span>
</span>    <span class="k">return</span> <span class="n">m_arg1Impl</span><span class="p">.</span><span class="n">dimensions</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">bool</span> <span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="n">CoeffReturnType</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_arg1Impl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">m_arg2Impl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">m_arg3Impl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h#L577">TensorEvaluator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>573
574
575
576
577
578
579
580
581
582
583
584</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TensorEvaluator</span><span class="o">&lt;</span><span class="n">IfArgType</span><span class="p">,</span> <span class="n">Device</span><span class="o">&gt;::</span><span class="n">Dimensions</span> <span class="n">Dimensions</span><span class="p">;</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="k">const</span> <span class="n">Dimensions</span><span class="o">&amp;</span> <span class="n">dimensions</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO: use then or else impl instead if they happen to be known at compile time.</span>
</span>    <span class="k">return</span> <span class="n">m_condImpl</span><span class="p">.</span><span class="n">dimensions</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">bool</span> <span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="n">CoeffReturnType</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_condImpl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">m_thenImpl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">m_elseImpl</span><span class="p">.</span><span class="n">evalSubExprsIfNeeded</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h#L84">TensorExpr.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>80
81
82
83
84
85
86
87
88
89
90
91</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">UnaryOp</span><span class="p">,</span> <span class="k">typename</span> <span class="n">XprType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">TensorCwiseUnaryOp</span><span class="o">&lt;</span><span class="n">UnaryOp</span><span class="p">,</span> <span class="n">XprType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="o">:</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="hll">  <span class="c1">// TODO(phli): Add InputScalar, InputPacket.  Check references to</span>
</span>  <span class="c1">// current Scalar/Packet to see if the intent is Input or Output.</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">result_of</span><span class="o">&lt;</span><span class="n">UnaryOp</span><span class="p">(</span><span class="k">typename</span> <span class="n">XprType</span><span class="o">::</span><span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">Scalar</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">XprType</span><span class="o">&gt;</span> <span class="n">XprTraits</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">XprType</span><span class="o">::</span><span class="n">Nested</span> <span class="n">XprTypeNested</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">XprTypeNested</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">_XprTypeNested</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">NumDimensions</span> <span class="o">=</span> <span class="n">XprTraits</span><span class="o">::</span><span class="n">NumDimensions</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">Layout</span> <span class="o">=</span> <span class="n">XprTraits</span><span class="o">::</span><span class="n">Layout</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h#L114">TensorExpr.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>110
111
112
113
114
115
116
117
118
119
120
121</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">UnaryOp</span><span class="p">,</span> <span class="k">typename</span> <span class="n">XprType</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TensorCwiseUnaryOp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TensorBase</span><span class="o">&lt;</span><span class="n">TensorCwiseUnaryOp</span><span class="o">&lt;</span><span class="n">UnaryOp</span><span class="p">,</span> <span class="n">XprType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ReadOnlyAccessors</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
<span class="hll">    <span class="c1">// TODO(phli): Add InputScalar, InputPacket.  Check references to</span>
</span>    <span class="c1">// current Scalar/Packet to see if the intent is Input or Output.</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">traits</span><span class="o">&lt;</span><span class="n">TensorCwiseUnaryOp</span><span class="o">&gt;::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">Real</span> <span class="n">RealScalar</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Scalar</span> <span class="n">CoeffReturnType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">nested</span><span class="o">&lt;</span><span class="n">TensorCwiseUnaryOp</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">Nested</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">traits</span><span class="o">&lt;</span><span class="n">TensorCwiseUnaryOp</span><span class="o">&gt;::</span><span class="n">StorageKind</span> <span class="n">StorageKind</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">traits</span><span class="o">&lt;</span><span class="n">TensorCwiseUnaryOp</span><span class="o">&gt;::</span><span class="n">Index</span> <span class="n">Index</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h#L146">TensorExpr.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>142
143
144
145
146
147
148
149
150
151
152
153</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">TensorCwiseBinaryOp</span><span class="o">&lt;</span><span class="n">BinaryOp</span><span class="p">,</span> <span class="n">LhsXprType</span><span class="p">,</span> <span class="n">RhsXprType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
  <span class="c1">// Type promotion to handle the case where the types of the lhs and the rhs</span>
  <span class="c1">// are different.</span>
<span class="hll">  <span class="c1">// TODO(phli): Add Lhs/RhsScalar, Lhs/RhsPacket.  Check references to</span>
</span>  <span class="c1">// current Scalar/Packet to see if the intent is Inputs or Output.</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">result_of</span><span class="o">&lt;</span>
      <span class="n">BinaryOp</span><span class="p">(</span><span class="k">typename</span> <span class="n">LhsXprType</span><span class="o">::</span><span class="n">Scalar</span><span class="p">,</span>
               <span class="k">typename</span> <span class="n">RhsXprType</span><span class="o">::</span><span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">Scalar</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">LhsXprType</span><span class="o">&gt;</span> <span class="n">XprTraits</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">promote_storage_type</span><span class="o">&lt;</span>
      <span class="k">typename</span> <span class="n">traits</span><span class="o">&lt;</span><span class="n">LhsXprType</span><span class="o">&gt;::</span><span class="n">StorageKind</span><span class="p">,</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h#L190">TensorExpr.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>186
187
188
189
190
191
192
193
194
195
196
197</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOp</span><span class="p">,</span> <span class="k">typename</span> <span class="n">LhsXprType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">RhsXprType</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TensorCwiseBinaryOp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TensorBase</span><span class="o">&lt;</span><span class="n">TensorCwiseBinaryOp</span><span class="o">&lt;</span><span class="n">BinaryOp</span><span class="p">,</span> <span class="n">LhsXprType</span><span class="p">,</span> <span class="n">RhsXprType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ReadOnlyAccessors</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
<span class="hll">    <span class="c1">// TODO(phli): Add Lhs/RhsScalar, Lhs/RhsPacket.  Check references to</span>
</span>    <span class="c1">// current Scalar/Packet to see if the intent is Inputs or Output.</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">traits</span><span class="o">&lt;</span><span class="n">TensorCwiseBinaryOp</span><span class="o">&gt;::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">NumTraits</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">Real</span> <span class="n">RealScalar</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Scalar</span> <span class="n">CoeffReturnType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">nested</span><span class="o">&lt;</span><span class="n">TensorCwiseBinaryOp</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">Nested</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">traits</span><span class="o">&lt;</span><span class="n">TensorCwiseBinaryOp</span><span class="o">&gt;::</span><span class="n">StorageKind</span> <span class="n">StorageKind</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">traits</span><span class="o">&lt;</span><span class="n">TensorCwiseBinaryOp</span><span class="o">&gt;::</span><span class="n">Index</span> <span class="n">Index</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h#L24">TensorFFT.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  * \ingroup CXX11_Tensor_Module
  *
  * \brief Tensor FFT class.
  *
<span class="hll">  * TODO:
</span>  * Vectorize the Cooley Tukey and the Bluestein algorithm
  * Add support for multithreaded evaluation
  * Improve the performance on GPU
  */

template &lt;bool NeedUprade&gt; struct MakeComplex {
  template &lt;typename T&gt;
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h#L339">TensorFixedSize.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>335
336
337
338
339
340
341
342
343
344
345</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">EIGEN_DEVICE_FUNC</span>
    <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">TensorFixedSize</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TensorFixedSize</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// FIXME: check that the dimensions of other match the dimensions of *this.</span>
<span class="hll">      <span class="c1">// Unfortunately this isn&#39;t possible yet when the rhs is an expression.</span>
</span>      <span class="k">typedef</span> <span class="n">TensorAssignOp</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorFixedSize</span><span class="o">&gt;</span> <span class="n">Assign</span><span class="p">;</span>
      <span class="n">Assign</span> <span class="nf">assign</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
      <span class="n">internal</span><span class="o">::</span><span class="n">TensorExecutor</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Assign</span><span class="p">,</span> <span class="n">DefaultDevice</span><span class="o">&gt;::</span><span class="n">run</span><span class="p">(</span><span class="n">assign</span><span class="p">,</span> <span class="n">DefaultDevice</span><span class="p">());</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherDerived</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h#L350">TensorFixedSize.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>346
347
348
349
350
351
352
353
354
355
356</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherDerived</span><span class="o">&gt;</span>
    <span class="n">EIGEN_DEVICE_FUNC</span>
    <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">TensorFixedSize</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">OtherDerived</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
<span class="hll">      <span class="c1">// FIXME: check that the dimensions of other match the dimensions of *this.</span>
</span>      <span class="c1">// Unfortunately this isn&#39;t possible yet when the rhs is an expression.</span>
      <span class="k">typedef</span> <span class="n">TensorAssignOp</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span> <span class="k">const</span> <span class="n">OtherDerived</span><span class="o">&gt;</span> <span class="n">Assign</span><span class="p">;</span>
      <span class="n">Assign</span> <span class="nf">assign</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
      <span class="n">internal</span><span class="o">::</span><span class="n">TensorExecutor</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Assign</span><span class="p">,</span> <span class="n">DefaultDevice</span><span class="o">&gt;::</span><span class="n">run</span><span class="p">(</span><span class="n">assign</span><span class="p">,</span> <span class="n">DefaultDevice</span><span class="p">());</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h#L150">TensorGenerator.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>146
147
148
149
150
151
152
153
154
155
156</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">TensorOpCost</span>
  <span class="n">costPerCoeff</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="hll">    <span class="c1">// TODO(rmlarsen): This is just a placeholder. Define interface to make</span>
</span>    <span class="c1">// generators return their cost.</span>
    <span class="k">return</span> <span class="n">TensorOpCost</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TensorOpCost</span><span class="o">::</span><span class="n">AddCost</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+</span>
                                  <span class="n">TensorOpCost</span><span class="o">::</span><span class="n">MulCost</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">Scalar</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h#L187">TensorInflation.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>183
184
185
186
187
188
189
190
191
192
193</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="k">return</span> <span class="nf">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="hll">  <span class="c1">// TODO(yangke): optimize this function so that we can detect and produce</span>
</span>  <span class="c1">// all-zero packets</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">LoadMode</span><span class="o">&gt;</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">PacketReturnType</span> <span class="n">packet</span><span class="p">(</span><span class="n">Index</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="n">EIGEN_STATIC_ASSERT</span><span class="p">((</span><span class="n">PacketSize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span> <span class="n">YOU_MADE_A_PROGRAMMING_MISTAKE</span><span class="p">)</span>
    <span class="n">eigen_assert</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">PacketSize</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">dimensions</span><span class="p">().</span><span class="n">TotalSize</span><span class="p">());</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h#L284">TensorMorphing.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>280
281
282
283
284
285
286
287
288
289
290
291</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="k">const</span> <span class="n">Sizes</span> <span class="n">m_sizes</span><span class="p">;</span>
<span class="p">};</span>


<span class="hll"><span class="c1">// Fixme: figure out the exact threshold</span>
</span><span class="k">namespace</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Index</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Device</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">MemcpyTriggerForSlicing</span> <span class="p">{</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">MemcpyTriggerForSlicing</span><span class="p">(</span><span class="k">const</span> <span class="n">Device</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">)</span> <span class="o">:</span> <span class="n">threshold_</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">device</span><span class="p">.</span><span class="n">numThreads</span><span class="p">())</span> <span class="p">{</span> <span class="p">}</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="p">()(</span><span class="n">Index</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">threshold_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">Index</span> <span class="n">threshold_</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h#L59">TensorRandom.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>55
56
57
58
59
60
61
62
63
64
65</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="kt">unsigned</span> <span class="n">PCG_XSH_RS_generator</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">  <span class="c1">// TODO: Unify with the implementation in the non blocking thread pool.</span>
</span>  <span class="kt">uint64_t</span> <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
  <span class="c1">// Update the internal state</span>
  <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">current</span> <span class="o">*</span> <span class="mi">6364136223846793005ULL</span> <span class="o">+</span> <span class="mh">0xda3e39cb94b95bdbULL</span><span class="p">;</span>
  <span class="c1">// Generate the random output (using the PCG-XSH-RS scheme)</span>
  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">((</span><span class="n">current</span> <span class="o">^</span> <span class="p">(</span><span class="n">current</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">22</span> <span class="o">+</span> <span class="p">(</span><span class="n">current</span> <span class="o">&gt;&gt;</span> <span class="mi">61</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h#L609">TensorReduction.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>605
606
607
608
609
610
611
612
613
614
615
616</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="k">return</span> <span class="n">reducer</span><span class="p">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">accum</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="hll">  <span class="c1">// TODO(bsteiner): provide a more efficient implementation.</span>
</span>  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">LoadMode</span><span class="o">&gt;</span>
  <span class="n">EIGEN_DEVICE_FUNC</span> <span class="n">EIGEN_STRONG_INLINE</span> <span class="n">PacketReturnType</span> <span class="n">packet</span><span class="p">(</span><span class="n">Index</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="n">EIGEN_STATIC_ASSERT</span><span class="p">((</span><span class="n">PacketSize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span> <span class="n">YOU_MADE_A_PROGRAMMING_MISTAKE</span><span class="p">)</span>
    <span class="n">eigen_assert</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">PacketSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">Index</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">array_prod</span><span class="p">(</span><span class="n">dimensions</span><span class="p">())));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">RunningOnGPU</span> <span class="o">&amp;&amp;</span> <span class="n">m_result</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h#L201">TensorReverse.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>197
198
199
200
201
202
203
204
205
206
207
208</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="p">{</span>
    <span class="n">EIGEN_STATIC_ASSERT</span><span class="p">((</span><span class="n">PacketSize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span> <span class="n">YOU_MADE_A_PROGRAMMING_MISTAKE</span><span class="p">)</span>
    <span class="n">eigen_assert</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">PacketSize</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">dimensions</span><span class="p">().</span><span class="n">TotalSize</span><span class="p">());</span>

<span class="hll">    <span class="c1">// TODO(ndjaitly): write a better packing routine that uses</span>
</span>    <span class="c1">// local structure.</span>
    <span class="n">EIGEN_ALIGN_MAX</span> <span class="k">typename</span> <span class="n">internal</span><span class="o">::</span><span class="n">remove_const</span><span class="o">&lt;</span><span class="n">CoeffReturnType</span><span class="o">&gt;::</span><span class="n">type</span>
                                                            <span class="n">values</span><span class="p">[</span><span class="n">PacketSize</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PacketSize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">PacketReturnType</span> <span class="n">rslt</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">pload</span><span class="o">&lt;</span><span class="n">PacketReturnType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h#L211">TensorScan.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>207
208
209
210
211
212
213
214
215
216
217
218</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">CoeffReturnType</span><span class="o">*</span> <span class="n">m_output</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// CPU implementation of scan</span>
<span class="hll"><span class="c1">// TODO(ibab) This single-threaded implementation should be parallelized,</span>
</span><span class="c1">// at least by running multiple scans at the same time.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Self</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Reducer</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Device</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ScanLauncher</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Self</span><span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Self</span><span class="o">::</span><span class="n">CoeffReturnType</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Index</span> <span class="n">total_size</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">array_prod</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">dimensions</span><span class="p">());</span>

    <span class="c1">// We fix the index along the scan axis to 0 and perform a</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h#L247">TensorScan.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>243
244
245
246
247
248
249
250
251
252
253</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#if defined(EIGEN_USE_GPU) &amp;&amp; defined(__CUDACC__)</span>

<span class="c1">// GPU implementation of scan</span>
<span class="c1">// TODO(ibab) This placeholder implementation performs multiple scans in</span>
<span class="hll"><span class="c1">// parallel, but it would be better to use a parallel scan algorithm and</span>
</span><span class="c1">// optimize memory access.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Self</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Reducer</span><span class="o">&gt;</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">ScanKernel</span><span class="p">(</span><span class="n">Self</span> <span class="n">self</span><span class="p">,</span> <span class="n">Index</span> <span class="n">total_size</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Self</span><span class="o">::</span><span class="n">CoeffReturnType</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Compute offset as in the CPU version</span>
  <span class="n">Index</span> <span class="n">val</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="n">Index</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="n">self</span><span class="p">.</span><span class="n">stride</span><span class="p">())</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">stride</span><span class="p">()</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">val</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">stride</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h#L169">TensorTraits.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>165
166
167
168
169
170
171
172
173
174
175
176</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">TensorRef</span><span class="o">&lt;</span><span class="n">PlainObjectType</span><span class="o">&gt;&amp;</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="hll"><span class="c1">// TODO nested&lt;&gt; does not exist anymore in Eigen/Core, and it thus has to be removed in favor of ref_selector.</span>
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">PlainObject</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">nested</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">ref_selector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar_</span><span class="p">,</span> <span class="kt">int</span> <span class="n">NumIndices_</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Options_</span><span class="p">,</span> <span class="k">typename</span> <span class="n">IndexType_</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">nested</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">Scalar_</span><span class="p">,</span> <span class="n">NumIndices_</span><span class="p">,</span> <span class="n">Options_</span><span class="p">,</span> <span class="n">IndexType_</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h#L148">NonBlockingThreadPool.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>144
145
146
147
148
149
150
151
152
153
154
155</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Steal</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Leave one thread spinning. This reduces latency.</span>
<span class="hll">          <span class="c1">// TODO(dvyukov): 1000 iterations is based on fair dice roll, tune it.</span>
</span>          <span class="c1">// Also, the time it takes to attempt to steal work 1000 times depends</span>
          <span class="c1">// on the size of the thread pool. However the speed at which the user</span>
          <span class="c1">// of the thread pool submit tasks is independent of the size of the</span>
          <span class="c1">// pool. Consider a time based limit instead.</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spinning_</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spinning_</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="nb">true</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">f</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">t</span> <span class="o">=</span> <span class="n">Steal</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/starry/_core/ops/lib/vendor/eigen_3.3.5/unsupported/Eigen/CXX11/src/util/EmulateArray.h#L181">EmulateArray.h</a>:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>177
178
179
180
181
182
183
184
185
186
187
188</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">T</span> <span class="n">dummy</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Comparison operator</span>
<span class="hll"><span class="c1">// Todo: implement !=, &lt;, &lt;=, &gt;,  and &gt;=</span>
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">EIGEN_DEVICE_FUNC</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/tests/greedy/test_exceptions_greedy.py#L43">test_exceptions_greedy.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>39
40
41
42
43
44
45
46
47
48
49</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="c1"># Bad `m`</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">map</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="c1"># TODO: It would be nice if `map[1, 3] = ...` raised</span>
<span class="hll">    <span class="c1"># an error, but currently it does nothing (silently).</span>
</span>
    <span class="c1"># Bad type</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">map</span><span class="p">[</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">5.7</span><span class="p">]</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">map</span><span class="p">[</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">5.7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/tests/greedy/test_light_delay_greedy.py#L13">test_light_delay_greedy.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">sec</span> <span class="o">=</span> <span class="n">starry</span><span class="o">.</span><span class="n">Secondary</span><span class="p">(</span><span class="n">starry</span><span class="o">.</span><span class="n">Map</span><span class="p">(),</span> <span class="n">porb</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">sys</span> <span class="o">=</span> <span class="n">starry</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">pri</span><span class="p">,</span> <span class="n">sec</span><span class="p">,</span> <span class="n">light_delay</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">sys</span><span class="o">.</span><span class="n">light_delay</span> <span class="ow">is</span> <span class="kc">True</span>

<span class="hll">    <span class="c1"># TODO: Add tests here.</span>
</span></pre></div>
</td></tr></table></div>
<p><a class="reference external" href="https://github.com/rodluger/starry/blob/7930784532c1f079ca2c39dbb103ea99d85b5740/tests/greedy/test_system_greedy.py#L87">test_system_greedy.py</a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>83
84
85
86
87</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="n">sys</span> <span class="o">=</span> <span class="n">starry</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">pri</span><span class="p">,</span> <span class="n">sec</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mi">50</span><span class="p">)))</span>
    <span class="n">flux</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">flux</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="hll">    <span class="c1"># TODO: Add an analytic validation here</span>
</span></pre></div>
</td></tr></table></div>
</div>


           </div>
           
          </div>
          <footer>
  
  <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
    
    <a href="coverage.html" class="btn btn-neutral float-right" title="Coverage reports" accesskey="n"
      rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
    
    
    <a href="developer.html" class="btn btn-neutral float-left" title="Developer" accesskey="p"
      rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
    
  </div>
  

  <hr />

  <div role="contentinfo">
    <p>
      
      &copy; Copyright 2019, Rodrigo Luger.
      <span class="lastupdated">
        Last updated on 2020 Jan 05 at 07:06:01 UTC.
      </span>

    </p>
  </div>
  
  
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a
    href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by
  <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>